/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(transparent)]
pub struct __BindgenFloat16(pub u16);
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const WINAPI_PARTITION_DESKTOP: u32 = 1;
pub const WINAPI_PARTITION_APP: u32 = 2;
pub const WINAPI_FAMILY_APP: u32 = 2;
pub const WINAPI_FAMILY_DESKTOP_APP: u32 = 3;
pub const WINAPI_FAMILY: u32 = 3;
pub const __MINGW64_VERSION_MAJOR: u32 = 11;
pub const __MINGW64_VERSION_MINOR: u32 = 0;
pub const __MINGW64_VERSION_BUGFIX: u32 = 1;
pub const __MINGW64_VERSION_RC: u32 = 0;
pub const __MINGW64_VERSION_STATE: &[u8; 6] = b"alpha\0";
pub const __MINGW32_MAJOR_VERSION: u32 = 3;
pub const __MINGW32_MINOR_VERSION: u32 = 11;
pub const _M_AMD64: u32 = 100;
pub const _M_X64: u32 = 100;
pub const __: u32 = 1;
pub const __MINGW_USE_UNDERSCORE_PREFIX: u32 = 0;
pub const __MINGW_HAVE_ANSI_C99_PRINTF: u32 = 1;
pub const __MINGW_HAVE_WIDE_C99_PRINTF: u32 = 1;
pub const __MINGW_HAVE_ANSI_C99_SCANF: u32 = 1;
pub const __MINGW_HAVE_WIDE_C99_SCANF: u32 = 1;
pub const __MINGW_SEC_WARN_STR : & [u8 ; 92] = b"This function or variable may be unsafe, use _CRT_SECURE_NO_WARNINGS to disable deprecation\0" ;
pub const __MINGW_MSVC2005_DEPREC_STR : & [u8 ; 117] = b"This POSIX function is deprecated beginning in Visual C++ 2005, use _CRT_NONSTDC_NO_DEPRECATE to disable deprecation\0" ;
pub const __MINGW_FORTIFY_LEVEL: u32 = 0;
pub const __MINGW_FORTIFY_VA_ARG: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const __USE_CRTIMP: u32 = 1;
pub const USE___UUIDOF: u32 = 0;
pub const __CRT__NO_INLINE: u32 = 1;
pub const __MSVCRT_VERSION__: u32 = 1792;
pub const _WIN32_WINNT: u32 = 2560;
pub const MINGW_HAS_SECURE_API: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const MINGW_HAS_DDK_H: u32 = 1;
pub const _CRT_PACKING: u32 = 8;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 253;
pub const _ARGMAX: u32 = 100;
pub const __USE_MINGW_ANSI_STDIO: u32 = 1;
pub const __STDC_WANT_SECURE_LIB__: u32 = 0;
pub const STRICT: u32 = 1;
pub const MAX_PATH: u32 = 260;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const _INC_CRT_UNICODE_MACROS: u32 = 2;
pub const __MINGW_PROCNAMEEXT_AW: &[u8; 2] = b"A\0";
pub const _UPPER: u32 = 1;
pub const _LOWER: u32 = 2;
pub const _DIGIT: u32 = 4;
pub const _SPACE: u32 = 8;
pub const _PUNCT: u32 = 16;
pub const _CONTROL: u32 = 32;
pub const _BLANK: u32 = 64;
pub const _HEX: u32 = 128;
pub const _LEADBYTE: u32 = 32768;
pub const _ALPHA: u32 = 259;
pub const ExceptionContinueExecution: u32 = 0;
pub const ExceptionContinueSearch: u32 = 1;
pub const ExceptionNestedException: u32 = 2;
pub const ExceptionCollidedUnwind: u32 = 3;
pub const ExceptionExecuteHandler: u32 = 4;
pub const EXCEPTION_EXECUTE_HANDLER: u32 = 1;
pub const EXCEPTION_CONTINUE_SEARCH: u32 = 0;
pub const EXCEPTION_CONTINUE_EXECUTION: i32 = -1;
pub const API_SET_PREFIX_NAME_A: &[u8; 5] = b"API-\0";
pub const API_SET_PREFIX_NAME_U: &[u8; 5] = b"API-\0";
pub const API_SET_EXTENSION_NAME_A: &[u8; 5] = b"EXT-\0";
pub const API_SET_EXTENSION_NAME_U: &[u8; 5] = b"EXT-\0";
pub const API_SET_SECTION_NAME: &[u8; 8] = b".apiset\0";
pub const API_SET_SCHEMA_SUFFIX: &[u8; 5] = b".sys\0";
pub const API_SET_LOAD_SCHEMA_ORDINAL: u32 = 1;
pub const API_SET_LOOKUP_ORDINAL: u32 = 2;
pub const API_SET_RELEASE_SCHEMA_ORDINAL: u32 = 3;
pub const ANYSIZE_ARRAY: u32 = 1;
pub const __FLAGCONSTRAINT: &[u8; 6] = b"=@ccc\0";
pub const _WIN32_WINNT_NT4: u32 = 1024;
pub const _WIN32_WINNT_WIN2K: u32 = 1280;
pub const _WIN32_WINNT_WINXP: u32 = 1281;
pub const _WIN32_WINNT_WS03: u32 = 1282;
pub const _WIN32_WINNT_WIN6: u32 = 1536;
pub const _WIN32_WINNT_VISTA: u32 = 1536;
pub const _WIN32_WINNT_WS08: u32 = 1536;
pub const _WIN32_WINNT_LONGHORN: u32 = 1536;
pub const _WIN32_WINNT_WIN7: u32 = 1537;
pub const _WIN32_WINNT_WIN8: u32 = 1538;
pub const _WIN32_WINNT_WINBLUE: u32 = 1539;
pub const _WIN32_WINNT_WINTHRESHOLD: u32 = 2560;
pub const _WIN32_WINNT_WIN10: u32 = 2560;
pub const _WIN32_IE_IE20: u32 = 512;
pub const _WIN32_IE_IE30: u32 = 768;
pub const _WIN32_IE_IE302: u32 = 770;
pub const _WIN32_IE_IE40: u32 = 1024;
pub const _WIN32_IE_IE401: u32 = 1025;
pub const _WIN32_IE_IE50: u32 = 1280;
pub const _WIN32_IE_IE501: u32 = 1281;
pub const _WIN32_IE_IE55: u32 = 1360;
pub const _WIN32_IE_IE60: u32 = 1536;
pub const _WIN32_IE_IE60SP1: u32 = 1537;
pub const _WIN32_IE_IE60SP2: u32 = 1539;
pub const _WIN32_IE_IE70: u32 = 1792;
pub const _WIN32_IE_IE80: u32 = 2048;
pub const _WIN32_IE_IE90: u32 = 2304;
pub const _WIN32_IE_IE100: u32 = 2560;
pub const _WIN32_IE_IE110: u32 = 2560;
pub const _WIN32_IE_NT4: u32 = 512;
pub const _WIN32_IE_NT4SP1: u32 = 512;
pub const _WIN32_IE_NT4SP2: u32 = 512;
pub const _WIN32_IE_NT4SP3: u32 = 770;
pub const _WIN32_IE_NT4SP4: u32 = 1025;
pub const _WIN32_IE_NT4SP5: u32 = 1025;
pub const _WIN32_IE_NT4SP6: u32 = 1280;
pub const _WIN32_IE_WIN98: u32 = 1025;
pub const _WIN32_IE_WIN98SE: u32 = 1280;
pub const _WIN32_IE_WINME: u32 = 1360;
pub const _WIN32_IE_WIN2K: u32 = 1281;
pub const _WIN32_IE_WIN2KSP1: u32 = 1281;
pub const _WIN32_IE_WIN2KSP2: u32 = 1281;
pub const _WIN32_IE_WIN2KSP3: u32 = 1281;
pub const _WIN32_IE_WIN2KSP4: u32 = 1281;
pub const _WIN32_IE_XP: u32 = 1536;
pub const _WIN32_IE_XPSP1: u32 = 1537;
pub const _WIN32_IE_XPSP2: u32 = 1539;
pub const _WIN32_IE_WS03: u32 = 1538;
pub const _WIN32_IE_WS03SP1: u32 = 1539;
pub const _WIN32_IE_WIN6: u32 = 1792;
pub const _WIN32_IE_LONGHORN: u32 = 1792;
pub const _WIN32_IE_WIN7: u32 = 2048;
pub const _WIN32_IE_WIN8: u32 = 2560;
pub const _WIN32_IE_WINBLUE: u32 = 2560;
pub const _WIN32_IE_WINTHRESHOLD: u32 = 2560;
pub const _WIN32_IE_WIN10: u32 = 2560;
pub const NTDDI_WIN2K: u32 = 83886080;
pub const NTDDI_WIN2KSP1: u32 = 83886336;
pub const NTDDI_WIN2KSP2: u32 = 83886592;
pub const NTDDI_WIN2KSP3: u32 = 83886848;
pub const NTDDI_WIN2KSP4: u32 = 83887104;
pub const NTDDI_WINXP: u32 = 83951616;
pub const NTDDI_WINXPSP1: u32 = 83951872;
pub const NTDDI_WINXPSP2: u32 = 83952128;
pub const NTDDI_WINXPSP3: u32 = 83952384;
pub const NTDDI_WINXPSP4: u32 = 83952640;
pub const NTDDI_WS03: u32 = 84017152;
pub const NTDDI_WS03SP1: u32 = 84017408;
pub const NTDDI_WS03SP2: u32 = 84017664;
pub const NTDDI_WS03SP3: u32 = 84017920;
pub const NTDDI_WS03SP4: u32 = 84018176;
pub const NTDDI_WIN6: u32 = 100663296;
pub const NTDDI_WIN6SP1: u32 = 100663552;
pub const NTDDI_WIN6SP2: u32 = 100663808;
pub const NTDDI_WIN6SP3: u32 = 100664064;
pub const NTDDI_WIN6SP4: u32 = 100664320;
pub const NTDDI_VISTA: u32 = 100663296;
pub const NTDDI_VISTASP1: u32 = 100663552;
pub const NTDDI_VISTASP2: u32 = 100663808;
pub const NTDDI_VISTASP3: u32 = 100664064;
pub const NTDDI_VISTASP4: u32 = 100664320;
pub const NTDDI_LONGHORN: u32 = 100663296;
pub const NTDDI_WS08: u32 = 100663552;
pub const NTDDI_WS08SP2: u32 = 100663808;
pub const NTDDI_WS08SP3: u32 = 100664064;
pub const NTDDI_WS08SP4: u32 = 100664320;
pub const NTDDI_WIN7: u32 = 100728832;
pub const NTDDI_WIN8: u32 = 100794368;
pub const NTDDI_WINBLUE: u32 = 100859904;
pub const NTDDI_WINTHRESHOLD: u32 = 167772160;
pub const NTDDI_WIN10: u32 = 167772160;
pub const NTDDI_WIN10_TH2: u32 = 167772161;
pub const NTDDI_WIN10_RS1: u32 = 167772162;
pub const NTDDI_WIN10_RS2: u32 = 167772163;
pub const NTDDI_WIN10_RS3: u32 = 167772164;
pub const NTDDI_WIN10_RS4: u32 = 167772165;
pub const NTDDI_WIN10_RS5: u32 = 167772166;
pub const NTDDI_WIN10_19H1: u32 = 167772167;
pub const NTDDI_WIN10_VB: u32 = 167772168;
pub const NTDDI_WIN10_MN: u32 = 167772169;
pub const NTDDI_WIN10_FE: u32 = 167772170;
pub const NTDDI_WIN10_CO: u32 = 167772171;
pub const NTDDI_WIN10_NI: u32 = 167772172;
pub const WDK_NTDDI_VERSION: u32 = 167772172;
pub const OSVERSION_MASK: u32 = 4294901760;
pub const SPVERSION_MASK: u32 = 65280;
pub const SUBVERSION_MASK: u32 = 255;
pub const WINVER: u32 = 2560;
pub const _WIN32_IE: u32 = 2560;
pub const MEMORY_ALLOCATION_ALIGNMENT: u32 = 16;
pub const ADDRESS_TAG_BIT: u64 = 4398046511104;
pub const X86_CACHE_ALIGNMENT_SIZE: u32 = 64;
pub const ARM_CACHE_ALIGNMENT_SIZE: u32 = 128;
pub const SYSTEM_CACHE_ALIGNMENT_SIZE: u32 = 64;
pub const PRAGMA_DEPRECATED_DDK: u32 = 0;
pub const UCSCHAR_INVALID_CHARACTER: u32 = 4294967295;
pub const MIN_UCSCHAR: u32 = 0;
pub const MAX_UCSCHAR: u32 = 1114111;
pub const APPLICATION_ERROR_MASK: u32 = 536870912;
pub const ERROR_SEVERITY_SUCCESS: u32 = 0;
pub const ERROR_SEVERITY_INFORMATIONAL: u32 = 1073741824;
pub const ERROR_SEVERITY_WARNING: u32 = 2147483648;
pub const ERROR_SEVERITY_ERROR: u32 = 3221225472;
pub const MAXLONGLONG: u64 = 9223372036854775807;
pub const UNICODE_STRING_MAX_CHARS: u32 = 32767;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const MINCHAR: u32 = 128;
pub const MAXCHAR: u32 = 127;
pub const MINSHORT: u32 = 32768;
pub const MAXSHORT: u32 = 32767;
pub const MINLONG: u32 = 2147483648;
pub const MAXLONG: u32 = 2147483647;
pub const MAXBYTE: u32 = 255;
pub const MAXWORD: u32 = 65535;
pub const MAXDWORD: u32 = 4294967295;
pub const ENCLAVE_SHORT_ID_LENGTH: u32 = 16;
pub const ENCLAVE_LONG_ID_LENGTH: u32 = 32;
pub const VER_WORKSTATION_NT: u32 = 1073741824;
pub const VER_SERVER_NT: u32 = 2147483648;
pub const VER_SUITE_SMALLBUSINESS: u32 = 1;
pub const VER_SUITE_ENTERPRISE: u32 = 2;
pub const VER_SUITE_BACKOFFICE: u32 = 4;
pub const VER_SUITE_COMMUNICATIONS: u32 = 8;
pub const VER_SUITE_TERMINAL: u32 = 16;
pub const VER_SUITE_SMALLBUSINESS_RESTRICTED: u32 = 32;
pub const VER_SUITE_EMBEDDEDNT: u32 = 64;
pub const VER_SUITE_DATACENTER: u32 = 128;
pub const VER_SUITE_SINGLEUSERTS: u32 = 256;
pub const VER_SUITE_PERSONAL: u32 = 512;
pub const VER_SUITE_BLADE: u32 = 1024;
pub const VER_SUITE_EMBEDDED_RESTRICTED: u32 = 2048;
pub const VER_SUITE_SECURITY_APPLIANCE: u32 = 4096;
pub const VER_SUITE_STORAGE_SERVER: u32 = 8192;
pub const VER_SUITE_COMPUTE_SERVER: u32 = 16384;
pub const VER_SUITE_WH_SERVER: u32 = 32768;
pub const VER_SUITE_MULTIUSERTS: u32 = 131072;
pub const PRODUCT_UNDEFINED: u32 = 0;
pub const PRODUCT_ULTIMATE: u32 = 1;
pub const PRODUCT_HOME_BASIC: u32 = 2;
pub const PRODUCT_HOME_PREMIUM: u32 = 3;
pub const PRODUCT_ENTERPRISE: u32 = 4;
pub const PRODUCT_HOME_BASIC_N: u32 = 5;
pub const PRODUCT_BUSINESS: u32 = 6;
pub const PRODUCT_STANDARD_SERVER: u32 = 7;
pub const PRODUCT_DATACENTER_SERVER: u32 = 8;
pub const PRODUCT_SMALLBUSINESS_SERVER: u32 = 9;
pub const PRODUCT_ENTERPRISE_SERVER: u32 = 10;
pub const PRODUCT_STARTER: u32 = 11;
pub const PRODUCT_DATACENTER_SERVER_CORE: u32 = 12;
pub const PRODUCT_STANDARD_SERVER_CORE: u32 = 13;
pub const PRODUCT_ENTERPRISE_SERVER_CORE: u32 = 14;
pub const PRODUCT_ENTERPRISE_SERVER_IA64: u32 = 15;
pub const PRODUCT_BUSINESS_N: u32 = 16;
pub const PRODUCT_WEB_SERVER: u32 = 17;
pub const PRODUCT_CLUSTER_SERVER: u32 = 18;
pub const PRODUCT_HOME_SERVER: u32 = 19;
pub const PRODUCT_STORAGE_EXPRESS_SERVER: u32 = 20;
pub const PRODUCT_STORAGE_STANDARD_SERVER: u32 = 21;
pub const PRODUCT_STORAGE_WORKGROUP_SERVER: u32 = 22;
pub const PRODUCT_STORAGE_ENTERPRISE_SERVER: u32 = 23;
pub const PRODUCT_SERVER_FOR_SMALLBUSINESS: u32 = 24;
pub const PRODUCT_SMALLBUSINESS_SERVER_PREMIUM: u32 = 25;
pub const PRODUCT_HOME_PREMIUM_N: u32 = 26;
pub const PRODUCT_ENTERPRISE_N: u32 = 27;
pub const PRODUCT_ULTIMATE_N: u32 = 28;
pub const PRODUCT_WEB_SERVER_CORE: u32 = 29;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT: u32 = 30;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY: u32 = 31;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING: u32 = 32;
pub const PRODUCT_SERVER_FOUNDATION: u32 = 33;
pub const PRODUCT_HOME_PREMIUM_SERVER: u32 = 34;
pub const PRODUCT_SERVER_FOR_SMALLBUSINESS_V: u32 = 35;
pub const PRODUCT_STANDARD_SERVER_V: u32 = 36;
pub const PRODUCT_DATACENTER_SERVER_V: u32 = 37;
pub const PRODUCT_SERVER_V: u32 = 37;
pub const PRODUCT_ENTERPRISE_SERVER_V: u32 = 38;
pub const PRODUCT_DATACENTER_SERVER_CORE_V: u32 = 39;
pub const PRODUCT_STANDARD_SERVER_CORE_V: u32 = 40;
pub const PRODUCT_ENTERPRISE_SERVER_CORE_V: u32 = 41;
pub const PRODUCT_HYPERV: u32 = 42;
pub const PRODUCT_STORAGE_EXPRESS_SERVER_CORE: u32 = 43;
pub const PRODUCT_STORAGE_STANDARD_SERVER_CORE: u32 = 44;
pub const PRODUCT_STORAGE_WORKGROUP_SERVER_CORE: u32 = 45;
pub const PRODUCT_STORAGE_ENTERPRISE_SERVER_CORE: u32 = 46;
pub const PRODUCT_STARTER_N: u32 = 47;
pub const PRODUCT_PROFESSIONAL: u32 = 48;
pub const PRODUCT_PROFESSIONAL_N: u32 = 49;
pub const PRODUCT_SB_SOLUTION_SERVER: u32 = 50;
pub const PRODUCT_SERVER_FOR_SB_SOLUTIONS: u32 = 51;
pub const PRODUCT_STANDARD_SERVER_SOLUTIONS: u32 = 52;
pub const PRODUCT_STANDARD_SERVER_SOLUTIONS_CORE: u32 = 53;
pub const PRODUCT_SB_SOLUTION_SERVER_EM: u32 = 54;
pub const PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM: u32 = 55;
pub const PRODUCT_SOLUTION_EMBEDDEDSERVER: u32 = 56;
pub const PRODUCT_SOLUTION_EMBEDDEDSERVER_CORE: u32 = 57;
pub const PRODUCT_PROFESSIONAL_EMBEDDED: u32 = 58;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_MGMT: u32 = 59;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_ADDL: u32 = 60;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_MGMTSVC: u32 = 61;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_ADDLSVC: u32 = 62;
pub const PRODUCT_SMALLBUSINESS_SERVER_PREMIUM_CORE: u32 = 63;
pub const PRODUCT_CLUSTER_SERVER_V: u32 = 64;
pub const PRODUCT_EMBEDDED: u32 = 65;
pub const PRODUCT_STARTER_E: u32 = 66;
pub const PRODUCT_HOME_BASIC_E: u32 = 67;
pub const PRODUCT_HOME_PREMIUM_E: u32 = 68;
pub const PRODUCT_PROFESSIONAL_E: u32 = 69;
pub const PRODUCT_ENTERPRISE_E: u32 = 70;
pub const PRODUCT_ULTIMATE_E: u32 = 71;
pub const PRODUCT_ENTERPRISE_EVALUATION: u32 = 72;
pub const PRODUCT_MULTIPOINT_STANDARD_SERVER: u32 = 76;
pub const PRODUCT_MULTIPOINT_PREMIUM_SERVER: u32 = 77;
pub const PRODUCT_STANDARD_EVALUATION_SERVER: u32 = 79;
pub const PRODUCT_DATACENTER_EVALUATION_SERVER: u32 = 80;
pub const PRODUCT_ENTERPRISE_N_EVALUATION: u32 = 84;
pub const PRODUCT_EMBEDDED_AUTOMOTIVE: u32 = 85;
pub const PRODUCT_EMBEDDED_INDUSTRY_A: u32 = 86;
pub const PRODUCT_THINPC: u32 = 87;
pub const PRODUCT_EMBEDDED_A: u32 = 88;
pub const PRODUCT_EMBEDDED_INDUSTRY: u32 = 89;
pub const PRODUCT_EMBEDDED_E: u32 = 90;
pub const PRODUCT_EMBEDDED_INDUSTRY_E: u32 = 91;
pub const PRODUCT_EMBEDDED_INDUSTRY_A_E: u32 = 92;
pub const PRODUCT_STORAGE_WORKGROUP_EVALUATION_SERVER: u32 = 95;
pub const PRODUCT_STORAGE_STANDARD_EVALUATION_SERVER: u32 = 96;
pub const PRODUCT_CORE_ARM: u32 = 97;
pub const PRODUCT_CORE_N: u32 = 98;
pub const PRODUCT_CORE_COUNTRYSPECIFIC: u32 = 99;
pub const PRODUCT_CORE_SINGLELANGUAGE: u32 = 100;
pub const PRODUCT_CORE_LANGUAGESPECIFIC: u32 = 100;
pub const PRODUCT_CORE: u32 = 101;
pub const PRODUCT_PROFESSIONAL_WMC: u32 = 103;
pub const PRODUCT_MOBILE_CORE: u32 = 104;
pub const PRODUCT_EMBEDDED_INDUSTRY_EVAL: u32 = 105;
pub const PRODUCT_EMBEDDED_INDUSTRY_E_EVAL: u32 = 106;
pub const PRODUCT_EMBEDDED_EVAL: u32 = 107;
pub const PRODUCT_EMBEDDED_E_EVAL: u32 = 108;
pub const PRODUCT_NANO_SERVER: u32 = 109;
pub const PRODUCT_CLOUD_STORAGE_SERVER: u32 = 110;
pub const PRODUCT_CORE_CONNECTED: u32 = 111;
pub const PRODUCT_PROFESSIONAL_STUDENT: u32 = 112;
pub const PRODUCT_CORE_CONNECTED_N: u32 = 113;
pub const PRODUCT_PROFESSIONAL_STUDENT_N: u32 = 114;
pub const PRODUCT_CORE_CONNECTED_SINGLELANGUAGE: u32 = 115;
pub const PRODUCT_CORE_CONNECTED_COUNTRYSPECIFIC: u32 = 116;
pub const PRODUCT_CONNECTED_CAR: u32 = 117;
pub const PRODUCT_INDUSTRY_HANDHELD: u32 = 118;
pub const PRODUCT_PPI_PRO: u32 = 119;
pub const PRODUCT_ARM64_SERVER: u32 = 120;
pub const PRODUCT_EDUCATION: u32 = 121;
pub const PRODUCT_EDUCATION_N: u32 = 122;
pub const PRODUCT_IOTUAP: u32 = 123;
pub const PRODUCT_CLOUD_HOST_INFRASTRUCTURE_SERVER: u32 = 124;
pub const PRODUCT_ENTERPRISE_S: u32 = 125;
pub const PRODUCT_ENTERPRISE_S_N: u32 = 126;
pub const PRODUCT_PROFESSIONAL_S: u32 = 127;
pub const PRODUCT_PROFESSIONAL_S_N: u32 = 128;
pub const PRODUCT_ENTERPRISE_S_EVALUATION: u32 = 129;
pub const PRODUCT_ENTERPRISE_S_N_EVALUATION: u32 = 130;
pub const PRODUCT_MOBILE_ENTERPRISE: u32 = 133;
pub const PRODUCT_HOLOGRAPHIC: u32 = 135;
pub const PRODUCT_HOLOGRAPHIC_BUSINESS: u32 = 136;
pub const PRODUCT_PRO_SINGLE_LANGUAGE: u32 = 138;
pub const PRODUCT_PRO_CHINA: u32 = 139;
pub const PRODUCT_ENTERPRISE_SUBSCRIPTION: u32 = 140;
pub const PRODUCT_ENTERPRISE_SUBSCRIPTION_N: u32 = 141;
pub const PRODUCT_DATACENTER_NANO_SERVER: u32 = 143;
pub const PRODUCT_STANDARD_NANO_SERVER: u32 = 144;
pub const PRODUCT_DATACENTER_A_SERVER_CORE: u32 = 145;
pub const PRODUCT_STANDARD_A_SERVER_CORE: u32 = 146;
pub const PRODUCT_DATACENTER_WS_SERVER_CORE: u32 = 147;
pub const PRODUCT_STANDARD_WS_SERVER_CORE: u32 = 148;
pub const PRODUCT_UTILITY_VM: u32 = 149;
pub const PRODUCT_DATACENTER_EVALUATION_SERVER_CORE: u32 = 159;
pub const PRODUCT_STANDARD_EVALUATION_SERVER_CORE: u32 = 160;
pub const PRODUCT_PRO_WORKSTATION: u32 = 161;
pub const PRODUCT_PRO_WORKSTATION_N: u32 = 162;
pub const PRODUCT_PRO_FOR_EDUCATION: u32 = 164;
pub const PRODUCT_PRO_FOR_EDUCATION_N: u32 = 165;
pub const PRODUCT_AZURE_SERVER_CORE: u32 = 168;
pub const PRODUCT_AZURE_NANO_SERVER: u32 = 169;
pub const PRODUCT_ENTERPRISEG: u32 = 171;
pub const PRODUCT_ENTERPRISEGN: u32 = 172;
pub const PRODUCT_SERVERRDSH: u32 = 175;
pub const PRODUCT_CLOUD: u32 = 178;
pub const PRODUCT_CLOUDN: u32 = 179;
pub const PRODUCT_HUBOS: u32 = 180;
pub const PRODUCT_ONECOREUPDATEOS: u32 = 182;
pub const PRODUCT_CLOUDE: u32 = 183;
pub const PRODUCT_IOTOS: u32 = 185;
pub const PRODUCT_CLOUDEN: u32 = 186;
pub const PRODUCT_IOTEDGEOS: u32 = 187;
pub const PRODUCT_IOTENTERPRISE: u32 = 188;
pub const PRODUCT_LITE: u32 = 189;
pub const PRODUCT_IOTENTERPRISES: u32 = 191;
pub const PRODUCT_XBOX_SYSTEMOS: u32 = 192;
pub const PRODUCT_XBOX_NATIVEOS: u32 = 193;
pub const PRODUCT_XBOX_GAMEOS: u32 = 194;
pub const PRODUCT_XBOX_ERAOS: u32 = 195;
pub const PRODUCT_XBOX_DURANGOHOSTOS: u32 = 196;
pub const PRODUCT_XBOX_SCARLETTHOSTOS: u32 = 197;
pub const PRODUCT_XBOX_KEYSTONE: u32 = 198;
pub const PRODUCT_AZURE_SERVER_CLOUDHOST: u32 = 199;
pub const PRODUCT_AZURE_SERVER_CLOUDMOS: u32 = 200;
pub const PRODUCT_CLOUDEDITIONN: u32 = 202;
pub const PRODUCT_CLOUDEDITION: u32 = 203;
pub const PRODUCT_AZURESTACKHCI_SERVER_CORE: u32 = 406;
pub const PRODUCT_DATACENTER_SERVER_AZURE_EDITION: u32 = 407;
pub const PRODUCT_DATACENTER_SERVER_CORE_AZURE_EDITION: u32 = 408;
pub const PRODUCT_UNLICENSED: u32 = 2882382797;
pub const LANG_NEUTRAL: u32 = 0;
pub const LANG_INVARIANT: u32 = 127;
pub const LANG_AFRIKAANS: u32 = 54;
pub const LANG_ALBANIAN: u32 = 28;
pub const LANG_ALSATIAN: u32 = 132;
pub const LANG_AMHARIC: u32 = 94;
pub const LANG_ARABIC: u32 = 1;
pub const LANG_ARMENIAN: u32 = 43;
pub const LANG_ASSAMESE: u32 = 77;
pub const LANG_AZERI: u32 = 44;
pub const LANG_AZERBAIJANI: u32 = 44;
pub const LANG_BANGLA: u32 = 69;
pub const LANG_BASHKIR: u32 = 109;
pub const LANG_BASQUE: u32 = 45;
pub const LANG_BELARUSIAN: u32 = 35;
pub const LANG_BENGALI: u32 = 69;
pub const LANG_BRETON: u32 = 126;
pub const LANG_BOSNIAN: u32 = 26;
pub const LANG_BOSNIAN_NEUTRAL: u32 = 30746;
pub const LANG_BULGARIAN: u32 = 2;
pub const LANG_CATALAN: u32 = 3;
pub const LANG_CENTRAL_KURDISH: u32 = 146;
pub const LANG_CHEROKEE: u32 = 92;
pub const LANG_CHINESE: u32 = 4;
pub const LANG_CHINESE_SIMPLIFIED: u32 = 4;
pub const LANG_CHINESE_TRADITIONAL: u32 = 31748;
pub const LANG_CORSICAN: u32 = 131;
pub const LANG_CROATIAN: u32 = 26;
pub const LANG_CZECH: u32 = 5;
pub const LANG_DANISH: u32 = 6;
pub const LANG_DARI: u32 = 140;
pub const LANG_DIVEHI: u32 = 101;
pub const LANG_DUTCH: u32 = 19;
pub const LANG_ENGLISH: u32 = 9;
pub const LANG_ESTONIAN: u32 = 37;
pub const LANG_FAEROESE: u32 = 56;
pub const LANG_FARSI: u32 = 41;
pub const LANG_FILIPINO: u32 = 100;
pub const LANG_FINNISH: u32 = 11;
pub const LANG_FRENCH: u32 = 12;
pub const LANG_FRISIAN: u32 = 98;
pub const LANG_FULAH: u32 = 103;
pub const LANG_GALICIAN: u32 = 86;
pub const LANG_GEORGIAN: u32 = 55;
pub const LANG_GERMAN: u32 = 7;
pub const LANG_GREEK: u32 = 8;
pub const LANG_GREENLANDIC: u32 = 111;
pub const LANG_GUJARATI: u32 = 71;
pub const LANG_HAUSA: u32 = 104;
pub const LANG_HAWAIIAN: u32 = 117;
pub const LANG_HEBREW: u32 = 13;
pub const LANG_HINDI: u32 = 57;
pub const LANG_HUNGARIAN: u32 = 14;
pub const LANG_ICELANDIC: u32 = 15;
pub const LANG_IGBO: u32 = 112;
pub const LANG_INDONESIAN: u32 = 33;
pub const LANG_INUKTITUT: u32 = 93;
pub const LANG_IRISH: u32 = 60;
pub const LANG_ITALIAN: u32 = 16;
pub const LANG_JAPANESE: u32 = 17;
pub const LANG_KANNADA: u32 = 75;
pub const LANG_KASHMIRI: u32 = 96;
pub const LANG_KAZAK: u32 = 63;
pub const LANG_KHMER: u32 = 83;
pub const LANG_KICHE: u32 = 134;
pub const LANG_KINYARWANDA: u32 = 135;
pub const LANG_KONKANI: u32 = 87;
pub const LANG_KOREAN: u32 = 18;
pub const LANG_KYRGYZ: u32 = 64;
pub const LANG_LAO: u32 = 84;
pub const LANG_LATVIAN: u32 = 38;
pub const LANG_LITHUANIAN: u32 = 39;
pub const LANG_LOWER_SORBIAN: u32 = 46;
pub const LANG_LUXEMBOURGISH: u32 = 110;
pub const LANG_MACEDONIAN: u32 = 47;
pub const LANG_MALAY: u32 = 62;
pub const LANG_MALAYALAM: u32 = 76;
pub const LANG_MALTESE: u32 = 58;
pub const LANG_MANIPURI: u32 = 88;
pub const LANG_MAORI: u32 = 129;
pub const LANG_MAPUDUNGUN: u32 = 122;
pub const LANG_MARATHI: u32 = 78;
pub const LANG_MOHAWK: u32 = 124;
pub const LANG_MONGOLIAN: u32 = 80;
pub const LANG_NEPALI: u32 = 97;
pub const LANG_NORWEGIAN: u32 = 20;
pub const LANG_OCCITAN: u32 = 130;
pub const LANG_ODIA: u32 = 72;
pub const LANG_ORIYA: u32 = 72;
pub const LANG_PASHTO: u32 = 99;
pub const LANG_PERSIAN: u32 = 41;
pub const LANG_POLISH: u32 = 21;
pub const LANG_PORTUGUESE: u32 = 22;
pub const LANG_PULAR: u32 = 103;
pub const LANG_PUNJABI: u32 = 70;
pub const LANG_QUECHUA: u32 = 107;
pub const LANG_ROMANIAN: u32 = 24;
pub const LANG_ROMANSH: u32 = 23;
pub const LANG_RUSSIAN: u32 = 25;
pub const LANG_SAKHA: u32 = 133;
pub const LANG_SAMI: u32 = 59;
pub const LANG_SANSKRIT: u32 = 79;
pub const LANG_SCOTTISH_GAELIC: u32 = 145;
pub const LANG_SERBIAN: u32 = 26;
pub const LANG_SERBIAN_NEUTRAL: u32 = 31770;
pub const LANG_SINDHI: u32 = 89;
pub const LANG_SINHALESE: u32 = 91;
pub const LANG_SLOVAK: u32 = 27;
pub const LANG_SLOVENIAN: u32 = 36;
pub const LANG_SOTHO: u32 = 108;
pub const LANG_SPANISH: u32 = 10;
pub const LANG_SWAHILI: u32 = 65;
pub const LANG_SWEDISH: u32 = 29;
pub const LANG_SYRIAC: u32 = 90;
pub const LANG_TAJIK: u32 = 40;
pub const LANG_TAMAZIGHT: u32 = 95;
pub const LANG_TAMIL: u32 = 73;
pub const LANG_TATAR: u32 = 68;
pub const LANG_TELUGU: u32 = 74;
pub const LANG_THAI: u32 = 30;
pub const LANG_TIBETAN: u32 = 81;
pub const LANG_TIGRIGNA: u32 = 115;
pub const LANG_TIGRINYA: u32 = 115;
pub const LANG_TSWANA: u32 = 50;
pub const LANG_TURKISH: u32 = 31;
pub const LANG_TURKMEN: u32 = 66;
pub const LANG_UIGHUR: u32 = 128;
pub const LANG_UKRAINIAN: u32 = 34;
pub const LANG_UPPER_SORBIAN: u32 = 46;
pub const LANG_URDU: u32 = 32;
pub const LANG_UZBEK: u32 = 67;
pub const LANG_VALENCIAN: u32 = 3;
pub const LANG_VIETNAMESE: u32 = 42;
pub const LANG_WELSH: u32 = 82;
pub const LANG_WOLOF: u32 = 136;
pub const LANG_XHOSA: u32 = 52;
pub const LANG_YAKUT: u32 = 133;
pub const LANG_YI: u32 = 120;
pub const LANG_YORUBA: u32 = 106;
pub const LANG_ZULU: u32 = 53;
pub const SUBLANG_NEUTRAL: u32 = 0;
pub const SUBLANG_DEFAULT: u32 = 1;
pub const SUBLANG_SYS_DEFAULT: u32 = 2;
pub const SUBLANG_CUSTOM_DEFAULT: u32 = 3;
pub const SUBLANG_CUSTOM_UNSPECIFIED: u32 = 4;
pub const SUBLANG_UI_CUSTOM_DEFAULT: u32 = 5;
pub const SUBLANG_AFRIKAANS_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_ALBANIAN_ALBANIA: u32 = 1;
pub const SUBLANG_ALSATIAN_FRANCE: u32 = 1;
pub const SUBLANG_AMHARIC_ETHIOPIA: u32 = 1;
pub const SUBLANG_ARABIC_SAUDI_ARABIA: u32 = 1;
pub const SUBLANG_ARABIC_IRAQ: u32 = 2;
pub const SUBLANG_ARABIC_EGYPT: u32 = 3;
pub const SUBLANG_ARABIC_LIBYA: u32 = 4;
pub const SUBLANG_ARABIC_ALGERIA: u32 = 5;
pub const SUBLANG_ARABIC_MOROCCO: u32 = 6;
pub const SUBLANG_ARABIC_TUNISIA: u32 = 7;
pub const SUBLANG_ARABIC_OMAN: u32 = 8;
pub const SUBLANG_ARABIC_YEMEN: u32 = 9;
pub const SUBLANG_ARABIC_SYRIA: u32 = 10;
pub const SUBLANG_ARABIC_JORDAN: u32 = 11;
pub const SUBLANG_ARABIC_LEBANON: u32 = 12;
pub const SUBLANG_ARABIC_KUWAIT: u32 = 13;
pub const SUBLANG_ARABIC_UAE: u32 = 14;
pub const SUBLANG_ARABIC_BAHRAIN: u32 = 15;
pub const SUBLANG_ARABIC_QATAR: u32 = 16;
pub const SUBLANG_ARMENIAN_ARMENIA: u32 = 1;
pub const SUBLANG_ASSAMESE_INDIA: u32 = 1;
pub const SUBLANG_AZERI_LATIN: u32 = 1;
pub const SUBLANG_AZERI_CYRILLIC: u32 = 2;
pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN: u32 = 1;
pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC: u32 = 2;
pub const SUBLANG_BANGLA_INDIA: u32 = 1;
pub const SUBLANG_BANGLA_BANGLADESH: u32 = 2;
pub const SUBLANG_BASHKIR_RUSSIA: u32 = 1;
pub const SUBLANG_BASQUE_BASQUE: u32 = 1;
pub const SUBLANG_BELARUSIAN_BELARUS: u32 = 1;
pub const SUBLANG_BENGALI_INDIA: u32 = 1;
pub const SUBLANG_BENGALI_BANGLADESH: u32 = 2;
pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 5;
pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC: u32 = 8;
pub const SUBLANG_BRETON_FRANCE: u32 = 1;
pub const SUBLANG_BULGARIAN_BULGARIA: u32 = 1;
pub const SUBLANG_CATALAN_CATALAN: u32 = 1;
pub const SUBLANG_CENTRAL_KURDISH_IRAQ: u32 = 1;
pub const SUBLANG_CHEROKEE_CHEROKEE: u32 = 1;
pub const SUBLANG_CHINESE_TRADITIONAL: u32 = 1;
pub const SUBLANG_CHINESE_SIMPLIFIED: u32 = 2;
pub const SUBLANG_CHINESE_HONGKONG: u32 = 3;
pub const SUBLANG_CHINESE_SINGAPORE: u32 = 4;
pub const SUBLANG_CHINESE_MACAU: u32 = 5;
pub const SUBLANG_CORSICAN_FRANCE: u32 = 1;
pub const SUBLANG_CZECH_CZECH_REPUBLIC: u32 = 1;
pub const SUBLANG_CROATIAN_CROATIA: u32 = 1;
pub const SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 4;
pub const SUBLANG_DANISH_DENMARK: u32 = 1;
pub const SUBLANG_DARI_AFGHANISTAN: u32 = 1;
pub const SUBLANG_DIVEHI_MALDIVES: u32 = 1;
pub const SUBLANG_DUTCH: u32 = 1;
pub const SUBLANG_DUTCH_BELGIAN: u32 = 2;
pub const SUBLANG_ENGLISH_US: u32 = 1;
pub const SUBLANG_ENGLISH_UK: u32 = 2;
pub const SUBLANG_ENGLISH_AUS: u32 = 3;
pub const SUBLANG_ENGLISH_CAN: u32 = 4;
pub const SUBLANG_ENGLISH_NZ: u32 = 5;
pub const SUBLANG_ENGLISH_IRELAND: u32 = 6;
pub const SUBLANG_ENGLISH_EIRE: u32 = 6;
pub const SUBLANG_ENGLISH_SOUTH_AFRICA: u32 = 7;
pub const SUBLANG_ENGLISH_JAMAICA: u32 = 8;
pub const SUBLANG_ENGLISH_CARIBBEAN: u32 = 9;
pub const SUBLANG_ENGLISH_BELIZE: u32 = 10;
pub const SUBLANG_ENGLISH_TRINIDAD: u32 = 11;
pub const SUBLANG_ENGLISH_ZIMBABWE: u32 = 12;
pub const SUBLANG_ENGLISH_PHILIPPINES: u32 = 13;
pub const SUBLANG_ENGLISH_INDIA: u32 = 16;
pub const SUBLANG_ENGLISH_MALAYSIA: u32 = 17;
pub const SUBLANG_ENGLISH_SINGAPORE: u32 = 18;
pub const SUBLANG_ESTONIAN_ESTONIA: u32 = 1;
pub const SUBLANG_FAEROESE_FAROE_ISLANDS: u32 = 1;
pub const SUBLANG_FILIPINO_PHILIPPINES: u32 = 1;
pub const SUBLANG_FINNISH_FINLAND: u32 = 1;
pub const SUBLANG_FRENCH: u32 = 1;
pub const SUBLANG_FRENCH_BELGIAN: u32 = 2;
pub const SUBLANG_FRENCH_CANADIAN: u32 = 3;
pub const SUBLANG_FRENCH_SWISS: u32 = 4;
pub const SUBLANG_FRENCH_LUXEMBOURG: u32 = 5;
pub const SUBLANG_FRENCH_MONACO: u32 = 6;
pub const SUBLANG_FRISIAN_NETHERLANDS: u32 = 1;
pub const SUBLANG_FULAH_SENEGAL: u32 = 2;
pub const SUBLANG_GALICIAN_GALICIAN: u32 = 1;
pub const SUBLANG_GEORGIAN_GEORGIA: u32 = 1;
pub const SUBLANG_GERMAN: u32 = 1;
pub const SUBLANG_GERMAN_SWISS: u32 = 2;
pub const SUBLANG_GERMAN_AUSTRIAN: u32 = 3;
pub const SUBLANG_GERMAN_LUXEMBOURG: u32 = 4;
pub const SUBLANG_GERMAN_LIECHTENSTEIN: u32 = 5;
pub const SUBLANG_GREEK_GREECE: u32 = 1;
pub const SUBLANG_GREENLANDIC_GREENLAND: u32 = 1;
pub const SUBLANG_GUJARATI_INDIA: u32 = 1;
pub const SUBLANG_HAUSA_NIGERIA_LATIN: u32 = 1;
pub const SUBLANG_HAUSA_NIGERIA: u32 = 1;
pub const SUBLANG_HAWAIIAN_US: u32 = 1;
pub const SUBLANG_HEBREW_ISRAEL: u32 = 1;
pub const SUBLANG_HINDI_INDIA: u32 = 1;
pub const SUBLANG_HUNGARIAN_HUNGARY: u32 = 1;
pub const SUBLANG_ICELANDIC_ICELAND: u32 = 1;
pub const SUBLANG_IGBO_NIGERIA: u32 = 1;
pub const SUBLANG_INDONESIAN_INDONESIA: u32 = 1;
pub const SUBLANG_INUKTITUT_CANADA: u32 = 1;
pub const SUBLANG_INUKTITUT_CANADA_LATIN: u32 = 2;
pub const SUBLANG_IRISH_IRELAND: u32 = 2;
pub const SUBLANG_ITALIAN: u32 = 1;
pub const SUBLANG_ITALIAN_SWISS: u32 = 2;
pub const SUBLANG_JAPANESE_JAPAN: u32 = 1;
pub const SUBLANG_KANNADA_INDIA: u32 = 1;
pub const SUBLANG_KASHMIRI_INDIA: u32 = 2;
pub const SUBLANG_KASHMIRI_SASIA: u32 = 2;
pub const SUBLANG_KAZAK_KAZAKHSTAN: u32 = 1;
pub const SUBLANG_KHMER_CAMBODIA: u32 = 1;
pub const SUBLANG_KICHE_GUATEMALA: u32 = 1;
pub const SUBLANG_KINYARWANDA_RWANDA: u32 = 1;
pub const SUBLANG_KONKANI_INDIA: u32 = 1;
pub const SUBLANG_KOREAN: u32 = 1;
pub const SUBLANG_KYRGYZ_KYRGYZSTAN: u32 = 1;
pub const SUBLANG_LAO_LAO: u32 = 1;
pub const SUBLANG_LAO_LAO_PDR: u32 = 1;
pub const SUBLANG_LATVIAN_LATVIA: u32 = 1;
pub const SUBLANG_LITHUANIAN_LITHUANIA: u32 = 1;
pub const SUBLANG_LITHUANIAN: u32 = 1;
pub const SUBLANG_LOWER_SORBIAN_GERMANY: u32 = 2;
pub const SUBLANG_LUXEMBOURGISH_LUXEMBOURG: u32 = 1;
pub const SUBLANG_MACEDONIAN_MACEDONIA: u32 = 1;
pub const SUBLANG_MALAY_MALAYSIA: u32 = 1;
pub const SUBLANG_MALAY_BRUNEI_DARUSSALAM: u32 = 2;
pub const SUBLANG_MALAYALAM_INDIA: u32 = 1;
pub const SUBLANG_MALTESE_MALTA: u32 = 1;
pub const SUBLANG_MAORI_NEW_ZEALAND: u32 = 1;
pub const SUBLANG_MAPUDUNGUN_CHILE: u32 = 1;
pub const SUBLANG_MARATHI_INDIA: u32 = 1;
pub const SUBLANG_MOHAWK_MOHAWK: u32 = 1;
pub const SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA: u32 = 1;
pub const SUBLANG_MONGOLIAN_PRC: u32 = 2;
pub const SUBLANG_NEPALI_NEPAL: u32 = 1;
pub const SUBLANG_NEPALI_INDIA: u32 = 2;
pub const SUBLANG_NORWEGIAN_BOKMAL: u32 = 1;
pub const SUBLANG_NORWEGIAN_NYNORSK: u32 = 2;
pub const SUBLANG_OCCITAN_FRANCE: u32 = 1;
pub const SUBLANG_ODIA_INDIA: u32 = 1;
pub const SUBLANG_ORIYA_INDIA: u32 = 1;
pub const SUBLANG_PASHTO_AFGHANISTAN: u32 = 1;
pub const SUBLANG_PERSIAN_IRAN: u32 = 1;
pub const SUBLANG_POLISH_POLAND: u32 = 1;
pub const SUBLANG_PORTUGUESE_BRAZILIAN: u32 = 1;
pub const SUBLANG_PORTUGUESE_PORTUGAL: u32 = 2;
pub const SUBLANG_PORTUGUESE: u32 = 2;
pub const SUBLANG_PULAR_SENEGAL: u32 = 2;
pub const SUBLANG_PUNJABI_INDIA: u32 = 1;
pub const SUBLANG_PUNJABI_PAKISTAN: u32 = 2;
pub const SUBLANG_QUECHUA_BOLIVIA: u32 = 1;
pub const SUBLANG_QUECHUA_ECUADOR: u32 = 2;
pub const SUBLANG_QUECHUA_PERU: u32 = 3;
pub const SUBLANG_ROMANIAN_ROMANIA: u32 = 1;
pub const SUBLANG_ROMANSH_SWITZERLAND: u32 = 1;
pub const SUBLANG_RUSSIAN_RUSSIA: u32 = 1;
pub const SUBLANG_SAKHA_RUSSIA: u32 = 1;
pub const SUBLANG_SAMI_NORTHERN_NORWAY: u32 = 1;
pub const SUBLANG_SAMI_NORTHERN_SWEDEN: u32 = 2;
pub const SUBLANG_SAMI_NORTHERN_FINLAND: u32 = 3;
pub const SUBLANG_SAMI_LULE_NORWAY: u32 = 4;
pub const SUBLANG_SAMI_LULE_SWEDEN: u32 = 5;
pub const SUBLANG_SAMI_SOUTHERN_NORWAY: u32 = 6;
pub const SUBLANG_SAMI_SOUTHERN_SWEDEN: u32 = 7;
pub const SUBLANG_SAMI_SKOLT_FINLAND: u32 = 8;
pub const SUBLANG_SAMI_INARI_FINLAND: u32 = 9;
pub const SUBLANG_SANSKRIT_INDIA: u32 = 1;
pub const SUBLANG_SCOTTISH_GAELIC: u32 = 1;
pub const SUBLANG_SERBIAN_LATIN: u32 = 2;
pub const SUBLANG_SERBIAN_CYRILLIC: u32 = 3;
pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 6;
pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC: u32 = 7;
pub const SUBLANG_SERBIAN_MONTENEGRO_LATIN: u32 = 11;
pub const SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC: u32 = 12;
pub const SUBLANG_SERBIAN_SERBIA_LATIN: u32 = 9;
pub const SUBLANG_SERBIAN_SERBIA_CYRILLIC: u32 = 10;
pub const SUBLANG_SERBIAN_CROATIA: u32 = 1;
pub const SUBLANG_SINDHI_INDIA: u32 = 1;
pub const SUBLANG_SINDHI_AFGHANISTAN: u32 = 2;
pub const SUBLANG_SINDHI_PAKISTAN: u32 = 2;
pub const SUBLANG_SINHALESE_SRI_LANKA: u32 = 1;
pub const SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_SLOVAK_SLOVAKIA: u32 = 1;
pub const SUBLANG_SLOVENIAN_SLOVENIA: u32 = 1;
pub const SUBLANG_SPANISH: u32 = 1;
pub const SUBLANG_SPANISH_MEXICAN: u32 = 2;
pub const SUBLANG_SPANISH_MODERN: u32 = 3;
pub const SUBLANG_SPANISH_GUATEMALA: u32 = 4;
pub const SUBLANG_SPANISH_COSTA_RICA: u32 = 5;
pub const SUBLANG_SPANISH_PANAMA: u32 = 6;
pub const SUBLANG_SPANISH_DOMINICAN_REPUBLIC: u32 = 7;
pub const SUBLANG_SPANISH_VENEZUELA: u32 = 8;
pub const SUBLANG_SPANISH_COLOMBIA: u32 = 9;
pub const SUBLANG_SPANISH_PERU: u32 = 10;
pub const SUBLANG_SPANISH_ARGENTINA: u32 = 11;
pub const SUBLANG_SPANISH_ECUADOR: u32 = 12;
pub const SUBLANG_SPANISH_CHILE: u32 = 13;
pub const SUBLANG_SPANISH_URUGUAY: u32 = 14;
pub const SUBLANG_SPANISH_PARAGUAY: u32 = 15;
pub const SUBLANG_SPANISH_BOLIVIA: u32 = 16;
pub const SUBLANG_SPANISH_EL_SALVADOR: u32 = 17;
pub const SUBLANG_SPANISH_HONDURAS: u32 = 18;
pub const SUBLANG_SPANISH_NICARAGUA: u32 = 19;
pub const SUBLANG_SPANISH_PUERTO_RICO: u32 = 20;
pub const SUBLANG_SPANISH_US: u32 = 21;
pub const SUBLANG_SWAHILI_KENYA: u32 = 1;
pub const SUBLANG_SWEDISH_SWEDEN: u32 = 1;
pub const SUBLANG_SWEDISH: u32 = 1;
pub const SUBLANG_SWEDISH_FINLAND: u32 = 2;
pub const SUBLANG_SYRIAC: u32 = 1;
pub const SUBLANG_SYRIAC_SYRIA: u32 = 1;
pub const SUBLANG_TAJIK_TAJIKISTAN: u32 = 1;
pub const SUBLANG_TAMAZIGHT_ALGERIA_LATIN: u32 = 2;
pub const SUBLANG_TAMAZIGHT_MOROCCO_TIFINAGH: u32 = 4;
pub const SUBLANG_TAMIL_INDIA: u32 = 1;
pub const SUBLANG_TAMIL_SRI_LANKA: u32 = 2;
pub const SUBLANG_TATAR_RUSSIA: u32 = 1;
pub const SUBLANG_TELUGU_INDIA: u32 = 1;
pub const SUBLANG_THAI_THAILAND: u32 = 1;
pub const SUBLANG_TIBETAN_PRC: u32 = 1;
pub const SUBLANG_TIBETAN_BHUTAN: u32 = 2;
pub const SUBLANG_TIGRIGNA_ERITREA: u32 = 2;
pub const SUBLANG_TIGRINYA_ERITREA: u32 = 2;
pub const SUBLANG_TIGRINYA_ETHIOPIA: u32 = 1;
pub const SUBLANG_TSWANA_BOTSWANA: u32 = 2;
pub const SUBLANG_TSWANA_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_TURKISH_TURKEY: u32 = 1;
pub const SUBLANG_TURKMEN_TURKMENISTAN: u32 = 1;
pub const SUBLANG_UIGHUR_PRC: u32 = 1;
pub const SUBLANG_UKRAINIAN_UKRAINE: u32 = 1;
pub const SUBLANG_UPPER_SORBIAN_GERMANY: u32 = 1;
pub const SUBLANG_URDU_PAKISTAN: u32 = 1;
pub const SUBLANG_URDU_INDIA: u32 = 2;
pub const SUBLANG_UZBEK_LATIN: u32 = 1;
pub const SUBLANG_UZBEK_CYRILLIC: u32 = 2;
pub const SUBLANG_VALENCIAN_VALENCIA: u32 = 2;
pub const SUBLANG_VIETNAMESE_VIETNAM: u32 = 1;
pub const SUBLANG_WELSH_UNITED_KINGDOM: u32 = 1;
pub const SUBLANG_WOLOF_SENEGAL: u32 = 1;
pub const SUBLANG_YORUBA_NIGERIA: u32 = 1;
pub const SUBLANG_XHOSA_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_YAKUT_RUSSIA: u32 = 1;
pub const SUBLANG_YI_PRC: u32 = 1;
pub const SUBLANG_ZULU_SOUTH_AFRICA: u32 = 1;
pub const SORT_DEFAULT: u32 = 0;
pub const SORT_INVARIANT_MATH: u32 = 1;
pub const SORT_JAPANESE_XJIS: u32 = 0;
pub const SORT_JAPANESE_UNICODE: u32 = 1;
pub const SORT_JAPANESE_RADICALSTROKE: u32 = 4;
pub const SORT_CHINESE_BIG5: u32 = 0;
pub const SORT_CHINESE_PRCP: u32 = 0;
pub const SORT_CHINESE_UNICODE: u32 = 1;
pub const SORT_CHINESE_PRC: u32 = 2;
pub const SORT_CHINESE_BOPOMOFO: u32 = 3;
pub const SORT_CHINESE_RADICALSTROKE: u32 = 4;
pub const SORT_KOREAN_KSC: u32 = 0;
pub const SORT_KOREAN_UNICODE: u32 = 1;
pub const SORT_GERMAN_PHONE_BOOK: u32 = 1;
pub const SORT_HUNGARIAN_DEFAULT: u32 = 0;
pub const SORT_HUNGARIAN_TECHNICAL: u32 = 1;
pub const SORT_GEORGIAN_TRADITIONAL: u32 = 0;
pub const SORT_GEORGIAN_MODERN: u32 = 1;
pub const NLS_VALID_LOCALE_MASK: u32 = 1048575;
pub const LOCALE_NAME_MAX_LENGTH: u32 = 85;
pub const LOCALE_TRANSIENT_KEYBOARD1: u32 = 8192;
pub const LOCALE_TRANSIENT_KEYBOARD2: u32 = 9216;
pub const LOCALE_TRANSIENT_KEYBOARD3: u32 = 10240;
pub const LOCALE_TRANSIENT_KEYBOARD4: u32 = 11264;
pub const MAXIMUM_WAIT_OBJECTS: u32 = 64;
pub const MAXIMUM_SUSPEND_COUNT: u32 = 127;
pub const __SAVE_GPRBX: &[u8; 30] = b"mov {%%rbx, %%rax |rax, rbx};\0";
pub const __RESTORE_GPRBX: &[u8; 30] = b"mov {%%rax, %%rbx |rbx, rax};\0";
pub const __TMPGPR: &[u8; 4] = b"rax\0";
pub const PATH_MAX: u32 = 260;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const _I8_MIN: i32 = -128;
pub const _I8_MAX: u32 = 127;
pub const _UI8_MAX: u32 = 255;
pub const _I16_MIN: i32 = -32768;
pub const _I16_MAX: u32 = 32767;
pub const _UI16_MAX: u32 = 65535;
pub const _I32_MIN: i32 = -2147483648;
pub const _I32_MAX: u32 = 2147483647;
pub const _UI32_MAX: u32 = 4294967295;
pub const LONG_LONG_MAX: u64 = 9223372036854775807;
pub const LONG_LONG_MIN: i64 = -9223372036854775808;
pub const ULONG_LONG_MAX: i32 = -1;
pub const _I64_MIN: i64 = -9223372036854775808;
pub const _I64_MAX: u64 = 9223372036854775807;
pub const _UI64_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const __USE_MINGW_STRTOX: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const RAND_MAX: u32 = 32767;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _MAX_ENV: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _HEAP_MAXREQ: i32 = -32;
pub const _HEAPEMPTY: i32 = -1;
pub const _HEAPOK: i32 = -2;
pub const _HEAPBADBEGIN: i32 = -3;
pub const _HEAPBADNODE: i32 = -4;
pub const _HEAPEND: i32 = -5;
pub const _HEAPBADPTR: i32 = -6;
pub const _FREEENTRY: u32 = 0;
pub const _USEDENTRY: u32 = 1;
pub const _MAX_WAIT_MALLOC_CRT: u32 = 60000;
pub const _ALLOCA_S_THRESHOLD: u32 = 1024;
pub const _ALLOCA_S_STACK_MARKER: u32 = 52428;
pub const _ALLOCA_S_HEAP_MARKER: u32 = 56797;
pub const _ALLOCA_S_MARKER_SIZE: u32 = 16;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const _MM_FROUND_TO_NEAREST_INT: u32 = 0;
pub const _MM_FROUND_TO_NEG_INF: u32 = 1;
pub const _MM_FROUND_TO_POS_INF: u32 = 2;
pub const _MM_FROUND_TO_ZERO: u32 = 3;
pub const _MM_FROUND_CUR_DIRECTION: u32 = 4;
pub const _MM_FROUND_RAISE_EXC: u32 = 0;
pub const _MM_FROUND_NO_EXC: u32 = 8;
pub const _MM_FROUND_NINT: u32 = 0;
pub const _MM_FROUND_FLOOR: u32 = 1;
pub const _MM_FROUND_CEIL: u32 = 2;
pub const _MM_FROUND_TRUNC: u32 = 3;
pub const _MM_FROUND_RINT: u32 = 4;
pub const _MM_FROUND_NEARBYINT: u32 = 12;
pub const _SIDD_UBYTE_OPS: u32 = 0;
pub const _SIDD_UWORD_OPS: u32 = 1;
pub const _SIDD_SBYTE_OPS: u32 = 2;
pub const _SIDD_SWORD_OPS: u32 = 3;
pub const _SIDD_CMP_EQUAL_ANY: u32 = 0;
pub const _SIDD_CMP_RANGES: u32 = 4;
pub const _SIDD_CMP_EQUAL_EACH: u32 = 8;
pub const _SIDD_CMP_EQUAL_ORDERED: u32 = 12;
pub const _SIDD_POSITIVE_POLARITY: u32 = 0;
pub const _SIDD_NEGATIVE_POLARITY: u32 = 16;
pub const _SIDD_MASKED_POSITIVE_POLARITY: u32 = 32;
pub const _SIDD_MASKED_NEGATIVE_POLARITY: u32 = 48;
pub const _SIDD_LEAST_SIGNIFICANT: u32 = 0;
pub const _SIDD_MOST_SIGNIFICANT: u32 = 64;
pub const _SIDD_BIT_MASK: u32 = 0;
pub const _SIDD_UNIT_MASK: u32 = 64;
pub const _CMP_EQ_OQ: u32 = 0;
pub const _CMP_LT_OS: u32 = 1;
pub const _CMP_LE_OS: u32 = 2;
pub const _CMP_UNORD_Q: u32 = 3;
pub const _CMP_NEQ_UQ: u32 = 4;
pub const _CMP_NLT_US: u32 = 5;
pub const _CMP_NLE_US: u32 = 6;
pub const _CMP_ORD_Q: u32 = 7;
pub const _CMP_EQ_UQ: u32 = 8;
pub const _CMP_NGE_US: u32 = 9;
pub const _CMP_NGT_US: u32 = 10;
pub const _CMP_FALSE_OQ: u32 = 11;
pub const _CMP_NEQ_OQ: u32 = 12;
pub const _CMP_GE_OS: u32 = 13;
pub const _CMP_GT_OS: u32 = 14;
pub const _CMP_TRUE_UQ: u32 = 15;
pub const _CMP_EQ_OS: u32 = 16;
pub const _CMP_LT_OQ: u32 = 17;
pub const _CMP_LE_OQ: u32 = 18;
pub const _CMP_UNORD_S: u32 = 19;
pub const _CMP_NEQ_US: u32 = 20;
pub const _CMP_NLT_UQ: u32 = 21;
pub const _CMP_NLE_UQ: u32 = 22;
pub const _CMP_ORD_S: u32 = 23;
pub const _CMP_EQ_US: u32 = 24;
pub const _CMP_NGE_UQ: u32 = 25;
pub const _CMP_NGT_UQ: u32 = 26;
pub const _CMP_FALSE_OS: u32 = 27;
pub const _CMP_NEQ_OS: u32 = 28;
pub const _CMP_GE_OQ: u32 = 29;
pub const _CMP_GT_OQ: u32 = 30;
pub const _CMP_TRUE_US: u32 = 31;
pub const _XBEGIN_STARTED: i32 = -1;
pub const _XABORT_EXPLICIT: u32 = 1;
pub const _XABORT_RETRY: u32 = 2;
pub const _XABORT_CONFLICT: u32 = 4;
pub const _XABORT_CAPACITY: u32 = 8;
pub const _XABORT_DEBUG: u32 = 16;
pub const _XABORT_NESTED: u32 = 32;
pub const __PCONFIG_KEY_PROGRAM: u32 = 1;
pub const _MM_PCOMCTRL_LT: u32 = 0;
pub const _MM_PCOMCTRL_LE: u32 = 1;
pub const _MM_PCOMCTRL_GT: u32 = 2;
pub const _MM_PCOMCTRL_GE: u32 = 3;
pub const _MM_PCOMCTRL_EQ: u32 = 4;
pub const _MM_PCOMCTRL_NEQ: u32 = 5;
pub const _MM_PCOMCTRL_FALSE: u32 = 6;
pub const _MM_PCOMCTRL_TRUE: u32 = 7;
pub const __RDPRU_MPERF: u32 = 0;
pub const __RDPRU_APERF: u32 = 1;
pub const PF_TEMPORAL_LEVEL_1: u32 = 3;
pub const PF_TEMPORAL_LEVEL_2: u32 = 2;
pub const PF_TEMPORAL_LEVEL_3: u32 = 1;
pub const PF_NON_TEMPORAL_LEVEL_ALL: u32 = 0;
pub const EXCEPTION_READ_FAULT: u32 = 0;
pub const EXCEPTION_WRITE_FAULT: u32 = 1;
pub const EXCEPTION_EXECUTE_FAULT: u32 = 8;
pub const CONTEXT_AMD64: u32 = 1048576;
pub const CONTEXT_EXCEPTION_ACTIVE: u32 = 134217728;
pub const CONTEXT_SERVICE_ACTIVE: u32 = 268435456;
pub const CONTEXT_EXCEPTION_REQUEST: u32 = 1073741824;
pub const CONTEXT_EXCEPTION_REPORTING: u32 = 2147483648;
pub const CONTEXT_UNWOUND_TO_CALL: u32 = 536870912;
pub const INITIAL_MXCSR: u32 = 8064;
pub const INITIAL_FPCSR: u32 = 639;
pub const RUNTIME_FUNCTION_INDIRECT: u32 = 1;
pub const OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME: &[u8; 34] =
    b"OutOfProcessFunctionTableCallback\0";
pub const UNW_FLAG_NHANDLER: u32 = 0;
pub const UNW_FLAG_EHANDLER: u32 = 1;
pub const UNW_FLAG_UHANDLER: u32 = 2;
pub const UNW_FLAG_CHAININFO: u32 = 4;
pub const EXCEPTION_NONCONTINUABLE: u32 = 1;
pub const EXCEPTION_UNWINDING: u32 = 2;
pub const EXCEPTION_EXIT_UNWIND: u32 = 4;
pub const EXCEPTION_STACK_INVALID: u32 = 8;
pub const EXCEPTION_NESTED_CALL: u32 = 16;
pub const EXCEPTION_TARGET_UNWIND: u32 = 32;
pub const EXCEPTION_COLLIDED_UNWIND: u32 = 64;
pub const EXCEPTION_UNWIND: u32 = 102;
pub const EXCEPTION_MAXIMUM_PARAMETERS: u32 = 15;
pub const UNWIND_HISTORY_TABLE_SIZE: u32 = 12;
pub const UNWIND_HISTORY_TABLE_NONE: u32 = 0;
pub const UNWIND_HISTORY_TABLE_GLOBAL: u32 = 1;
pub const UNWIND_HISTORY_TABLE_LOCAL: u32 = 2;
pub const SID_REVISION: u32 = 1;
pub const SID_MAX_SUB_AUTHORITIES: u32 = 15;
pub const SID_RECOMMENDED_SUB_AUTHORITIES: u32 = 1;
pub const SID_HASH_SIZE: u32 = 32;
pub const SECURITY_INSTALLER_GROUP_CAPABILITY_BASE: u32 = 32;
pub const SECURITY_INSTALLER_GROUP_CAPABILITY_RID_COUNT: u32 = 9;
pub const SECURITY_INSTALLER_CAPABILITY_RID_COUNT: u32 = 10;
pub const SECURITY_TRUSTED_INSTALLER_RID1: u32 = 956008885;
pub const SECURITY_TRUSTED_INSTALLER_RID2: u32 = 3418522649;
pub const SECURITY_TRUSTED_INSTALLER_RID3: u32 = 1831038044;
pub const SECURITY_TRUSTED_INSTALLER_RID4: u32 = 1853292631;
pub const SECURITY_TRUSTED_INSTALLER_RID5: u32 = 2271478464;
pub const ACL_REVISION: u32 = 2;
pub const ACL_REVISION_DS: u32 = 4;
pub const ACL_REVISION1: u32 = 1;
pub const ACL_REVISION2: u32 = 2;
pub const ACL_REVISION3: u32 = 3;
pub const ACL_REVISION4: u32 = 4;
pub const MAX_ACL_REVISION: u32 = 4;
pub const ACCESS_MIN_MS_ACE_TYPE: u32 = 0;
pub const ACCESS_ALLOWED_ACE_TYPE: u32 = 0;
pub const ACCESS_DENIED_ACE_TYPE: u32 = 1;
pub const SYSTEM_AUDIT_ACE_TYPE: u32 = 2;
pub const SYSTEM_ALARM_ACE_TYPE: u32 = 3;
pub const ACCESS_MAX_MS_V2_ACE_TYPE: u32 = 3;
pub const ACCESS_ALLOWED_COMPOUND_ACE_TYPE: u32 = 4;
pub const ACCESS_MAX_MS_V3_ACE_TYPE: u32 = 4;
pub const ACCESS_MIN_MS_OBJECT_ACE_TYPE: u32 = 5;
pub const ACCESS_ALLOWED_OBJECT_ACE_TYPE: u32 = 5;
pub const ACCESS_DENIED_OBJECT_ACE_TYPE: u32 = 6;
pub const SYSTEM_AUDIT_OBJECT_ACE_TYPE: u32 = 7;
pub const SYSTEM_ALARM_OBJECT_ACE_TYPE: u32 = 8;
pub const ACCESS_MAX_MS_OBJECT_ACE_TYPE: u32 = 8;
pub const ACCESS_MAX_MS_V4_ACE_TYPE: u32 = 8;
pub const ACCESS_MAX_MS_ACE_TYPE: u32 = 8;
pub const ACCESS_ALLOWED_CALLBACK_ACE_TYPE: u32 = 9;
pub const ACCESS_DENIED_CALLBACK_ACE_TYPE: u32 = 10;
pub const ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE: u32 = 11;
pub const ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE: u32 = 12;
pub const SYSTEM_AUDIT_CALLBACK_ACE_TYPE: u32 = 13;
pub const SYSTEM_ALARM_CALLBACK_ACE_TYPE: u32 = 14;
pub const SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE: u32 = 15;
pub const SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE: u32 = 16;
pub const SYSTEM_MANDATORY_LABEL_ACE_TYPE: u32 = 17;
pub const SYSTEM_RESOURCE_ATTRIBUTE_ACE_TYPE: u32 = 18;
pub const SYSTEM_SCOPED_POLICY_ID_ACE_TYPE: u32 = 19;
pub const SYSTEM_PROCESS_TRUST_LABEL_ACE_TYPE: u32 = 20;
pub const SYSTEM_ACCESS_FILTER_ACE_TYPE: u32 = 21;
pub const ACCESS_MAX_MS_V5_ACE_TYPE: u32 = 21;
pub const OBJECT_INHERIT_ACE: u32 = 1;
pub const CONTAINER_INHERIT_ACE: u32 = 2;
pub const NO_PROPAGATE_INHERIT_ACE: u32 = 4;
pub const INHERIT_ONLY_ACE: u32 = 8;
pub const INHERITED_ACE: u32 = 16;
pub const VALID_INHERIT_FLAGS: u32 = 31;
pub const CRITICAL_ACE_FLAG: u32 = 32;
pub const SUCCESSFUL_ACCESS_ACE_FLAG: u32 = 64;
pub const FAILED_ACCESS_ACE_FLAG: u32 = 128;
pub const TRUST_PROTECTED_FILTER_ACE_FLAG: u32 = 64;
pub const SYSTEM_MANDATORY_LABEL_NO_WRITE_UP: u32 = 1;
pub const SYSTEM_MANDATORY_LABEL_NO_READ_UP: u32 = 2;
pub const SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP: u32 = 4;
pub const SYSTEM_MANDATORY_LABEL_VALID_MASK: u32 = 7;
pub const SYSTEM_PROCESS_TRUST_LABEL_VALID_MASK: u32 = 16777215;
pub const SYSTEM_PROCESS_TRUST_NOCONSTRAINT_MASK: u32 = 4294967295;
pub const SYSTEM_ACCESS_FILTER_VALID_MASK: u32 = 16777215;
pub const SYSTEM_ACCESS_FILTER_NOCONSTRAINT_MASK: u32 = 4294967295;
pub const ACE_OBJECT_TYPE_PRESENT: u32 = 1;
pub const ACE_INHERITED_OBJECT_TYPE_PRESENT: u32 = 2;
pub const SECURITY_DESCRIPTOR_REVISION: u32 = 1;
pub const SECURITY_DESCRIPTOR_REVISION1: u32 = 1;
pub const SE_OWNER_DEFAULTED: u32 = 1;
pub const SE_GROUP_DEFAULTED: u32 = 2;
pub const SE_DACL_PRESENT: u32 = 4;
pub const SE_DACL_DEFAULTED: u32 = 8;
pub const SE_SACL_PRESENT: u32 = 16;
pub const SE_SACL_DEFAULTED: u32 = 32;
pub const SE_DACL_AUTO_INHERIT_REQ: u32 = 256;
pub const SE_SACL_AUTO_INHERIT_REQ: u32 = 512;
pub const SE_DACL_AUTO_INHERITED: u32 = 1024;
pub const SE_SACL_AUTO_INHERITED: u32 = 2048;
pub const SE_DACL_PROTECTED: u32 = 4096;
pub const SE_SACL_PROTECTED: u32 = 8192;
pub const SE_RM_CONTROL_VALID: u32 = 16384;
pub const SE_SELF_RELATIVE: u32 = 32768;
pub const ACCESS_OBJECT_GUID: u32 = 0;
pub const ACCESS_PROPERTY_SET_GUID: u32 = 1;
pub const ACCESS_PROPERTY_GUID: u32 = 2;
pub const ACCESS_MAX_LEVEL: u32 = 4;
pub const AUDIT_ALLOW_NO_PRIVILEGE: u32 = 1;
pub const ACCESS_DS_SOURCE_A: &[u8; 3] = b"DS\0";
pub const ACCESS_DS_SOURCE_W: &[u8; 3] = b"DS\0";
pub const ACCESS_DS_OBJECT_TYPE_NAME_A: &[u8; 25] = b"Directory Service Object\0";
pub const ACCESS_DS_OBJECT_TYPE_NAME_W: &[u8; 25] = b"Directory Service Object\0";
pub const SE_PRIVILEGE_REMOVED: u32 = 4;
pub const PRIVILEGE_SET_ALL_NECESSARY: u32 = 1;
pub const ACCESS_REASON_TYPE_MASK: u32 = 16711680;
pub const ACCESS_REASON_DATA_MASK: u32 = 65535;
pub const ACCESS_REASON_STAGING_MASK: u32 = 2147483648;
pub const ACCESS_REASON_EXDATA_MASK: u32 = 2130706432;
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_OWNER_ACE: u32 = 1;
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_LABEL_ACE: u32 = 2;
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_ACCESS_FILTER_ACE: u32 = 4;
pub const SE_SECURITY_DESCRIPTOR_VALID_FLAGS: u32 = 7;
pub const SE_ACCESS_CHECK_FLAG_NO_LEARNING_MODE_LOGGING: u32 = 8;
pub const SE_ACCESS_CHECK_VALID_FLAGS: u32 = 8;
pub const SE_ACTIVATE_AS_USER_CAPABILITY: &[u8; 15] = b"activateAsUser\0";
pub const SE_CONSTRAINED_IMPERSONATION_CAPABILITY: &[u8; 25] = b"constrainedImpersonation\0";
pub const SE_SESSION_IMPERSONATION_CAPABILITY: &[u8; 21] = b"sessionImpersonation\0";
pub const SE_MUMA_CAPABILITY: &[u8; 5] = b"muma\0";
pub const SE_DEVELOPMENT_MODE_NETWORK_CAPABILITY: &[u8; 23] = b"developmentModeNetwork\0";
pub const SE_LEARNING_MODE_LOGGING_CAPABILITY: &[u8; 20] = b"learningModeLogging\0";
pub const SE_PERMISSIVE_LEARNING_MODE_CAPABILITY: &[u8; 23] = b"permissiveLearningMode\0";
pub const SE_APP_SILO_VOLUME_ROOT_MINIMAL_CAPABILITY: &[u8; 32] =
    b"isolatedWin32-volumeRootMinimal\0";
pub const SE_APP_SILO_PROFILES_ROOT_MINIMAL_CAPABILITY: &[u8; 34] =
    b"isolatedWin32-profilesRootMinimal\0";
pub const SE_APP_SILO_USER_PROFILE_MINIMAL_CAPABILITY: &[u8; 33] =
    b"isolatedWin32-userProfileMinimal\0";
pub const SE_APP_SILO_PRINT_CAPABILITY: &[u8; 20] = b"isolatedWin32-print\0";
pub const TOKEN_ASSIGN_PRIMARY: u32 = 1;
pub const TOKEN_DUPLICATE: u32 = 2;
pub const TOKEN_IMPERSONATE: u32 = 4;
pub const TOKEN_QUERY: u32 = 8;
pub const TOKEN_QUERY_SOURCE: u32 = 16;
pub const TOKEN_ADJUST_PRIVILEGES: u32 = 32;
pub const TOKEN_ADJUST_GROUPS: u32 = 64;
pub const TOKEN_ADJUST_DEFAULT: u32 = 128;
pub const TOKEN_ADJUST_SESSIONID: u32 = 256;
pub const TOKEN_ACCESS_PSEUDO_HANDLE_WIN8: u32 = 24;
pub const TOKEN_ACCESS_PSEUDO_HANDLE: u32 = 24;
pub const TOKEN_MANDATORY_POLICY_OFF: u32 = 0;
pub const TOKEN_MANDATORY_POLICY_NO_WRITE_UP: u32 = 1;
pub const TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN: u32 = 2;
pub const TOKEN_MANDATORY_POLICY_VALID_MASK: u32 = 3;
pub const POLICY_AUDIT_SUBCATEGORY_COUNT: u32 = 56;
pub const TOKEN_SOURCE_LENGTH: u32 = 8;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_INVALID: u32 = 0;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_INT64: u32 = 1;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64: u32 = 2;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_STRING: u32 = 3;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_FQBN: u32 = 4;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_SID: u32 = 5;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_BOOLEAN: u32 = 6;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING: u32 = 16;
pub const CLAIM_SECURITY_ATTRIBUTE_NON_INHERITABLE: u32 = 1;
pub const CLAIM_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE: u32 = 2;
pub const CLAIM_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY: u32 = 4;
pub const CLAIM_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT: u32 = 8;
pub const CLAIM_SECURITY_ATTRIBUTE_DISABLED: u32 = 16;
pub const CLAIM_SECURITY_ATTRIBUTE_MANDATORY: u32 = 32;
pub const CLAIM_SECURITY_ATTRIBUTE_VALID_FLAGS: u32 = 63;
pub const CLAIM_SECURITY_ATTRIBUTE_CUSTOM_FLAGS: u32 = 4294901760;
pub const CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1: u32 = 1;
pub const CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION: u32 = 1;
pub const SECURITY_DYNAMIC_TRACKING: u32 = 1;
pub const SECURITY_STATIC_TRACKING: u32 = 0;
pub const DISABLE_MAX_PRIVILEGE: u32 = 1;
pub const SANDBOX_INERT: u32 = 2;
pub const LUA_TOKEN: u32 = 4;
pub const WRITE_RESTRICTED: u32 = 8;
pub const SE_SIGNING_LEVEL_UNCHECKED: u32 = 0;
pub const SE_SIGNING_LEVEL_UNSIGNED: u32 = 1;
pub const SE_SIGNING_LEVEL_ENTERPRISE: u32 = 2;
pub const SE_SIGNING_LEVEL_CUSTOM_1: u32 = 3;
pub const SE_SIGNING_LEVEL_DEVELOPER: u32 = 3;
pub const SE_SIGNING_LEVEL_AUTHENTICODE: u32 = 4;
pub const SE_SIGNING_LEVEL_CUSTOM_2: u32 = 5;
pub const SE_SIGNING_LEVEL_STORE: u32 = 6;
pub const SE_SIGNING_LEVEL_CUSTOM_3: u32 = 7;
pub const SE_SIGNING_LEVEL_ANTIMALWARE: u32 = 7;
pub const SE_SIGNING_LEVEL_MICROSOFT: u32 = 8;
pub const SE_SIGNING_LEVEL_CUSTOM_4: u32 = 9;
pub const SE_SIGNING_LEVEL_CUSTOM_5: u32 = 10;
pub const SE_SIGNING_LEVEL_DYNAMIC_CODEGEN: u32 = 11;
pub const SE_SIGNING_LEVEL_WINDOWS: u32 = 12;
pub const SE_SIGNING_LEVEL_CUSTOM_7: u32 = 13;
pub const SE_SIGNING_LEVEL_WINDOWS_TCB: u32 = 14;
pub const SE_SIGNING_LEVEL_CUSTOM_6: u32 = 15;
pub const SE_LEARNING_MODE_FLAG_PERMISSIVE: u32 = 1;
pub const PROCESS_TERMINATE: u32 = 1;
pub const PROCESS_CREATE_THREAD: u32 = 2;
pub const PROCESS_SET_SESSIONID: u32 = 4;
pub const PROCESS_VM_OPERATION: u32 = 8;
pub const PROCESS_VM_READ: u32 = 16;
pub const PROCESS_VM_WRITE: u32 = 32;
pub const PROCESS_DUP_HANDLE: u32 = 64;
pub const PROCESS_CREATE_PROCESS: u32 = 128;
pub const PROCESS_SET_QUOTA: u32 = 256;
pub const PROCESS_SET_INFORMATION: u32 = 512;
pub const PROCESS_QUERY_INFORMATION: u32 = 1024;
pub const PROCESS_SUSPEND_RESUME: u32 = 2048;
pub const PROCESS_QUERY_LIMITED_INFORMATION: u32 = 4096;
pub const PROCESS_SET_LIMITED_INFORMATION: u32 = 8192;
pub const MAXIMUM_PROC_PER_GROUP: u32 = 64;
pub const MAXIMUM_PROCESSORS: u32 = 64;
pub const THREAD_TERMINATE: u32 = 1;
pub const THREAD_SUSPEND_RESUME: u32 = 2;
pub const THREAD_GET_CONTEXT: u32 = 8;
pub const THREAD_SET_CONTEXT: u32 = 16;
pub const THREAD_SET_INFORMATION: u32 = 32;
pub const THREAD_QUERY_INFORMATION: u32 = 64;
pub const THREAD_SET_THREAD_TOKEN: u32 = 128;
pub const THREAD_IMPERSONATE: u32 = 256;
pub const THREAD_DIRECT_IMPERSONATION: u32 = 512;
pub const THREAD_SET_LIMITED_INFORMATION: u32 = 1024;
pub const THREAD_QUERY_LIMITED_INFORMATION: u32 = 2048;
pub const THREAD_RESUME: u32 = 4096;
pub const JOB_OBJECT_ASSIGN_PROCESS: u32 = 1;
pub const JOB_OBJECT_SET_ATTRIBUTES: u32 = 2;
pub const JOB_OBJECT_QUERY: u32 = 4;
pub const JOB_OBJECT_TERMINATE: u32 = 8;
pub const JOB_OBJECT_SET_SECURITY_ATTRIBUTES: u32 = 16;
pub const JOB_OBJECT_IMPERSONATE: u32 = 32;
pub const FLS_MAXIMUM_AVAILABLE: u32 = 128;
pub const TLS_MINIMUM_AVAILABLE: u32 = 64;
pub const THREAD_DYNAMIC_CODE_ALLOW: u32 = 1;
pub const THREAD_BASE_PRIORITY_LOWRT: u32 = 15;
pub const THREAD_BASE_PRIORITY_MAX: u32 = 2;
pub const THREAD_BASE_PRIORITY_MIN: i32 = -2;
pub const THREAD_BASE_PRIORITY_IDLE: i32 = -15;
pub const COMPONENT_KTM: u32 = 1;
pub const COMPONENT_VALID_FLAGS: u32 = 1;
pub const DYNAMIC_EH_CONTINUATION_TARGET_ADD: u32 = 1;
pub const DYNAMIC_EH_CONTINUATION_TARGET_PROCESSED: u32 = 2;
pub const DYNAMIC_ENFORCED_ADDRESS_RANGE_ADD: u32 = 1;
pub const DYNAMIC_ENFORCED_ADDRESS_RANGE_PROCESSED: u32 = 2;
pub const QUOTA_LIMITS_HARDWS_MIN_ENABLE: u32 = 1;
pub const QUOTA_LIMITS_HARDWS_MIN_DISABLE: u32 = 2;
pub const QUOTA_LIMITS_HARDWS_MAX_ENABLE: u32 = 4;
pub const QUOTA_LIMITS_HARDWS_MAX_DISABLE: u32 = 8;
pub const QUOTA_LIMITS_USE_DEFAULT_LIMITS: u32 = 16;
pub const MAX_HW_COUNTERS: u32 = 16;
pub const THREAD_PROFILING_FLAG_DISPATCH: u32 = 1;
pub const JOB_OBJECT_NET_RATE_CONTROL_MAX_DSCP_TAG: u32 = 64;
pub const JOB_OBJECT_TERMINATE_AT_END_OF_JOB: u32 = 0;
pub const JOB_OBJECT_POST_AT_END_OF_JOB: u32 = 1;
pub const JOB_OBJECT_MSG_END_OF_JOB_TIME: u32 = 1;
pub const JOB_OBJECT_MSG_END_OF_PROCESS_TIME: u32 = 2;
pub const JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT: u32 = 3;
pub const JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO: u32 = 4;
pub const JOB_OBJECT_MSG_NEW_PROCESS: u32 = 6;
pub const JOB_OBJECT_MSG_EXIT_PROCESS: u32 = 7;
pub const JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS: u32 = 8;
pub const JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT: u32 = 9;
pub const JOB_OBJECT_MSG_JOB_MEMORY_LIMIT: u32 = 10;
pub const JOB_OBJECT_MSG_NOTIFICATION_LIMIT: u32 = 11;
pub const JOB_OBJECT_MSG_JOB_CYCLE_TIME_LIMIT: u32 = 12;
pub const JOB_OBJECT_MSG_SILO_TERMINATED: u32 = 13;
pub const JOB_OBJECT_MSG_MINIMUM: u32 = 1;
pub const JOB_OBJECT_MSG_MAXIMUM: u32 = 12;
pub const JOB_OBJECT_LIMIT_WORKINGSET: u32 = 1;
pub const JOB_OBJECT_LIMIT_PROCESS_TIME: u32 = 2;
pub const JOB_OBJECT_LIMIT_JOB_TIME: u32 = 4;
pub const JOB_OBJECT_LIMIT_ACTIVE_PROCESS: u32 = 8;
pub const JOB_OBJECT_LIMIT_AFFINITY: u32 = 16;
pub const JOB_OBJECT_LIMIT_PRIORITY_CLASS: u32 = 32;
pub const JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME: u32 = 64;
pub const JOB_OBJECT_LIMIT_SCHEDULING_CLASS: u32 = 128;
pub const JOB_OBJECT_LIMIT_PROCESS_MEMORY: u32 = 256;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY: u32 = 512;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY_HIGH: u32 = 512;
pub const JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION: u32 = 1024;
pub const JOB_OBJECT_LIMIT_BREAKAWAY_OK: u32 = 2048;
pub const JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK: u32 = 4096;
pub const JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE: u32 = 8192;
pub const JOB_OBJECT_LIMIT_SUBSET_AFFINITY: u32 = 16384;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY_LOW: u32 = 32768;
pub const JOB_OBJECT_LIMIT_JOB_READ_BYTES: u32 = 65536;
pub const JOB_OBJECT_LIMIT_JOB_WRITE_BYTES: u32 = 131072;
pub const JOB_OBJECT_LIMIT_RATE_CONTROL: u32 = 262144;
pub const JOB_OBJECT_LIMIT_CPU_RATE_CONTROL: u32 = 262144;
pub const JOB_OBJECT_LIMIT_IO_RATE_CONTROL: u32 = 524288;
pub const JOB_OBJECT_LIMIT_NET_RATE_CONTROL: u32 = 1048576;
pub const JOB_OBJECT_LIMIT_RESERVED3: u32 = 32768;
pub const JOB_OBJECT_LIMIT_RESERVED4: u32 = 65536;
pub const JOB_OBJECT_LIMIT_RESERVED5: u32 = 131072;
pub const JOB_OBJECT_LIMIT_RESERVED6: u32 = 262144;
pub const JOB_OBJECT_LIMIT_VALID_FLAGS: u32 = 524287;
pub const JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS: u32 = 255;
pub const JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS: u32 = 32767;
pub const JOB_OBJECT_RESERVED_LIMIT_VALID_FLAGS: u32 = 524287;
pub const JOB_OBJECT_NOTIFICATION_LIMIT_VALID_FLAGS: u32 = 459268;
pub const JOB_OBJECT_UILIMIT_NONE: u32 = 0;
pub const JOB_OBJECT_UILIMIT_HANDLES: u32 = 1;
pub const JOB_OBJECT_UILIMIT_READCLIPBOARD: u32 = 2;
pub const JOB_OBJECT_UILIMIT_WRITECLIPBOARD: u32 = 4;
pub const JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS: u32 = 8;
pub const JOB_OBJECT_UILIMIT_DISPLAYSETTINGS: u32 = 16;
pub const JOB_OBJECT_UILIMIT_GLOBALATOMS: u32 = 32;
pub const JOB_OBJECT_UILIMIT_DESKTOP: u32 = 64;
pub const JOB_OBJECT_UILIMIT_EXITWINDOWS: u32 = 128;
pub const JOB_OBJECT_UILIMIT_ALL: u32 = 255;
pub const JOB_OBJECT_UI_VALID_FLAGS: u32 = 255;
pub const JOB_OBJECT_SECURITY_NO_ADMIN: u32 = 1;
pub const JOB_OBJECT_SECURITY_RESTRICTED_TOKEN: u32 = 2;
pub const JOB_OBJECT_SECURITY_ONLY_TOKEN: u32 = 4;
pub const JOB_OBJECT_SECURITY_FILTER_TOKENS: u32 = 8;
pub const JOB_OBJECT_SECURITY_VALID_FLAGS: u32 = 15;
pub const JOB_OBJECT_CPU_RATE_CONTROL_ENABLE: u32 = 1;
pub const JOB_OBJECT_CPU_RATE_CONTROL_WEIGHT_BASED: u32 = 2;
pub const JOB_OBJECT_CPU_RATE_CONTROL_HARD_CAP: u32 = 4;
pub const JOB_OBJECT_CPU_RATE_CONTROL_NOTIFY: u32 = 8;
pub const JOB_OBJECT_CPU_RATE_CONTROL_MIN_MAX_RATE: u32 = 16;
pub const JOB_OBJECT_CPU_RATE_CONTROL_VALID_FLAGS: u32 = 31;
pub const MEMORY_PARTITION_QUERY_ACCESS: u32 = 1;
pub const MEMORY_PARTITION_MODIFY_ACCESS: u32 = 2;
pub const EVENT_MODIFY_STATE: u32 = 2;
pub const MUTANT_QUERY_STATE: u32 = 1;
pub const SEMAPHORE_MODIFY_STATE: u32 = 2;
pub const TIMER_QUERY_STATE: u32 = 1;
pub const TIMER_MODIFY_STATE: u32 = 2;
pub const TIME_ZONE_ID_UNKNOWN: u32 = 0;
pub const TIME_ZONE_ID_STANDARD: u32 = 1;
pub const TIME_ZONE_ID_DAYLIGHT: u32 = 2;
pub const LTP_PC_SMT: u32 = 1;
pub const CACHE_FULLY_ASSOCIATIVE: u32 = 255;
pub const SYSTEM_CPU_SET_INFORMATION_PARKED: u32 = 1;
pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED: u32 = 2;
pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED_TO_TARGET_PROCESS: u32 = 4;
pub const SYSTEM_CPU_SET_INFORMATION_REALTIME: u32 = 8;
pub const PROCESSOR_INTEL_386: u32 = 386;
pub const PROCESSOR_INTEL_486: u32 = 486;
pub const PROCESSOR_INTEL_PENTIUM: u32 = 586;
pub const PROCESSOR_INTEL_IA64: u32 = 2200;
pub const PROCESSOR_AMD_X8664: u32 = 8664;
pub const PROCESSOR_MIPS_R4000: u32 = 4000;
pub const PROCESSOR_ALPHA_21064: u32 = 21064;
pub const PROCESSOR_PPC_601: u32 = 601;
pub const PROCESSOR_PPC_603: u32 = 603;
pub const PROCESSOR_PPC_604: u32 = 604;
pub const PROCESSOR_PPC_620: u32 = 620;
pub const PROCESSOR_HITACHI_SH3: u32 = 10003;
pub const PROCESSOR_HITACHI_SH3E: u32 = 10004;
pub const PROCESSOR_HITACHI_SH4: u32 = 10005;
pub const PROCESSOR_MOTOROLA_821: u32 = 821;
pub const PROCESSOR_SHx_SH3: u32 = 103;
pub const PROCESSOR_SHx_SH4: u32 = 104;
pub const PROCESSOR_STRONGARM: u32 = 2577;
pub const PROCESSOR_ARM720: u32 = 1824;
pub const PROCESSOR_ARM820: u32 = 2080;
pub const PROCESSOR_ARM920: u32 = 2336;
pub const PROCESSOR_ARM_7TDMI: u32 = 70001;
pub const PROCESSOR_OPTIL: u32 = 18767;
pub const PROCESSOR_ARCHITECTURE_INTEL: u32 = 0;
pub const PROCESSOR_ARCHITECTURE_MIPS: u32 = 1;
pub const PROCESSOR_ARCHITECTURE_ALPHA: u32 = 2;
pub const PROCESSOR_ARCHITECTURE_PPC: u32 = 3;
pub const PROCESSOR_ARCHITECTURE_SHX: u32 = 4;
pub const PROCESSOR_ARCHITECTURE_ARM: u32 = 5;
pub const PROCESSOR_ARCHITECTURE_IA64: u32 = 6;
pub const PROCESSOR_ARCHITECTURE_ALPHA64: u32 = 7;
pub const PROCESSOR_ARCHITECTURE_MSIL: u32 = 8;
pub const PROCESSOR_ARCHITECTURE_AMD64: u32 = 9;
pub const PROCESSOR_ARCHITECTURE_IA32_ON_WIN64: u32 = 10;
pub const PROCESSOR_ARCHITECTURE_NEUTRAL: u32 = 11;
pub const PROCESSOR_ARCHITECTURE_ARM64: u32 = 12;
pub const PROCESSOR_ARCHITECTURE_ARM32_ON_WIN64: u32 = 13;
pub const PROCESSOR_ARCHITECTURE_IA32_ON_ARM64: u32 = 14;
pub const PROCESSOR_ARCHITECTURE_UNKNOWN: u32 = 65535;
pub const PF_FLOATING_POINT_PRECISION_ERRATA: u32 = 0;
pub const PF_FLOATING_POINT_EMULATED: u32 = 1;
pub const PF_COMPARE_EXCHANGE_DOUBLE: u32 = 2;
pub const PF_MMX_INSTRUCTIONS_AVAILABLE: u32 = 3;
pub const PF_PPC_MOVEMEM_64BIT_OK: u32 = 4;
pub const PF_ALPHA_BYTE_INSTRUCTIONS: u32 = 5;
pub const PF_XMMI_INSTRUCTIONS_AVAILABLE: u32 = 6;
pub const PF_3DNOW_INSTRUCTIONS_AVAILABLE: u32 = 7;
pub const PF_RDTSC_INSTRUCTION_AVAILABLE: u32 = 8;
pub const PF_PAE_ENABLED: u32 = 9;
pub const PF_XMMI64_INSTRUCTIONS_AVAILABLE: u32 = 10;
pub const PF_SSE_DAZ_MODE_AVAILABLE: u32 = 11;
pub const PF_NX_ENABLED: u32 = 12;
pub const PF_SSE3_INSTRUCTIONS_AVAILABLE: u32 = 13;
pub const PF_COMPARE_EXCHANGE128: u32 = 14;
pub const PF_COMPARE64_EXCHANGE128: u32 = 15;
pub const PF_CHANNELS_ENABLED: u32 = 16;
pub const PF_XSAVE_ENABLED: u32 = 17;
pub const PF_ARM_VFP_32_REGISTERS_AVAILABLE: u32 = 18;
pub const PF_ARM_NEON_INSTRUCTIONS_AVAILABLE: u32 = 19;
pub const PF_SECOND_LEVEL_ADDRESS_TRANSLATION: u32 = 20;
pub const PF_VIRT_FIRMWARE_ENABLED: u32 = 21;
pub const PF_RDWRFSGSBASE_AVAILABLE: u32 = 22;
pub const PF_FASTFAIL_AVAILABLE: u32 = 23;
pub const PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE: u32 = 24;
pub const PF_ARM_64BIT_LOADSTORE_ATOMIC: u32 = 25;
pub const PF_ARM_EXTERNAL_CACHE_AVAILABLE: u32 = 26;
pub const PF_ARM_FMAC_INSTRUCTIONS_AVAILABLE: u32 = 27;
pub const PF_RDRAND_INSTRUCTION_AVAILABLE: u32 = 28;
pub const PF_ARM_V8_INSTRUCTIONS_AVAILABLE: u32 = 29;
pub const PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE: u32 = 30;
pub const PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE: u32 = 31;
pub const PF_RDTSCP_INSTRUCTION_AVAILABLE: u32 = 32;
pub const PF_RDPID_INSTRUCTION_AVAILABLE: u32 = 33;
pub const PF_ARM_V81_ATOMIC_INSTRUCTIONS_AVAILABLE: u32 = 34;
pub const PF_MONITORX_INSTRUCTION_AVAILABLE: u32 = 35;
pub const PF_SSSE3_INSTRUCTIONS_AVAILABLE: u32 = 36;
pub const PF_SSE4_1_INSTRUCTIONS_AVAILABLE: u32 = 37;
pub const PF_SSE4_2_INSTRUCTIONS_AVAILABLE: u32 = 38;
pub const PF_AVX_INSTRUCTIONS_AVAILABLE: u32 = 39;
pub const PF_AVX2_INSTRUCTIONS_AVAILABLE: u32 = 40;
pub const PF_AVX512F_INSTRUCTIONS_AVAILABLE: u32 = 41;
pub const PF_ERMS_AVAILABLE: u32 = 42;
pub const PF_ARM_V82_DP_INSTRUCTIONS_AVAILABLE: u32 = 43;
pub const PF_ARM_V83_JSCVT_INSTRUCTIONS_AVAILABLE: u32 = 44;
pub const XSTATE_LEGACY_FLOATING_POINT: u32 = 0;
pub const XSTATE_LEGACY_SSE: u32 = 1;
pub const XSTATE_GSSE: u32 = 2;
pub const XSTATE_AVX: u32 = 2;
pub const XSTATE_MPX_BNDREGS: u32 = 3;
pub const XSTATE_MPX_BNDCSR: u32 = 4;
pub const XSTATE_AVX512_KMASK: u32 = 5;
pub const XSTATE_AVX512_ZMM_H: u32 = 6;
pub const XSTATE_AVX512_ZMM: u32 = 7;
pub const XSTATE_IPT: u32 = 8;
pub const XSTATE_PASID: u32 = 10;
pub const XSTATE_CET_U: u32 = 11;
pub const XSTATE_CET_S: u32 = 12;
pub const XSTATE_AMX_TILE_CONFIG: u32 = 17;
pub const XSTATE_AMX_TILE_DATA: u32 = 18;
pub const XSTATE_LWP: u32 = 62;
pub const MAXIMUM_XSTATE_FEATURES: u32 = 64;
pub const XSTATE_MASK_LEGACY_FLOATING_POINT: u32 = 1;
pub const XSTATE_MASK_LEGACY_SSE: u32 = 2;
pub const XSTATE_MASK_LEGACY: u32 = 3;
pub const XSTATE_MASK_GSSE: u32 = 4;
pub const XSTATE_MASK_AVX: u32 = 4;
pub const XSTATE_MASK_MPX: u32 = 24;
pub const XSTATE_MASK_AVX512: u32 = 224;
pub const XSTATE_MASK_IPT: u32 = 256;
pub const XSTATE_MASK_PASID: u32 = 1024;
pub const XSTATE_MASK_CET_U: u32 = 2048;
pub const XSTATE_MASK_CET_S: u32 = 4096;
pub const XSTATE_MASK_AMX_TILE_CONFIG: u32 = 131072;
pub const XSTATE_MASK_AMX_TILE_DATA: u32 = 262144;
pub const XSTATE_MASK_LWP: u64 = 4611686018427387904;
pub const XSTATE_MASK_ALLOWED: u64 = 4611686018427784703;
pub const XSTATE_MASK_PERSISTENT: u64 = 4611686018427387920;
pub const XSTATE_MASK_USER_VISIBLE_SUPERVISOR: u32 = 2048;
pub const XSTATE_MASK_LARGE_FEATURES: u32 = 262144;
pub const XSTATE_COMPACTION_ENABLE: u32 = 63;
pub const XSTATE_COMPACTION_ENABLE_MASK: i64 = -9223372036854775808;
pub const XSTATE_ALIGN_BIT: u32 = 1;
pub const XSTATE_ALIGN_MASK: u32 = 2;
pub const XSTATE_XFD_BIT: u32 = 2;
pub const XSTATE_XFD_MASK: u32 = 4;
pub const XSTATE_CONTROLFLAG_XSAVEOPT_MASK: u32 = 1;
pub const XSTATE_CONTROLFLAG_XSAVEC_MASK: u32 = 2;
pub const XSTATE_CONTROLFLAG_XFD_MASK: u32 = 4;
pub const XSTATE_CONTROLFLAG_VALID_MASK: u32 = 7;
pub const CFG_CALL_TARGET_VALID: u32 = 1;
pub const CFG_CALL_TARGET_PROCESSED: u32 = 2;
pub const CFG_CALL_TARGET_CONVERT_EXPORT_SUPPRESSED_TO_VALID: u32 = 4;
pub const CFG_CALL_TARGET_VALID_XFG: u32 = 8;
pub const CFG_CALL_TARGET_CONVERT_XFG_TO_CFG: u32 = 16;
pub const SECTION_QUERY: u32 = 1;
pub const SECTION_MAP_WRITE: u32 = 2;
pub const SECTION_MAP_READ: u32 = 4;
pub const SECTION_MAP_EXECUTE: u32 = 8;
pub const SECTION_EXTEND_SIZE: u32 = 16;
pub const SECTION_MAP_EXECUTE_EXPLICIT: u32 = 32;
pub const SESSION_QUERY_ACCESS: u32 = 1;
pub const SESSION_MODIFY_ACCESS: u32 = 2;
pub const PAGE_NOACCESS: u32 = 1;
pub const PAGE_READONLY: u32 = 2;
pub const PAGE_READWRITE: u32 = 4;
pub const PAGE_WRITECOPY: u32 = 8;
pub const PAGE_EXECUTE: u32 = 16;
pub const PAGE_EXECUTE_READ: u32 = 32;
pub const PAGE_EXECUTE_READWRITE: u32 = 64;
pub const PAGE_EXECUTE_WRITECOPY: u32 = 128;
pub const PAGE_GUARD: u32 = 256;
pub const PAGE_NOCACHE: u32 = 512;
pub const PAGE_WRITECOMBINE: u32 = 1024;
pub const PAGE_GRAPHICS_NOACCESS: u32 = 2048;
pub const PAGE_GRAPHICS_READONLY: u32 = 4096;
pub const PAGE_GRAPHICS_READWRITE: u32 = 8192;
pub const PAGE_GRAPHICS_EXECUTE: u32 = 16384;
pub const PAGE_GRAPHICS_EXECUTE_READ: u32 = 32768;
pub const PAGE_GRAPHICS_EXECUTE_READWRITE: u32 = 65536;
pub const PAGE_GRAPHICS_COHERENT: u32 = 131072;
pub const PAGE_GRAPHICS_NOCACHE: u32 = 262144;
pub const PAGE_ENCLAVE_THREAD_CONTROL: u32 = 2147483648;
pub const PAGE_REVERT_TO_FILE_MAP: u32 = 2147483648;
pub const PAGE_TARGETS_NO_UPDATE: u32 = 1073741824;
pub const PAGE_TARGETS_INVALID: u32 = 1073741824;
pub const PAGE_ENCLAVE_UNVALIDATED: u32 = 536870912;
pub const PAGE_ENCLAVE_MASK: u32 = 268435456;
pub const PAGE_ENCLAVE_DECOMMIT: u32 = 268435456;
pub const PAGE_ENCLAVE_SS_FIRST: u32 = 268435457;
pub const PAGE_ENCLAVE_SS_REST: u32 = 268435458;
pub const MEM_COMMIT: u32 = 4096;
pub const MEM_RESERVE: u32 = 8192;
pub const MEM_REPLACE_PLACEHOLDER: u32 = 16384;
pub const MEM_DECOMMIT: u32 = 16384;
pub const MEM_RELEASE: u32 = 32768;
pub const MEM_FREE: u32 = 65536;
pub const MEM_PRIVATE: u32 = 131072;
pub const MEM_RESERVE_PLACEHOLDER: u32 = 262144;
pub const MEM_MAPPED: u32 = 262144;
pub const MEM_RESET: u32 = 524288;
pub const MEM_TOP_DOWN: u32 = 1048576;
pub const MEM_WRITE_WATCH: u32 = 2097152;
pub const MEM_PHYSICAL: u32 = 4194304;
pub const MEM_ROTATE: u32 = 8388608;
pub const MEM_DIFFERENT_IMAGE_BASE_OK: u32 = 8388608;
pub const MEM_RESET_UNDO: u32 = 16777216;
pub const MEM_LARGE_PAGES: u32 = 536870912;
pub const MEM_4MB_PAGES: u32 = 2147483648;
pub const MEM_64K_PAGES: u32 = 541065216;
pub const MEM_UNMAP_WITH_TRANSIENT_BOOST: u32 = 1;
pub const MEM_COALESCE_PLACEHOLDERS: u32 = 1;
pub const MEM_PRESERVE_PLACEHOLDER: u32 = 2;
pub const MEM_EXTENDED_PARAMETER_GRAPHICS: u32 = 1;
pub const MEM_EXTENDED_PARAMETER_NONPAGED: u32 = 2;
pub const MEM_EXTENDED_PARAMETER_ZERO_PAGES_OPTIONAL: u32 = 4;
pub const MEM_EXTENDED_PARAMETER_NONPAGED_LARGE: u32 = 8;
pub const MEM_EXTENDED_PARAMETER_NONPAGED_HUGE: u32 = 16;
pub const MEM_EXTENDED_PARAMETER_SOFT_FAULT_PAGES: u32 = 32;
pub const MEM_EXTENDED_PARAMETER_EC_CODE: u32 = 64;
pub const MEM_EXTENDED_PARAMETER_IMAGE_NO_HPAT: u32 = 128;
pub const MEM_EXTENDED_PARAMETER_TYPE_BITS: u32 = 8;
pub const SEC_HUGE_PAGES: u32 = 131072;
pub const SEC_PARTITION_OWNER_HANDLE: u32 = 262144;
pub const SEC_64K_PAGES: u32 = 524288;
pub const SEC_FILE: u32 = 8388608;
pub const SEC_IMAGE: u32 = 16777216;
pub const SEC_PROTECTED_IMAGE: u32 = 33554432;
pub const SEC_RESERVE: u32 = 67108864;
pub const SEC_COMMIT: u32 = 134217728;
pub const SEC_NOCACHE: u32 = 268435456;
pub const SEC_WRITECOMBINE: u32 = 1073741824;
pub const SEC_LARGE_PAGES: u32 = 2147483648;
pub const SEC_IMAGE_NO_EXECUTE: u32 = 285212672;
pub const MEM_IMAGE: u32 = 16777216;
pub const WRITE_WATCH_FLAG_RESET: u32 = 1;
pub const ENCLAVE_TYPE_SGX: u32 = 1;
pub const ENCLAVE_TYPE_SGX2: u32 = 2;
pub const ENCLAVE_TYPE_VBS: u32 = 16;
pub const ENCLAVE_VBS_FLAG_DEBUG: u32 = 1;
pub const ENCLAVE_TYPE_VBS_BASIC: u32 = 17;
pub const VBS_BASIC_PAGE_MEASURED_DATA: u32 = 1;
pub const VBS_BASIC_PAGE_UNMEASURED_DATA: u32 = 2;
pub const VBS_BASIC_PAGE_ZERO_FILL: u32 = 3;
pub const VBS_BASIC_PAGE_THREAD_DESCRIPTOR: u32 = 4;
pub const VBS_BASIC_PAGE_SYSTEM_CALL: u32 = 5;
pub const DEDICATED_MEMORY_CACHE_ELIGIBLE: u32 = 1;
pub const FILE_READ_DATA: u32 = 1;
pub const FILE_LIST_DIRECTORY: u32 = 1;
pub const FILE_WRITE_DATA: u32 = 2;
pub const FILE_ADD_FILE: u32 = 2;
pub const FILE_APPEND_DATA: u32 = 4;
pub const FILE_ADD_SUBDIRECTORY: u32 = 4;
pub const FILE_CREATE_PIPE_INSTANCE: u32 = 4;
pub const FILE_READ_EA: u32 = 8;
pub const FILE_WRITE_EA: u32 = 16;
pub const FILE_EXECUTE: u32 = 32;
pub const FILE_TRAVERSE: u32 = 32;
pub const FILE_DELETE_CHILD: u32 = 64;
pub const FILE_READ_ATTRIBUTES: u32 = 128;
pub const FILE_WRITE_ATTRIBUTES: u32 = 256;
pub const FILE_SUPERSEDE: u32 = 0;
pub const FILE_OPEN: u32 = 1;
pub const FILE_CREATE: u32 = 2;
pub const FILE_OPEN_IF: u32 = 3;
pub const FILE_OVERWRITE: u32 = 4;
pub const FILE_OVERWRITE_IF: u32 = 5;
pub const FILE_MAXIMUM_DISPOSITION: u32 = 5;
pub const FILE_DIRECTORY_FILE: u32 = 1;
pub const FILE_WRITE_THROUGH: u32 = 2;
pub const FILE_SEQUENTIAL_ONLY: u32 = 4;
pub const FILE_NO_INTERMEDIATE_BUFFERING: u32 = 8;
pub const FILE_SYNCHRONOUS_IO_ALERT: u32 = 16;
pub const FILE_SYNCHRONOUS_IO_NONALERT: u32 = 32;
pub const FILE_NON_DIRECTORY_FILE: u32 = 64;
pub const FILE_CREATE_TREE_CONNECTION: u32 = 128;
pub const FILE_COMPLETE_IF_OPLOCKED: u32 = 256;
pub const FILE_NO_EA_KNOWLEDGE: u32 = 512;
pub const FILE_OPEN_REMOTE_INSTANCE: u32 = 1024;
pub const FILE_RANDOM_ACCESS: u32 = 2048;
pub const FILE_DELETE_ON_CLOSE: u32 = 4096;
pub const FILE_OPEN_BY_FILE_ID: u32 = 8192;
pub const FILE_OPEN_FOR_BACKUP_INTENT: u32 = 16384;
pub const FILE_NO_COMPRESSION: u32 = 32768;
pub const FILE_OPEN_REQUIRING_OPLOCK: u32 = 65536;
pub const FILE_DISALLOW_EXCLUSIVE: u32 = 131072;
pub const FILE_RESERVE_OPFILTER: u32 = 1048576;
pub const FILE_OPEN_REPARSE_POINT: u32 = 2097152;
pub const FILE_OPEN_NO_RECALL: u32 = 4194304;
pub const FILE_OPEN_FOR_FREE_SPACE_QUERY: u32 = 8388608;
pub const FILE_SHARE_READ: u32 = 1;
pub const FILE_SHARE_WRITE: u32 = 2;
pub const FILE_SHARE_DELETE: u32 = 4;
pub const FILE_SHARE_VALID_FLAGS: u32 = 7;
pub const FILE_ATTRIBUTE_READONLY: u32 = 1;
pub const FILE_ATTRIBUTE_HIDDEN: u32 = 2;
pub const FILE_ATTRIBUTE_SYSTEM: u32 = 4;
pub const FILE_ATTRIBUTE_DIRECTORY: u32 = 16;
pub const FILE_ATTRIBUTE_ARCHIVE: u32 = 32;
pub const FILE_ATTRIBUTE_DEVICE: u32 = 64;
pub const FILE_ATTRIBUTE_NORMAL: u32 = 128;
pub const FILE_ATTRIBUTE_TEMPORARY: u32 = 256;
pub const FILE_ATTRIBUTE_SPARSE_FILE: u32 = 512;
pub const FILE_ATTRIBUTE_REPARSE_POINT: u32 = 1024;
pub const FILE_ATTRIBUTE_COMPRESSED: u32 = 2048;
pub const FILE_ATTRIBUTE_OFFLINE: u32 = 4096;
pub const FILE_ATTRIBUTE_NOT_CONTENT_INDEXED: u32 = 8192;
pub const FILE_ATTRIBUTE_ENCRYPTED: u32 = 16384;
pub const FILE_ATTRIBUTE_INTEGRITY_STREAM: u32 = 32768;
pub const FILE_ATTRIBUTE_VIRTUAL: u32 = 65536;
pub const FILE_ATTRIBUTE_NO_SCRUB_DATA: u32 = 131072;
pub const FILE_ATTRIBUTE_EA: u32 = 262144;
pub const FILE_ATTRIBUTE_PINNED: u32 = 524288;
pub const FILE_ATTRIBUTE_UNPINNED: u32 = 1048576;
pub const FILE_ATTRIBUTE_RECALL_ON_OPEN: u32 = 262144;
pub const FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS: u32 = 4194304;
pub const TREE_CONNECT_ATTRIBUTE_PRIVACY: u32 = 16384;
pub const TREE_CONNECT_ATTRIBUTE_INTEGRITY: u32 = 32768;
pub const TREE_CONNECT_ATTRIBUTE_GLOBAL: u32 = 4;
pub const TREE_CONNECT_ATTRIBUTE_PINNED: u32 = 2;
pub const FILE_ATTRIBUTE_STRICTLY_SEQUENTIAL: u32 = 536870912;
pub const FILE_NOTIFY_CHANGE_FILE_NAME: u32 = 1;
pub const FILE_NOTIFY_CHANGE_DIR_NAME: u32 = 2;
pub const FILE_NOTIFY_CHANGE_ATTRIBUTES: u32 = 4;
pub const FILE_NOTIFY_CHANGE_SIZE: u32 = 8;
pub const FILE_NOTIFY_CHANGE_LAST_WRITE: u32 = 16;
pub const FILE_NOTIFY_CHANGE_LAST_ACCESS: u32 = 32;
pub const FILE_NOTIFY_CHANGE_CREATION: u32 = 64;
pub const FILE_NOTIFY_CHANGE_SECURITY: u32 = 256;
pub const FILE_ACTION_ADDED: u32 = 1;
pub const FILE_ACTION_REMOVED: u32 = 2;
pub const FILE_ACTION_MODIFIED: u32 = 3;
pub const FILE_ACTION_RENAMED_OLD_NAME: u32 = 4;
pub const FILE_ACTION_RENAMED_NEW_NAME: u32 = 5;
pub const FILE_CASE_SENSITIVE_SEARCH: u32 = 1;
pub const FILE_CASE_PRESERVED_NAMES: u32 = 2;
pub const FILE_UNICODE_ON_DISK: u32 = 4;
pub const FILE_PERSISTENT_ACLS: u32 = 8;
pub const FILE_FILE_COMPRESSION: u32 = 16;
pub const FILE_VOLUME_QUOTAS: u32 = 32;
pub const FILE_SUPPORTS_SPARSE_FILES: u32 = 64;
pub const FILE_SUPPORTS_REPARSE_POINTS: u32 = 128;
pub const FILE_SUPPORTS_REMOTE_STORAGE: u32 = 256;
pub const FILE_RETURNS_CLEANUP_RESULT_INFO: u32 = 512;
pub const FILE_SUPPORTS_POSIX_UNLINK_RENAME: u32 = 1024;
pub const FILE_SUPPORTS_BYPASS_IO: u32 = 2048;
pub const FILE_SUPPORTS_STREAM_SNAPSHOTS: u32 = 4096;
pub const FILE_SUPPORTS_CASE_SENSITIVE_DIRS: u32 = 8192;
pub const FILE_VOLUME_IS_COMPRESSED: u32 = 32768;
pub const FILE_SUPPORTS_OBJECT_IDS: u32 = 65536;
pub const FILE_SUPPORTS_ENCRYPTION: u32 = 131072;
pub const FILE_NAMED_STREAMS: u32 = 262144;
pub const FILE_READ_ONLY_VOLUME: u32 = 524288;
pub const FILE_SEQUENTIAL_WRITE_ONCE: u32 = 1048576;
pub const FILE_SUPPORTS_TRANSACTIONS: u32 = 2097152;
pub const FILE_SUPPORTS_HARD_LINKS: u32 = 4194304;
pub const FILE_SUPPORTS_EXTENDED_ATTRIBUTES: u32 = 8388608;
pub const FILE_SUPPORTS_OPEN_BY_FILE_ID: u32 = 16777216;
pub const FILE_SUPPORTS_USN_JOURNAL: u32 = 33554432;
pub const FILE_SUPPORTS_INTEGRITY_STREAMS: u32 = 67108864;
pub const FILE_SUPPORTS_BLOCK_REFCOUNTING: u32 = 134217728;
pub const FILE_SUPPORTS_SPARSE_VDL: u32 = 268435456;
pub const FILE_DAX_VOLUME: u32 = 536870912;
pub const FILE_SUPPORTS_GHOSTING: u32 = 1073741824;
pub const FILE_NAME_FLAG_HARDLINK: u32 = 0;
pub const FILE_NAME_FLAG_NTFS: u32 = 1;
pub const FILE_NAME_FLAG_DOS: u32 = 2;
pub const FILE_NAME_FLAG_BOTH: u32 = 3;
pub const FILE_NAME_FLAGS_UNSPECIFIED: u32 = 128;
pub const FILE_CS_FLAG_CASE_SENSITIVE_DIR: u32 = 1;
pub const FLUSH_FLAGS_FILE_DATA_ONLY: u32 = 1;
pub const FLUSH_FLAGS_NO_SYNC: u32 = 2;
pub const MAXIMUM_REPARSE_DATA_BUFFER_SIZE: u32 = 16384;
pub const SYMLINK_FLAG_RELATIVE: u32 = 1;
pub const IO_REPARSE_TAG_RESERVED_ZERO: u32 = 0;
pub const IO_REPARSE_TAG_RESERVED_ONE: u32 = 1;
pub const IO_REPARSE_TAG_RESERVED_TWO: u32 = 2;
pub const IO_REPARSE_TAG_RESERVED_RANGE: u32 = 2;
pub const SCRUB_DATA_INPUT_FLAG_RESUME: u32 = 1;
pub const SCRUB_DATA_INPUT_FLAG_SKIP_IN_SYNC: u32 = 2;
pub const SCRUB_DATA_INPUT_FLAG_SKIP_NON_INTEGRITY_DATA: u32 = 4;
pub const SCRUB_DATA_INPUT_FLAG_IGNORE_REDUNDANCY: u32 = 8;
pub const SCRUB_DATA_INPUT_FLAG_SKIP_DATA: u32 = 16;
pub const SCRUB_DATA_INPUT_FLAG_SCRUB_BY_OBJECT_ID: u32 = 32;
pub const SCRUB_DATA_INPUT_FLAG_OPLOCK_NOT_ACQUIRED: u32 = 64;
pub const SCRUB_DATA_OUTPUT_FLAG_INCOMPLETE: u32 = 1;
pub const SCRUB_DATA_OUTPUT_FLAG_NON_USER_DATA_RANGE: u32 = 65536;
pub const SCRUB_DATA_OUTPUT_FLAG_PARITY_EXTENT_DATA_RETURNED: u32 = 131072;
pub const SCRUB_DATA_OUTPUT_FLAG_RESUME_CONTEXT_LENGTH_SPECIFIED: u32 = 262144;
pub const IO_COMPLETION_MODIFY_STATE: u32 = 2;
pub const DUPLICATE_CLOSE_SOURCE: u32 = 1;
pub const DUPLICATE_SAME_ACCESS: u32 = 2;
pub const POWERBUTTON_ACTION_INDEX_NOTHING: u32 = 0;
pub const POWERBUTTON_ACTION_INDEX_SLEEP: u32 = 1;
pub const POWERBUTTON_ACTION_INDEX_HIBERNATE: u32 = 2;
pub const POWERBUTTON_ACTION_INDEX_SHUTDOWN: u32 = 3;
pub const POWERBUTTON_ACTION_VALUE_NOTHING: u32 = 0;
pub const POWERBUTTON_ACTION_VALUE_SLEEP: u32 = 2;
pub const POWERBUTTON_ACTION_VALUE_HIBERNATE: u32 = 3;
pub const POWERBUTTON_ACTION_VALUE_SHUTDOWN: u32 = 6;
pub const PERFSTATE_POLICY_CHANGE_IDEAL: u32 = 0;
pub const PERFSTATE_POLICY_CHANGE_SINGLE: u32 = 1;
pub const PERFSTATE_POLICY_CHANGE_ROCKET: u32 = 2;
pub const PERFSTATE_POLICY_CHANGE_MAX: u32 = 2;
pub const PROCESSOR_PERF_BOOST_POLICY_DISABLED: u32 = 0;
pub const PROCESSOR_PERF_BOOST_POLICY_MAX: u32 = 100;
pub const PROCESSOR_PERF_BOOST_MODE_DISABLED: u32 = 0;
pub const PROCESSOR_PERF_BOOST_MODE_ENABLED: u32 = 1;
pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE: u32 = 2;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_ENABLED: u32 = 3;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE: u32 = 4;
pub const PROCESSOR_PERF_BOOST_MODE_MAX: u32 = 4;
pub const CORE_PARKING_POLICY_CHANGE_IDEAL: u32 = 0;
pub const CORE_PARKING_POLICY_CHANGE_SINGLE: u32 = 1;
pub const CORE_PARKING_POLICY_CHANGE_ROCKET: u32 = 2;
pub const CORE_PARKING_POLICY_CHANGE_MULTISTEP: u32 = 3;
pub const CORE_PARKING_POLICY_CHANGE_MAX: u32 = 3;
pub const POWER_DEVICE_IDLE_POLICY_PERFORMANCE: u32 = 0;
pub const POWER_DEVICE_IDLE_POLICY_CONSERVATIVE: u32 = 1;
pub const POWER_SYSTEM_MAXIMUM: u32 = 7;
pub const DIAGNOSTIC_REASON_VERSION: u32 = 0;
pub const POWER_REQUEST_CONTEXT_VERSION: u32 = 0;
pub const DIAGNOSTIC_REASON_SIMPLE_STRING: u32 = 1;
pub const DIAGNOSTIC_REASON_DETAILED_STRING: u32 = 2;
pub const DIAGNOSTIC_REASON_NOT_SPECIFIED: u32 = 2147483648;
pub const DIAGNOSTIC_REASON_INVALID_FLAGS: i64 = -2147483652;
pub const POWER_REQUEST_CONTEXT_SIMPLE_STRING: u32 = 1;
pub const POWER_REQUEST_CONTEXT_DETAILED_STRING: u32 = 2;
pub const PDCAP_D0_SUPPORTED: u32 = 1;
pub const PDCAP_D1_SUPPORTED: u32 = 2;
pub const PDCAP_D2_SUPPORTED: u32 = 4;
pub const PDCAP_D3_SUPPORTED: u32 = 8;
pub const PDCAP_WAKE_FROM_D0_SUPPORTED: u32 = 16;
pub const PDCAP_WAKE_FROM_D1_SUPPORTED: u32 = 32;
pub const PDCAP_WAKE_FROM_D2_SUPPORTED: u32 = 64;
pub const PDCAP_WAKE_FROM_D3_SUPPORTED: u32 = 128;
pub const PDCAP_WARM_EJECT_SUPPORTED: u32 = 256;
pub const POWER_SETTING_VALUE_VERSION: u32 = 1;
pub const POWER_PLATFORM_ROLE_V1: u32 = 1;
pub const POWER_PLATFORM_ROLE_V2: u32 = 2;
pub const POWER_PLATFORM_ROLE_VERSION: u32 = 2;
pub const PROC_IDLE_BUCKET_COUNT: u32 = 6;
pub const PROC_IDLE_BUCKET_COUNT_EX: u32 = 16;
pub const ACPI_PPM_SOFTWARE_ALL: u32 = 252;
pub const ACPI_PPM_SOFTWARE_ANY: u32 = 253;
pub const ACPI_PPM_HARDWARE_ALL: u32 = 254;
pub const MS_PPM_SOFTWARE_ALL: u32 = 1;
pub const PPM_FIRMWARE_ACPI1C2: u32 = 1;
pub const PPM_FIRMWARE_ACPI1C3: u32 = 2;
pub const PPM_FIRMWARE_ACPI1TSTATES: u32 = 4;
pub const PPM_FIRMWARE_CST: u32 = 8;
pub const PPM_FIRMWARE_CSD: u32 = 16;
pub const PPM_FIRMWARE_PCT: u32 = 32;
pub const PPM_FIRMWARE_PSS: u32 = 64;
pub const PPM_FIRMWARE_XPSS: u32 = 128;
pub const PPM_FIRMWARE_PPC: u32 = 256;
pub const PPM_FIRMWARE_PSD: u32 = 512;
pub const PPM_FIRMWARE_PTC: u32 = 1024;
pub const PPM_FIRMWARE_TSS: u32 = 2048;
pub const PPM_FIRMWARE_TPC: u32 = 4096;
pub const PPM_FIRMWARE_TSD: u32 = 8192;
pub const PPM_FIRMWARE_PCCH: u32 = 16384;
pub const PPM_FIRMWARE_PCCP: u32 = 32768;
pub const PPM_FIRMWARE_OSC: u32 = 65536;
pub const PPM_FIRMWARE_PDC: u32 = 131072;
pub const PPM_FIRMWARE_CPC: u32 = 262144;
pub const PPM_PERFORMANCE_IMPLEMENTATION_NONE: u32 = 0;
pub const PPM_PERFORMANCE_IMPLEMENTATION_PSTATES: u32 = 1;
pub const PPM_PERFORMANCE_IMPLEMENTATION_PCCV1: u32 = 2;
pub const PPM_PERFORMANCE_IMPLEMENTATION_CPPC: u32 = 3;
pub const PPM_PERFORMANCE_IMPLEMENTATION_PEP: u32 = 4;
pub const PPM_IDLE_IMPLEMENTATION_NONE: u32 = 0;
pub const PPM_IDLE_IMPLEMENTATION_CSTATES: u32 = 1;
pub const PPM_IDLE_IMPLEMENTATION_PEP: u32 = 2;
pub const POWER_ACTION_QUERY_ALLOWED: u32 = 1;
pub const POWER_ACTION_UI_ALLOWED: u32 = 2;
pub const POWER_ACTION_OVERRIDE_APPS: u32 = 4;
pub const POWER_ACTION_HIBERBOOT: u32 = 8;
pub const POWER_ACTION_PSEUDO_TRANSITION: u32 = 134217728;
pub const POWER_ACTION_LIGHTEST_FIRST: u32 = 268435456;
pub const POWER_ACTION_LOCK_CONSOLE: u32 = 536870912;
pub const POWER_ACTION_DISABLE_WAKES: u32 = 1073741824;
pub const POWER_ACTION_CRITICAL: u32 = 2147483648;
pub const POWER_LEVEL_USER_NOTIFY_TEXT: u32 = 1;
pub const POWER_LEVEL_USER_NOTIFY_SOUND: u32 = 2;
pub const POWER_LEVEL_USER_NOTIFY_EXEC: u32 = 4;
pub const POWER_USER_NOTIFY_BUTTON: u32 = 8;
pub const POWER_USER_NOTIFY_SHUTDOWN: u32 = 16;
pub const POWER_USER_NOTIFY_FORCED_SHUTDOWN: u32 = 32;
pub const POWER_FORCE_TRIGGER_RESET: u32 = 2147483648;
pub const BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK: u32 = 7;
pub const BATTERY_DISCHARGE_FLAGS_ENABLE: u32 = 2147483648;
pub const DISCHARGE_POLICY_CRITICAL: u32 = 0;
pub const DISCHARGE_POLICY_LOW: u32 = 1;
pub const NUM_DISCHARGE_POLICIES: u32 = 4;
pub const PROCESSOR_IDLESTATE_POLICY_COUNT: u32 = 3;
pub const PO_THROTTLE_NONE: u32 = 0;
pub const PO_THROTTLE_CONSTANT: u32 = 1;
pub const PO_THROTTLE_DEGRADE: u32 = 2;
pub const PO_THROTTLE_ADAPTIVE: u32 = 3;
pub const PO_THROTTLE_MAXIMUM: u32 = 4;
pub const IMAGE_DOS_SIGNATURE: u32 = 23117;
pub const IMAGE_OS2_SIGNATURE: u32 = 17742;
pub const IMAGE_OS2_SIGNATURE_LE: u32 = 17740;
pub const IMAGE_VXD_SIGNATURE: u32 = 17740;
pub const IMAGE_NT_SIGNATURE: u32 = 17744;
pub const IMAGE_SIZEOF_FILE_HEADER: u32 = 20;
pub const IMAGE_FILE_RELOCS_STRIPPED: u32 = 1;
pub const IMAGE_FILE_EXECUTABLE_IMAGE: u32 = 2;
pub const IMAGE_FILE_LINE_NUMS_STRIPPED: u32 = 4;
pub const IMAGE_FILE_LOCAL_SYMS_STRIPPED: u32 = 8;
pub const IMAGE_FILE_AGGRESIVE_WS_TRIM: u32 = 16;
pub const IMAGE_FILE_LARGE_ADDRESS_AWARE: u32 = 32;
pub const IMAGE_FILE_BYTES_REVERSED_LO: u32 = 128;
pub const IMAGE_FILE_32BIT_MACHINE: u32 = 256;
pub const IMAGE_FILE_DEBUG_STRIPPED: u32 = 512;
pub const IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP: u32 = 1024;
pub const IMAGE_FILE_NET_RUN_FROM_SWAP: u32 = 2048;
pub const IMAGE_FILE_SYSTEM: u32 = 4096;
pub const IMAGE_FILE_DLL: u32 = 8192;
pub const IMAGE_FILE_UP_SYSTEM_ONLY: u32 = 16384;
pub const IMAGE_FILE_BYTES_REVERSED_HI: u32 = 32768;
pub const IMAGE_FILE_MACHINE_UNKNOWN: u32 = 0;
pub const IMAGE_FILE_MACHINE_I386: u32 = 332;
pub const IMAGE_FILE_MACHINE_R3000: u32 = 354;
pub const IMAGE_FILE_MACHINE_R4000: u32 = 358;
pub const IMAGE_FILE_MACHINE_R10000: u32 = 360;
pub const IMAGE_FILE_MACHINE_WCEMIPSV2: u32 = 361;
pub const IMAGE_FILE_MACHINE_ALPHA: u32 = 388;
pub const IMAGE_FILE_MACHINE_SH3: u32 = 418;
pub const IMAGE_FILE_MACHINE_SH3DSP: u32 = 419;
pub const IMAGE_FILE_MACHINE_SH3E: u32 = 420;
pub const IMAGE_FILE_MACHINE_SH4: u32 = 422;
pub const IMAGE_FILE_MACHINE_SH5: u32 = 424;
pub const IMAGE_FILE_MACHINE_ARM: u32 = 448;
pub const IMAGE_FILE_MACHINE_ARMV7: u32 = 452;
pub const IMAGE_FILE_MACHINE_ARMNT: u32 = 452;
pub const IMAGE_FILE_MACHINE_ARM64: u32 = 43620;
pub const IMAGE_FILE_MACHINE_THUMB: u32 = 450;
pub const IMAGE_FILE_MACHINE_AM33: u32 = 467;
pub const IMAGE_FILE_MACHINE_POWERPC: u32 = 496;
pub const IMAGE_FILE_MACHINE_POWERPCFP: u32 = 497;
pub const IMAGE_FILE_MACHINE_IA64: u32 = 512;
pub const IMAGE_FILE_MACHINE_MIPS16: u32 = 614;
pub const IMAGE_FILE_MACHINE_ALPHA64: u32 = 644;
pub const IMAGE_FILE_MACHINE_MIPSFPU: u32 = 870;
pub const IMAGE_FILE_MACHINE_MIPSFPU16: u32 = 1126;
pub const IMAGE_FILE_MACHINE_AXP64: u32 = 644;
pub const IMAGE_FILE_MACHINE_TRICORE: u32 = 1312;
pub const IMAGE_FILE_MACHINE_CEF: u32 = 3311;
pub const IMAGE_FILE_MACHINE_EBC: u32 = 3772;
pub const IMAGE_FILE_MACHINE_AMD64: u32 = 34404;
pub const IMAGE_FILE_MACHINE_M32R: u32 = 36929;
pub const IMAGE_FILE_MACHINE_CEE: u32 = 49390;
pub const IMAGE_NUMBEROF_DIRECTORY_ENTRIES: u32 = 16;
pub const IMAGE_SIZEOF_ROM_OPTIONAL_HEADER: u32 = 56;
pub const IMAGE_SIZEOF_STD_OPTIONAL_HEADER: u32 = 28;
pub const IMAGE_SIZEOF_NT_OPTIONAL32_HEADER: u32 = 224;
pub const IMAGE_SIZEOF_NT_OPTIONAL64_HEADER: u32 = 240;
pub const IMAGE_NT_OPTIONAL_HDR32_MAGIC: u32 = 267;
pub const IMAGE_NT_OPTIONAL_HDR64_MAGIC: u32 = 523;
pub const IMAGE_ROM_OPTIONAL_HDR_MAGIC: u32 = 263;
pub const IMAGE_SIZEOF_NT_OPTIONAL_HEADER: u32 = 240;
pub const IMAGE_NT_OPTIONAL_HDR_MAGIC: u32 = 523;
pub const IMAGE_SUBSYSTEM_UNKNOWN: u32 = 0;
pub const IMAGE_SUBSYSTEM_NATIVE: u32 = 1;
pub const IMAGE_SUBSYSTEM_WINDOWS_GUI: u32 = 2;
pub const IMAGE_SUBSYSTEM_WINDOWS_CUI: u32 = 3;
pub const IMAGE_SUBSYSTEM_OS2_CUI: u32 = 5;
pub const IMAGE_SUBSYSTEM_POSIX_CUI: u32 = 7;
pub const IMAGE_SUBSYSTEM_NATIVE_WINDOWS: u32 = 8;
pub const IMAGE_SUBSYSTEM_WINDOWS_CE_GUI: u32 = 9;
pub const IMAGE_SUBSYSTEM_EFI_APPLICATION: u32 = 10;
pub const IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER: u32 = 11;
pub const IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER: u32 = 12;
pub const IMAGE_SUBSYSTEM_EFI_ROM: u32 = 13;
pub const IMAGE_SUBSYSTEM_XBOX: u32 = 14;
pub const IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION: u32 = 16;
pub const IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA: u32 = 32;
pub const IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE: u32 = 64;
pub const IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY: u32 = 128;
pub const IMAGE_DLLCHARACTERISTICS_NX_COMPAT: u32 = 256;
pub const IMAGE_DLLCHARACTERISTICS_NO_ISOLATION: u32 = 512;
pub const IMAGE_DLLCHARACTERISTICS_NO_SEH: u32 = 1024;
pub const IMAGE_DLLCHARACTERISTICS_NO_BIND: u32 = 2048;
pub const IMAGE_DLLCHARACTERISTICS_APPCONTAINER: u32 = 4096;
pub const IMAGE_DLLCHARACTERISTICS_WDM_DRIVER: u32 = 8192;
pub const IMAGE_DLLCHARACTERISTICS_GUARD_CF: u32 = 16384;
pub const IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE: u32 = 32768;
pub const IMAGE_DIRECTORY_ENTRY_EXPORT: u32 = 0;
pub const IMAGE_DIRECTORY_ENTRY_IMPORT: u32 = 1;
pub const IMAGE_DIRECTORY_ENTRY_RESOURCE: u32 = 2;
pub const IMAGE_DIRECTORY_ENTRY_EXCEPTION: u32 = 3;
pub const IMAGE_DIRECTORY_ENTRY_SECURITY: u32 = 4;
pub const IMAGE_DIRECTORY_ENTRY_BASERELOC: u32 = 5;
pub const IMAGE_DIRECTORY_ENTRY_DEBUG: u32 = 6;
pub const IMAGE_DIRECTORY_ENTRY_ARCHITECTURE: u32 = 7;
pub const IMAGE_DIRECTORY_ENTRY_GLOBALPTR: u32 = 8;
pub const IMAGE_DIRECTORY_ENTRY_TLS: u32 = 9;
pub const IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG: u32 = 10;
pub const IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT: u32 = 11;
pub const IMAGE_DIRECTORY_ENTRY_IAT: u32 = 12;
pub const IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT: u32 = 13;
pub const IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR: u32 = 14;
pub const IMAGE_SIZEOF_SHORT_NAME: u32 = 8;
pub const IMAGE_SIZEOF_SECTION_HEADER: u32 = 40;
pub const IMAGE_SCN_TYPE_NO_PAD: u32 = 8;
pub const IMAGE_SCN_CNT_CODE: u32 = 32;
pub const IMAGE_SCN_CNT_INITIALIZED_DATA: u32 = 64;
pub const IMAGE_SCN_CNT_UNINITIALIZED_DATA: u32 = 128;
pub const IMAGE_SCN_LNK_OTHER: u32 = 256;
pub const IMAGE_SCN_LNK_INFO: u32 = 512;
pub const IMAGE_SCN_LNK_REMOVE: u32 = 2048;
pub const IMAGE_SCN_LNK_COMDAT: u32 = 4096;
pub const IMAGE_SCN_NO_DEFER_SPEC_EXC: u32 = 16384;
pub const IMAGE_SCN_GPREL: u32 = 32768;
pub const IMAGE_SCN_MEM_FARDATA: u32 = 32768;
pub const IMAGE_SCN_MEM_PURGEABLE: u32 = 131072;
pub const IMAGE_SCN_MEM_16BIT: u32 = 131072;
pub const IMAGE_SCN_MEM_LOCKED: u32 = 262144;
pub const IMAGE_SCN_MEM_PRELOAD: u32 = 524288;
pub const IMAGE_SCN_ALIGN_1BYTES: u32 = 1048576;
pub const IMAGE_SCN_ALIGN_2BYTES: u32 = 2097152;
pub const IMAGE_SCN_ALIGN_4BYTES: u32 = 3145728;
pub const IMAGE_SCN_ALIGN_8BYTES: u32 = 4194304;
pub const IMAGE_SCN_ALIGN_16BYTES: u32 = 5242880;
pub const IMAGE_SCN_ALIGN_32BYTES: u32 = 6291456;
pub const IMAGE_SCN_ALIGN_64BYTES: u32 = 7340032;
pub const IMAGE_SCN_ALIGN_128BYTES: u32 = 8388608;
pub const IMAGE_SCN_ALIGN_256BYTES: u32 = 9437184;
pub const IMAGE_SCN_ALIGN_512BYTES: u32 = 10485760;
pub const IMAGE_SCN_ALIGN_1024BYTES: u32 = 11534336;
pub const IMAGE_SCN_ALIGN_2048BYTES: u32 = 12582912;
pub const IMAGE_SCN_ALIGN_4096BYTES: u32 = 13631488;
pub const IMAGE_SCN_ALIGN_8192BYTES: u32 = 14680064;
pub const IMAGE_SCN_ALIGN_MASK: u32 = 15728640;
pub const IMAGE_SCN_LNK_NRELOC_OVFL: u32 = 16777216;
pub const IMAGE_SCN_MEM_DISCARDABLE: u32 = 33554432;
pub const IMAGE_SCN_MEM_NOT_CACHED: u32 = 67108864;
pub const IMAGE_SCN_MEM_NOT_PAGED: u32 = 134217728;
pub const IMAGE_SCN_MEM_SHARED: u32 = 268435456;
pub const IMAGE_SCN_MEM_EXECUTE: u32 = 536870912;
pub const IMAGE_SCN_MEM_READ: u32 = 1073741824;
pub const IMAGE_SCN_MEM_WRITE: u32 = 2147483648;
pub const IMAGE_SCN_SCALE_INDEX: u32 = 1;
pub const IMAGE_SIZEOF_SYMBOL: u32 = 18;
pub const IMAGE_SYM_SECTION_MAX: u32 = 65279;
pub const IMAGE_SYM_SECTION_MAX_EX: u32 = 2147483647;
pub const IMAGE_SYM_TYPE_NULL: u32 = 0;
pub const IMAGE_SYM_TYPE_VOID: u32 = 1;
pub const IMAGE_SYM_TYPE_CHAR: u32 = 2;
pub const IMAGE_SYM_TYPE_SHORT: u32 = 3;
pub const IMAGE_SYM_TYPE_INT: u32 = 4;
pub const IMAGE_SYM_TYPE_LONG: u32 = 5;
pub const IMAGE_SYM_TYPE_FLOAT: u32 = 6;
pub const IMAGE_SYM_TYPE_DOUBLE: u32 = 7;
pub const IMAGE_SYM_TYPE_STRUCT: u32 = 8;
pub const IMAGE_SYM_TYPE_UNION: u32 = 9;
pub const IMAGE_SYM_TYPE_ENUM: u32 = 10;
pub const IMAGE_SYM_TYPE_MOE: u32 = 11;
pub const IMAGE_SYM_TYPE_BYTE: u32 = 12;
pub const IMAGE_SYM_TYPE_WORD: u32 = 13;
pub const IMAGE_SYM_TYPE_UINT: u32 = 14;
pub const IMAGE_SYM_TYPE_DWORD: u32 = 15;
pub const IMAGE_SYM_TYPE_PCODE: u32 = 32768;
pub const IMAGE_SYM_DTYPE_NULL: u32 = 0;
pub const IMAGE_SYM_DTYPE_POINTER: u32 = 1;
pub const IMAGE_SYM_DTYPE_FUNCTION: u32 = 2;
pub const IMAGE_SYM_DTYPE_ARRAY: u32 = 3;
pub const IMAGE_SYM_CLASS_NULL: u32 = 0;
pub const IMAGE_SYM_CLASS_AUTOMATIC: u32 = 1;
pub const IMAGE_SYM_CLASS_EXTERNAL: u32 = 2;
pub const IMAGE_SYM_CLASS_STATIC: u32 = 3;
pub const IMAGE_SYM_CLASS_REGISTER: u32 = 4;
pub const IMAGE_SYM_CLASS_EXTERNAL_DEF: u32 = 5;
pub const IMAGE_SYM_CLASS_LABEL: u32 = 6;
pub const IMAGE_SYM_CLASS_UNDEFINED_LABEL: u32 = 7;
pub const IMAGE_SYM_CLASS_MEMBER_OF_STRUCT: u32 = 8;
pub const IMAGE_SYM_CLASS_ARGUMENT: u32 = 9;
pub const IMAGE_SYM_CLASS_STRUCT_TAG: u32 = 10;
pub const IMAGE_SYM_CLASS_MEMBER_OF_UNION: u32 = 11;
pub const IMAGE_SYM_CLASS_UNION_TAG: u32 = 12;
pub const IMAGE_SYM_CLASS_TYPE_DEFINITION: u32 = 13;
pub const IMAGE_SYM_CLASS_UNDEFINED_STATIC: u32 = 14;
pub const IMAGE_SYM_CLASS_ENUM_TAG: u32 = 15;
pub const IMAGE_SYM_CLASS_MEMBER_OF_ENUM: u32 = 16;
pub const IMAGE_SYM_CLASS_REGISTER_PARAM: u32 = 17;
pub const IMAGE_SYM_CLASS_BIT_FIELD: u32 = 18;
pub const IMAGE_SYM_CLASS_FAR_EXTERNAL: u32 = 68;
pub const IMAGE_SYM_CLASS_BLOCK: u32 = 100;
pub const IMAGE_SYM_CLASS_FUNCTION: u32 = 101;
pub const IMAGE_SYM_CLASS_END_OF_STRUCT: u32 = 102;
pub const IMAGE_SYM_CLASS_FILE: u32 = 103;
pub const IMAGE_SYM_CLASS_SECTION: u32 = 104;
pub const IMAGE_SYM_CLASS_WEAK_EXTERNAL: u32 = 105;
pub const IMAGE_SYM_CLASS_CLR_TOKEN: u32 = 107;
pub const N_BTMASK: u32 = 15;
pub const N_TMASK: u32 = 48;
pub const N_TMASK1: u32 = 192;
pub const N_TMASK2: u32 = 240;
pub const N_BTSHFT: u32 = 4;
pub const N_TSHIFT: u32 = 2;
pub const IMAGE_SIZEOF_AUX_SYMBOL: u32 = 18;
pub const IMAGE_COMDAT_SELECT_NODUPLICATES: u32 = 1;
pub const IMAGE_COMDAT_SELECT_ANY: u32 = 2;
pub const IMAGE_COMDAT_SELECT_SAME_SIZE: u32 = 3;
pub const IMAGE_COMDAT_SELECT_EXACT_MATCH: u32 = 4;
pub const IMAGE_COMDAT_SELECT_ASSOCIATIVE: u32 = 5;
pub const IMAGE_COMDAT_SELECT_LARGEST: u32 = 6;
pub const IMAGE_COMDAT_SELECT_NEWEST: u32 = 7;
pub const IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY: u32 = 1;
pub const IMAGE_WEAK_EXTERN_SEARCH_LIBRARY: u32 = 2;
pub const IMAGE_WEAK_EXTERN_SEARCH_ALIAS: u32 = 3;
pub const IMAGE_SIZEOF_RELOCATION: u32 = 10;
pub const IMAGE_REL_I386_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_I386_DIR16: u32 = 1;
pub const IMAGE_REL_I386_REL16: u32 = 2;
pub const IMAGE_REL_I386_DIR32: u32 = 6;
pub const IMAGE_REL_I386_DIR32NB: u32 = 7;
pub const IMAGE_REL_I386_SEG12: u32 = 9;
pub const IMAGE_REL_I386_SECTION: u32 = 10;
pub const IMAGE_REL_I386_SECREL: u32 = 11;
pub const IMAGE_REL_I386_TOKEN: u32 = 12;
pub const IMAGE_REL_I386_SECREL7: u32 = 13;
pub const IMAGE_REL_I386_REL32: u32 = 20;
pub const IMAGE_REL_MIPS_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_MIPS_REFHALF: u32 = 1;
pub const IMAGE_REL_MIPS_REFWORD: u32 = 2;
pub const IMAGE_REL_MIPS_JMPADDR: u32 = 3;
pub const IMAGE_REL_MIPS_REFHI: u32 = 4;
pub const IMAGE_REL_MIPS_REFLO: u32 = 5;
pub const IMAGE_REL_MIPS_GPREL: u32 = 6;
pub const IMAGE_REL_MIPS_LITERAL: u32 = 7;
pub const IMAGE_REL_MIPS_SECTION: u32 = 10;
pub const IMAGE_REL_MIPS_SECREL: u32 = 11;
pub const IMAGE_REL_MIPS_SECRELLO: u32 = 12;
pub const IMAGE_REL_MIPS_SECRELHI: u32 = 13;
pub const IMAGE_REL_MIPS_TOKEN: u32 = 14;
pub const IMAGE_REL_MIPS_JMPADDR16: u32 = 16;
pub const IMAGE_REL_MIPS_REFWORDNB: u32 = 34;
pub const IMAGE_REL_MIPS_PAIR: u32 = 37;
pub const IMAGE_REL_ALPHA_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_ALPHA_REFLONG: u32 = 1;
pub const IMAGE_REL_ALPHA_REFQUAD: u32 = 2;
pub const IMAGE_REL_ALPHA_GPREL32: u32 = 3;
pub const IMAGE_REL_ALPHA_LITERAL: u32 = 4;
pub const IMAGE_REL_ALPHA_LITUSE: u32 = 5;
pub const IMAGE_REL_ALPHA_GPDISP: u32 = 6;
pub const IMAGE_REL_ALPHA_BRADDR: u32 = 7;
pub const IMAGE_REL_ALPHA_HINT: u32 = 8;
pub const IMAGE_REL_ALPHA_INLINE_REFLONG: u32 = 9;
pub const IMAGE_REL_ALPHA_REFHI: u32 = 10;
pub const IMAGE_REL_ALPHA_REFLO: u32 = 11;
pub const IMAGE_REL_ALPHA_PAIR: u32 = 12;
pub const IMAGE_REL_ALPHA_MATCH: u32 = 13;
pub const IMAGE_REL_ALPHA_SECTION: u32 = 14;
pub const IMAGE_REL_ALPHA_SECREL: u32 = 15;
pub const IMAGE_REL_ALPHA_REFLONGNB: u32 = 16;
pub const IMAGE_REL_ALPHA_SECRELLO: u32 = 17;
pub const IMAGE_REL_ALPHA_SECRELHI: u32 = 18;
pub const IMAGE_REL_ALPHA_REFQ3: u32 = 19;
pub const IMAGE_REL_ALPHA_REFQ2: u32 = 20;
pub const IMAGE_REL_ALPHA_REFQ1: u32 = 21;
pub const IMAGE_REL_ALPHA_GPRELLO: u32 = 22;
pub const IMAGE_REL_ALPHA_GPRELHI: u32 = 23;
pub const IMAGE_REL_PPC_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_PPC_ADDR64: u32 = 1;
pub const IMAGE_REL_PPC_ADDR32: u32 = 2;
pub const IMAGE_REL_PPC_ADDR24: u32 = 3;
pub const IMAGE_REL_PPC_ADDR16: u32 = 4;
pub const IMAGE_REL_PPC_ADDR14: u32 = 5;
pub const IMAGE_REL_PPC_REL24: u32 = 6;
pub const IMAGE_REL_PPC_REL14: u32 = 7;
pub const IMAGE_REL_PPC_TOCREL16: u32 = 8;
pub const IMAGE_REL_PPC_TOCREL14: u32 = 9;
pub const IMAGE_REL_PPC_ADDR32NB: u32 = 10;
pub const IMAGE_REL_PPC_SECREL: u32 = 11;
pub const IMAGE_REL_PPC_SECTION: u32 = 12;
pub const IMAGE_REL_PPC_IFGLUE: u32 = 13;
pub const IMAGE_REL_PPC_IMGLUE: u32 = 14;
pub const IMAGE_REL_PPC_SECREL16: u32 = 15;
pub const IMAGE_REL_PPC_REFHI: u32 = 16;
pub const IMAGE_REL_PPC_REFLO: u32 = 17;
pub const IMAGE_REL_PPC_PAIR: u32 = 18;
pub const IMAGE_REL_PPC_SECRELLO: u32 = 19;
pub const IMAGE_REL_PPC_SECRELHI: u32 = 20;
pub const IMAGE_REL_PPC_GPREL: u32 = 21;
pub const IMAGE_REL_PPC_TOKEN: u32 = 22;
pub const IMAGE_REL_PPC_TYPEMASK: u32 = 255;
pub const IMAGE_REL_PPC_NEG: u32 = 256;
pub const IMAGE_REL_PPC_BRTAKEN: u32 = 512;
pub const IMAGE_REL_PPC_BRNTAKEN: u32 = 1024;
pub const IMAGE_REL_PPC_TOCDEFN: u32 = 2048;
pub const IMAGE_REL_SH3_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_SH3_DIRECT16: u32 = 1;
pub const IMAGE_REL_SH3_DIRECT32: u32 = 2;
pub const IMAGE_REL_SH3_DIRECT8: u32 = 3;
pub const IMAGE_REL_SH3_DIRECT8_WORD: u32 = 4;
pub const IMAGE_REL_SH3_DIRECT8_LONG: u32 = 5;
pub const IMAGE_REL_SH3_DIRECT4: u32 = 6;
pub const IMAGE_REL_SH3_DIRECT4_WORD: u32 = 7;
pub const IMAGE_REL_SH3_DIRECT4_LONG: u32 = 8;
pub const IMAGE_REL_SH3_PCREL8_WORD: u32 = 9;
pub const IMAGE_REL_SH3_PCREL8_LONG: u32 = 10;
pub const IMAGE_REL_SH3_PCREL12_WORD: u32 = 11;
pub const IMAGE_REL_SH3_STARTOF_SECTION: u32 = 12;
pub const IMAGE_REL_SH3_SIZEOF_SECTION: u32 = 13;
pub const IMAGE_REL_SH3_SECTION: u32 = 14;
pub const IMAGE_REL_SH3_SECREL: u32 = 15;
pub const IMAGE_REL_SH3_DIRECT32_NB: u32 = 16;
pub const IMAGE_REL_SH3_GPREL4_LONG: u32 = 17;
pub const IMAGE_REL_SH3_TOKEN: u32 = 18;
pub const IMAGE_REL_SHM_PCRELPT: u32 = 19;
pub const IMAGE_REL_SHM_REFLO: u32 = 20;
pub const IMAGE_REL_SHM_REFHALF: u32 = 21;
pub const IMAGE_REL_SHM_RELLO: u32 = 22;
pub const IMAGE_REL_SHM_RELHALF: u32 = 23;
pub const IMAGE_REL_SHM_PAIR: u32 = 24;
pub const IMAGE_REL_SH_NOMODE: u32 = 32768;
pub const IMAGE_REL_ARM_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_ARM_ADDR32: u32 = 1;
pub const IMAGE_REL_ARM_ADDR32NB: u32 = 2;
pub const IMAGE_REL_ARM_BRANCH24: u32 = 3;
pub const IMAGE_REL_ARM_BRANCH11: u32 = 4;
pub const IMAGE_REL_ARM_TOKEN: u32 = 5;
pub const IMAGE_REL_ARM_GPREL12: u32 = 6;
pub const IMAGE_REL_ARM_GPREL7: u32 = 7;
pub const IMAGE_REL_ARM_BLX24: u32 = 8;
pub const IMAGE_REL_ARM_BLX11: u32 = 9;
pub const IMAGE_REL_ARM_SECTION: u32 = 14;
pub const IMAGE_REL_ARM_SECREL: u32 = 15;
pub const IMAGE_REL_ARM_MOV32A: u32 = 16;
pub const IMAGE_REL_ARM_MOV32: u32 = 16;
pub const IMAGE_REL_ARM_MOV32T: u32 = 17;
pub const IMAGE_REL_THUMB_MOV32: u32 = 17;
pub const IMAGE_REL_ARM_BRANCH20T: u32 = 18;
pub const IMAGE_REL_THUMB_BRANCH20: u32 = 18;
pub const IMAGE_REL_ARM_BRANCH24T: u32 = 20;
pub const IMAGE_REL_THUMB_BRANCH24: u32 = 20;
pub const IMAGE_REL_ARM_BLX23T: u32 = 21;
pub const IMAGE_REL_THUMB_BLX23: u32 = 21;
pub const IMAGE_REL_AM_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_AM_ADDR32: u32 = 1;
pub const IMAGE_REL_AM_ADDR32NB: u32 = 2;
pub const IMAGE_REL_AM_CALL32: u32 = 3;
pub const IMAGE_REL_AM_FUNCINFO: u32 = 4;
pub const IMAGE_REL_AM_REL32_1: u32 = 5;
pub const IMAGE_REL_AM_REL32_2: u32 = 6;
pub const IMAGE_REL_AM_SECREL: u32 = 7;
pub const IMAGE_REL_AM_SECTION: u32 = 8;
pub const IMAGE_REL_AM_TOKEN: u32 = 9;
pub const IMAGE_REL_AMD64_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_AMD64_ADDR64: u32 = 1;
pub const IMAGE_REL_AMD64_ADDR32: u32 = 2;
pub const IMAGE_REL_AMD64_ADDR32NB: u32 = 3;
pub const IMAGE_REL_AMD64_REL32: u32 = 4;
pub const IMAGE_REL_AMD64_REL32_1: u32 = 5;
pub const IMAGE_REL_AMD64_REL32_2: u32 = 6;
pub const IMAGE_REL_AMD64_REL32_3: u32 = 7;
pub const IMAGE_REL_AMD64_REL32_4: u32 = 8;
pub const IMAGE_REL_AMD64_REL32_5: u32 = 9;
pub const IMAGE_REL_AMD64_SECTION: u32 = 10;
pub const IMAGE_REL_AMD64_SECREL: u32 = 11;
pub const IMAGE_REL_AMD64_SECREL7: u32 = 12;
pub const IMAGE_REL_AMD64_TOKEN: u32 = 13;
pub const IMAGE_REL_AMD64_SREL32: u32 = 14;
pub const IMAGE_REL_AMD64_PAIR: u32 = 15;
pub const IMAGE_REL_AMD64_SSPAN32: u32 = 16;
pub const IMAGE_REL_IA64_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_IA64_IMM14: u32 = 1;
pub const IMAGE_REL_IA64_IMM22: u32 = 2;
pub const IMAGE_REL_IA64_IMM64: u32 = 3;
pub const IMAGE_REL_IA64_DIR32: u32 = 4;
pub const IMAGE_REL_IA64_DIR64: u32 = 5;
pub const IMAGE_REL_IA64_PCREL21B: u32 = 6;
pub const IMAGE_REL_IA64_PCREL21M: u32 = 7;
pub const IMAGE_REL_IA64_PCREL21F: u32 = 8;
pub const IMAGE_REL_IA64_GPREL22: u32 = 9;
pub const IMAGE_REL_IA64_LTOFF22: u32 = 10;
pub const IMAGE_REL_IA64_SECTION: u32 = 11;
pub const IMAGE_REL_IA64_SECREL22: u32 = 12;
pub const IMAGE_REL_IA64_SECREL64I: u32 = 13;
pub const IMAGE_REL_IA64_SECREL32: u32 = 14;
pub const IMAGE_REL_IA64_DIR32NB: u32 = 16;
pub const IMAGE_REL_IA64_SREL14: u32 = 17;
pub const IMAGE_REL_IA64_SREL22: u32 = 18;
pub const IMAGE_REL_IA64_SREL32: u32 = 19;
pub const IMAGE_REL_IA64_UREL32: u32 = 20;
pub const IMAGE_REL_IA64_PCREL60X: u32 = 21;
pub const IMAGE_REL_IA64_PCREL60B: u32 = 22;
pub const IMAGE_REL_IA64_PCREL60F: u32 = 23;
pub const IMAGE_REL_IA64_PCREL60I: u32 = 24;
pub const IMAGE_REL_IA64_PCREL60M: u32 = 25;
pub const IMAGE_REL_IA64_IMMGPREL64: u32 = 26;
pub const IMAGE_REL_IA64_TOKEN: u32 = 27;
pub const IMAGE_REL_IA64_GPREL32: u32 = 28;
pub const IMAGE_REL_IA64_ADDEND: u32 = 31;
pub const IMAGE_REL_CEF_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_CEF_ADDR32: u32 = 1;
pub const IMAGE_REL_CEF_ADDR64: u32 = 2;
pub const IMAGE_REL_CEF_ADDR32NB: u32 = 3;
pub const IMAGE_REL_CEF_SECTION: u32 = 4;
pub const IMAGE_REL_CEF_SECREL: u32 = 5;
pub const IMAGE_REL_CEF_TOKEN: u32 = 6;
pub const IMAGE_REL_CEE_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_CEE_ADDR32: u32 = 1;
pub const IMAGE_REL_CEE_ADDR64: u32 = 2;
pub const IMAGE_REL_CEE_ADDR32NB: u32 = 3;
pub const IMAGE_REL_CEE_SECTION: u32 = 4;
pub const IMAGE_REL_CEE_SECREL: u32 = 5;
pub const IMAGE_REL_CEE_TOKEN: u32 = 6;
pub const IMAGE_REL_M32R_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_M32R_ADDR32: u32 = 1;
pub const IMAGE_REL_M32R_ADDR32NB: u32 = 2;
pub const IMAGE_REL_M32R_ADDR24: u32 = 3;
pub const IMAGE_REL_M32R_GPREL16: u32 = 4;
pub const IMAGE_REL_M32R_PCREL24: u32 = 5;
pub const IMAGE_REL_M32R_PCREL16: u32 = 6;
pub const IMAGE_REL_M32R_PCREL8: u32 = 7;
pub const IMAGE_REL_M32R_REFHALF: u32 = 8;
pub const IMAGE_REL_M32R_REFHI: u32 = 9;
pub const IMAGE_REL_M32R_REFLO: u32 = 10;
pub const IMAGE_REL_M32R_PAIR: u32 = 11;
pub const IMAGE_REL_M32R_SECTION: u32 = 12;
pub const IMAGE_REL_M32R_SECREL32: u32 = 13;
pub const IMAGE_REL_M32R_TOKEN: u32 = 14;
pub const IMAGE_REL_EBC_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_EBC_ADDR32NB: u32 = 1;
pub const IMAGE_REL_EBC_REL32: u32 = 2;
pub const IMAGE_REL_EBC_SECTION: u32 = 3;
pub const IMAGE_REL_EBC_SECREL: u32 = 4;
pub const EMARCH_ENC_I17_IMM7B_INST_WORD_X: u32 = 3;
pub const EMARCH_ENC_I17_IMM7B_SIZE_X: u32 = 7;
pub const EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X: u32 = 4;
pub const EMARCH_ENC_I17_IMM7B_VAL_POS_X: u32 = 0;
pub const EMARCH_ENC_I17_IMM9D_INST_WORD_X: u32 = 3;
pub const EMARCH_ENC_I17_IMM9D_SIZE_X: u32 = 9;
pub const EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X: u32 = 18;
pub const EMARCH_ENC_I17_IMM9D_VAL_POS_X: u32 = 7;
pub const EMARCH_ENC_I17_IMM5C_INST_WORD_X: u32 = 3;
pub const EMARCH_ENC_I17_IMM5C_SIZE_X: u32 = 5;
pub const EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X: u32 = 13;
pub const EMARCH_ENC_I17_IMM5C_VAL_POS_X: u32 = 16;
pub const EMARCH_ENC_I17_IC_INST_WORD_X: u32 = 3;
pub const EMARCH_ENC_I17_IC_SIZE_X: u32 = 1;
pub const EMARCH_ENC_I17_IC_INST_WORD_POS_X: u32 = 12;
pub const EMARCH_ENC_I17_IC_VAL_POS_X: u32 = 21;
pub const EMARCH_ENC_I17_IMM41a_INST_WORD_X: u32 = 1;
pub const EMARCH_ENC_I17_IMM41a_SIZE_X: u32 = 10;
pub const EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X: u32 = 14;
pub const EMARCH_ENC_I17_IMM41a_VAL_POS_X: u32 = 22;
pub const EMARCH_ENC_I17_IMM41b_INST_WORD_X: u32 = 1;
pub const EMARCH_ENC_I17_IMM41b_SIZE_X: u32 = 8;
pub const EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X: u32 = 24;
pub const EMARCH_ENC_I17_IMM41b_VAL_POS_X: u32 = 32;
pub const EMARCH_ENC_I17_IMM41c_INST_WORD_X: u32 = 2;
pub const EMARCH_ENC_I17_IMM41c_SIZE_X: u32 = 23;
pub const EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X: u32 = 0;
pub const EMARCH_ENC_I17_IMM41c_VAL_POS_X: u32 = 40;
pub const EMARCH_ENC_I17_SIGN_INST_WORD_X: u32 = 3;
pub const EMARCH_ENC_I17_SIGN_SIZE_X: u32 = 1;
pub const EMARCH_ENC_I17_SIGN_INST_WORD_POS_X: u32 = 27;
pub const EMARCH_ENC_I17_SIGN_VAL_POS_X: u32 = 63;
pub const X3_OPCODE_INST_WORD_X: u32 = 3;
pub const X3_OPCODE_SIZE_X: u32 = 4;
pub const X3_OPCODE_INST_WORD_POS_X: u32 = 28;
pub const X3_OPCODE_SIGN_VAL_POS_X: u32 = 0;
pub const X3_I_INST_WORD_X: u32 = 3;
pub const X3_I_SIZE_X: u32 = 1;
pub const X3_I_INST_WORD_POS_X: u32 = 27;
pub const X3_I_SIGN_VAL_POS_X: u32 = 59;
pub const X3_D_WH_INST_WORD_X: u32 = 3;
pub const X3_D_WH_SIZE_X: u32 = 3;
pub const X3_D_WH_INST_WORD_POS_X: u32 = 24;
pub const X3_D_WH_SIGN_VAL_POS_X: u32 = 0;
pub const X3_IMM20_INST_WORD_X: u32 = 3;
pub const X3_IMM20_SIZE_X: u32 = 20;
pub const X3_IMM20_INST_WORD_POS_X: u32 = 4;
pub const X3_IMM20_SIGN_VAL_POS_X: u32 = 0;
pub const X3_IMM39_1_INST_WORD_X: u32 = 2;
pub const X3_IMM39_1_SIZE_X: u32 = 23;
pub const X3_IMM39_1_INST_WORD_POS_X: u32 = 0;
pub const X3_IMM39_1_SIGN_VAL_POS_X: u32 = 36;
pub const X3_IMM39_2_INST_WORD_X: u32 = 1;
pub const X3_IMM39_2_SIZE_X: u32 = 16;
pub const X3_IMM39_2_INST_WORD_POS_X: u32 = 16;
pub const X3_IMM39_2_SIGN_VAL_POS_X: u32 = 20;
pub const X3_P_INST_WORD_X: u32 = 3;
pub const X3_P_SIZE_X: u32 = 4;
pub const X3_P_INST_WORD_POS_X: u32 = 0;
pub const X3_P_SIGN_VAL_POS_X: u32 = 0;
pub const X3_TMPLT_INST_WORD_X: u32 = 0;
pub const X3_TMPLT_SIZE_X: u32 = 4;
pub const X3_TMPLT_INST_WORD_POS_X: u32 = 0;
pub const X3_TMPLT_SIGN_VAL_POS_X: u32 = 0;
pub const X3_BTYPE_QP_INST_WORD_X: u32 = 2;
pub const X3_BTYPE_QP_SIZE_X: u32 = 9;
pub const X3_BTYPE_QP_INST_WORD_POS_X: u32 = 23;
pub const X3_BTYPE_QP_INST_VAL_POS_X: u32 = 0;
pub const X3_EMPTY_INST_WORD_X: u32 = 1;
pub const X3_EMPTY_SIZE_X: u32 = 2;
pub const X3_EMPTY_INST_WORD_POS_X: u32 = 14;
pub const X3_EMPTY_INST_VAL_POS_X: u32 = 0;
pub const IMAGE_SIZEOF_LINENUMBER: u32 = 6;
pub const IMAGE_SIZEOF_BASE_RELOCATION: u32 = 8;
pub const IMAGE_REL_BASED_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_BASED_HIGH: u32 = 1;
pub const IMAGE_REL_BASED_LOW: u32 = 2;
pub const IMAGE_REL_BASED_HIGHLOW: u32 = 3;
pub const IMAGE_REL_BASED_HIGHADJ: u32 = 4;
pub const IMAGE_REL_BASED_MIPS_JMPADDR: u32 = 5;
pub const IMAGE_REL_BASED_ARM_MOV32: u32 = 5;
pub const IMAGE_REL_BASED_THUMB_MOV32: u32 = 7;
pub const IMAGE_REL_BASED_MIPS_JMPADDR16: u32 = 9;
pub const IMAGE_REL_BASED_IA64_IMM64: u32 = 9;
pub const IMAGE_REL_BASED_DIR64: u32 = 10;
pub const IMAGE_ARCHIVE_START_SIZE: u32 = 8;
pub const IMAGE_ARCHIVE_START: &[u8; 9] = b"!<arch>\n\0";
pub const IMAGE_ARCHIVE_END: &[u8; 3] = b"`\n\0";
pub const IMAGE_ARCHIVE_PAD: &[u8; 2] = b"\n\0";
pub const IMAGE_ARCHIVE_LINKER_MEMBER: &[u8; 17] = b"/               \0";
pub const IMAGE_ARCHIVE_LONGNAMES_MEMBER: &[u8; 17] = b"//              \0";
pub const IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR: u32 = 60;
pub const IMAGE_ORDINAL_FLAG64: i64 = -9223372036854775808;
pub const IMAGE_ORDINAL_FLAG32: u32 = 2147483648;
pub const IMAGE_ORDINAL_FLAG: i64 = -9223372036854775808;
pub const IMAGE_RESOURCE_NAME_IS_STRING: u32 = 2147483648;
pub const IMAGE_RESOURCE_DATA_IS_DIRECTORY: u32 = 2147483648;
pub const IMAGE_DEBUG_TYPE_UNKNOWN: u32 = 0;
pub const IMAGE_DEBUG_TYPE_COFF: u32 = 1;
pub const IMAGE_DEBUG_TYPE_CODEVIEW: u32 = 2;
pub const IMAGE_DEBUG_TYPE_FPO: u32 = 3;
pub const IMAGE_DEBUG_TYPE_MISC: u32 = 4;
pub const IMAGE_DEBUG_TYPE_EXCEPTION: u32 = 5;
pub const IMAGE_DEBUG_TYPE_FIXUP: u32 = 6;
pub const IMAGE_DEBUG_TYPE_OMAP_TO_SRC: u32 = 7;
pub const IMAGE_DEBUG_TYPE_OMAP_FROM_SRC: u32 = 8;
pub const IMAGE_DEBUG_TYPE_BORLAND: u32 = 9;
pub const IMAGE_DEBUG_TYPE_RESERVED10: u32 = 10;
pub const IMAGE_DEBUG_TYPE_CLSID: u32 = 11;
pub const FRAME_FPO: u32 = 0;
pub const FRAME_TRAP: u32 = 1;
pub const FRAME_TSS: u32 = 2;
pub const FRAME_NONFPO: u32 = 3;
pub const SIZEOF_RFPO_DATA: u32 = 16;
pub const IMAGE_DEBUG_MISC_EXENAME: u32 = 1;
pub const IMAGE_SEPARATE_DEBUG_SIGNATURE: u32 = 18756;
pub const NON_PAGED_DEBUG_SIGNATURE: u32 = 18766;
pub const IMAGE_SEPARATE_DEBUG_FLAGS_MASK: u32 = 32768;
pub const IMAGE_SEPARATE_DEBUG_MISMATCH: u32 = 32768;
pub const IMPORT_OBJECT_HDR_SIG2: u32 = 65535;
pub const _RTL_RUN_ONCE_DEF: u32 = 1;
pub const RTL_RUN_ONCE_CTX_RESERVED_BITS: u32 = 2;
pub const FAST_FAIL_LEGACY_GS_VIOLATION: u32 = 0;
pub const FAST_FAIL_VTGUARD_CHECK_FAILURE: u32 = 1;
pub const FAST_FAIL_STACK_COOKIE_CHECK_FAILURE: u32 = 2;
pub const FAST_FAIL_CORRUPT_LIST_ENTRY: u32 = 3;
pub const FAST_FAIL_INCORRECT_STACK: u32 = 4;
pub const FAST_FAIL_INVALID_ARG: u32 = 5;
pub const FAST_FAIL_GS_COOKIE_INIT: u32 = 6;
pub const FAST_FAIL_FATAL_APP_EXIT: u32 = 7;
pub const FAST_FAIL_RANGE_CHECK_FAILURE: u32 = 8;
pub const FAST_FAIL_UNSAFE_REGISTRY_ACCESS: u32 = 9;
pub const FAST_FAIL_INVALID_FAST_FAIL_CODE: u32 = 4294967295;
pub const HEAP_NO_SERIALIZE: u32 = 1;
pub const HEAP_GROWABLE: u32 = 2;
pub const HEAP_GENERATE_EXCEPTIONS: u32 = 4;
pub const HEAP_ZERO_MEMORY: u32 = 8;
pub const HEAP_REALLOC_IN_PLACE_ONLY: u32 = 16;
pub const HEAP_TAIL_CHECKING_ENABLED: u32 = 32;
pub const HEAP_FREE_CHECKING_ENABLED: u32 = 64;
pub const HEAP_DISABLE_COALESCE_ON_FREE: u32 = 128;
pub const HEAP_CREATE_ALIGN_16: u32 = 65536;
pub const HEAP_CREATE_ENABLE_TRACING: u32 = 131072;
pub const HEAP_CREATE_ENABLE_EXECUTE: u32 = 262144;
pub const HEAP_MAXIMUM_TAG: u32 = 4095;
pub const HEAP_PSEUDO_TAG_FLAG: u32 = 32768;
pub const HEAP_TAG_SHIFT: u32 = 18;
pub const IS_TEXT_UNICODE_ASCII16: u32 = 1;
pub const IS_TEXT_UNICODE_REVERSE_ASCII16: u32 = 16;
pub const IS_TEXT_UNICODE_STATISTICS: u32 = 2;
pub const IS_TEXT_UNICODE_REVERSE_STATISTICS: u32 = 32;
pub const IS_TEXT_UNICODE_CONTROLS: u32 = 4;
pub const IS_TEXT_UNICODE_REVERSE_CONTROLS: u32 = 64;
pub const IS_TEXT_UNICODE_SIGNATURE: u32 = 8;
pub const IS_TEXT_UNICODE_REVERSE_SIGNATURE: u32 = 128;
pub const IS_TEXT_UNICODE_ILLEGAL_CHARS: u32 = 256;
pub const IS_TEXT_UNICODE_ODD_LENGTH: u32 = 512;
pub const IS_TEXT_UNICODE_DBCS_LEADBYTE: u32 = 1024;
pub const IS_TEXT_UNICODE_NULL_BYTES: u32 = 4096;
pub const IS_TEXT_UNICODE_UNICODE_MASK: u32 = 15;
pub const IS_TEXT_UNICODE_REVERSE_MASK: u32 = 240;
pub const IS_TEXT_UNICODE_NOT_UNICODE_MASK: u32 = 3840;
pub const IS_TEXT_UNICODE_NOT_ASCII_MASK: u32 = 61440;
pub const COMPRESSION_FORMAT_NONE: u32 = 0;
pub const COMPRESSION_FORMAT_DEFAULT: u32 = 1;
pub const COMPRESSION_FORMAT_LZNT1: u32 = 2;
pub const COMPRESSION_FORMAT_XPRESS: u32 = 3;
pub const COMPRESSION_FORMAT_XPRESS_HUFF: u32 = 4;
pub const COMPRESSION_ENGINE_STANDARD: u32 = 0;
pub const COMPRESSION_ENGINE_MAXIMUM: u32 = 256;
pub const COMPRESSION_ENGINE_HIBER: u32 = 512;
pub const SEF_DACL_AUTO_INHERIT: u32 = 1;
pub const SEF_SACL_AUTO_INHERIT: u32 = 2;
pub const SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT: u32 = 4;
pub const SEF_AVOID_PRIVILEGE_CHECK: u32 = 8;
pub const SEF_AVOID_OWNER_CHECK: u32 = 16;
pub const SEF_DEFAULT_OWNER_FROM_PARENT: u32 = 32;
pub const SEF_DEFAULT_GROUP_FROM_PARENT: u32 = 64;
pub const SEF_MACL_NO_WRITE_UP: u32 = 256;
pub const SEF_MACL_NO_READ_UP: u32 = 512;
pub const SEF_MACL_NO_EXECUTE_UP: u32 = 1024;
pub const SEF_AVOID_OWNER_RESTRICTION: u32 = 4096;
pub const SEF_MACL_VALID_FLAGS: u32 = 1792;
pub const MESSAGE_RESOURCE_UNICODE: u32 = 1;
pub const VER_EQUAL: u32 = 1;
pub const VER_GREATER: u32 = 2;
pub const VER_GREATER_EQUAL: u32 = 3;
pub const VER_LESS: u32 = 4;
pub const VER_LESS_EQUAL: u32 = 5;
pub const VER_AND: u32 = 6;
pub const VER_OR: u32 = 7;
pub const VER_CONDITION_MASK: u32 = 7;
pub const VER_NUM_BITS_PER_CONDITION_MASK: u32 = 3;
pub const VER_MINORVERSION: u32 = 1;
pub const VER_MAJORVERSION: u32 = 2;
pub const VER_BUILDNUMBER: u32 = 4;
pub const VER_PLATFORMID: u32 = 8;
pub const VER_SERVICEPACKMINOR: u32 = 16;
pub const VER_SERVICEPACKMAJOR: u32 = 32;
pub const VER_SUITENAME: u32 = 64;
pub const VER_PRODUCT_TYPE: u32 = 128;
pub const VER_NT_WORKSTATION: u32 = 1;
pub const VER_NT_DOMAIN_CONTROLLER: u32 = 2;
pub const VER_NT_SERVER: u32 = 3;
pub const VER_PLATFORM_WIN32s: u32 = 0;
pub const VER_PLATFORM_WIN32_WINDOWS: u32 = 1;
pub const VER_PLATFORM_WIN32_NT: u32 = 2;
pub const RTL_UMS_VERSION: u32 = 256;
pub const VRL_PREDEFINED_CLASS_BEGIN: u32 = 1;
pub const VRL_CUSTOM_CLASS_BEGIN: u32 = 256;
pub const VRL_CLASS_CONSISTENCY: u32 = 1;
pub const VRL_ENABLE_KERNEL_BREAKS: u32 = 2147483648;
pub const RTL_CRITSECT_TYPE: u32 = 0;
pub const RTL_RESOURCE_TYPE: u32 = 1;
pub const RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO: u32 = 16777216;
pub const RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN: u32 = 33554432;
pub const RTL_CRITICAL_SECTION_FLAG_STATIC_INIT: u32 = 67108864;
pub const RTL_CRITICAL_SECTION_FLAG_RESOURCE_TYPE: u32 = 134217728;
pub const RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO: u32 = 268435456;
pub const RTL_CRITICAL_SECTION_ALL_FLAG_BITS: u32 = 4278190080;
pub const RTL_CRITICAL_SECTION_FLAG_RESERVED: u32 = 3758096384;
pub const RTL_CRITICAL_SECTION_DEBUG_FLAG_STATIC_INIT: u32 = 1;
pub const RTL_CONDITION_VARIABLE_LOCKMODE_SHARED: u32 = 1;
pub const WT_EXECUTEDEFAULT: u32 = 0;
pub const WT_EXECUTEINIOTHREAD: u32 = 1;
pub const WT_EXECUTEINUITHREAD: u32 = 2;
pub const WT_EXECUTEINWAITTHREAD: u32 = 4;
pub const WT_EXECUTEONLYONCE: u32 = 8;
pub const WT_EXECUTEINTIMERTHREAD: u32 = 32;
pub const WT_EXECUTELONGFUNCTION: u32 = 16;
pub const WT_EXECUTEINPERSISTENTIOTHREAD: u32 = 64;
pub const WT_EXECUTEINPERSISTENTTHREAD: u32 = 128;
pub const WT_TRANSFER_IMPERSONATION: u32 = 256;
pub const WT_EXECUTEDELETEWAIT: u32 = 8;
pub const WT_EXECUTEINLONGTHREAD: u32 = 16;
pub const MAX_SUPPORTED_OS_NUM: u32 = 4;
pub const ACTIVATION_CONTEXT_PATH_TYPE_NONE: u32 = 1;
pub const ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE: u32 = 2;
pub const ACTIVATION_CONTEXT_PATH_TYPE_URL: u32 = 3;
pub const ACTIVATION_CONTEXT_PATH_TYPE_ASSEMBLYREF: u32 = 4;
pub const INVALID_OS_COUNT: u32 = 65535;
pub const CREATE_BOUNDARY_DESCRIPTOR_ADD_APPCONTAINER_SID: u32 = 1;
pub const RTL_VRF_FLG_FULL_PAGE_HEAP: u32 = 1;
pub const RTL_VRF_FLG_RESERVED_DONOTUSE: u32 = 2;
pub const RTL_VRF_FLG_HANDLE_CHECKS: u32 = 4;
pub const RTL_VRF_FLG_STACK_CHECKS: u32 = 8;
pub const RTL_VRF_FLG_APPCOMPAT_CHECKS: u32 = 16;
pub const RTL_VRF_FLG_TLS_CHECKS: u32 = 32;
pub const RTL_VRF_FLG_DIRTY_STACKS: u32 = 64;
pub const RTL_VRF_FLG_RPC_CHECKS: u32 = 128;
pub const RTL_VRF_FLG_COM_CHECKS: u32 = 256;
pub const RTL_VRF_FLG_DANGEROUS_APIS: u32 = 512;
pub const RTL_VRF_FLG_RACE_CHECKS: u32 = 1024;
pub const RTL_VRF_FLG_DEADLOCK_CHECKS: u32 = 2048;
pub const RTL_VRF_FLG_FIRST_CHANCE_EXCEPTION_CHECKS: u32 = 4096;
pub const RTL_VRF_FLG_VIRTUAL_MEM_CHECKS: u32 = 8192;
pub const RTL_VRF_FLG_ENABLE_LOGGING: u32 = 16384;
pub const RTL_VRF_FLG_FAST_FILL_HEAP: u32 = 32768;
pub const RTL_VRF_FLG_VIRTUAL_SPACE_TRACKING: u32 = 65536;
pub const RTL_VRF_FLG_ENABLED_SYSTEM_WIDE: u32 = 131072;
pub const RTL_VRF_FLG_MISCELLANEOUS_CHECKS: u32 = 131072;
pub const RTL_VRF_FLG_LOCK_CHECKS: u32 = 262144;
pub const APPLICATION_VERIFIER_INTERNAL_ERROR: u32 = 2147483648;
pub const APPLICATION_VERIFIER_INTERNAL_WARNING: u32 = 1073741824;
pub const APPLICATION_VERIFIER_NO_BREAK: u32 = 536870912;
pub const APPLICATION_VERIFIER_CONTINUABLE_BREAK: u32 = 268435456;
pub const APPLICATION_VERIFIER_UNKNOWN_ERROR: u32 = 1;
pub const APPLICATION_VERIFIER_ACCESS_VIOLATION: u32 = 2;
pub const APPLICATION_VERIFIER_UNSYNCHRONIZED_ACCESS: u32 = 3;
pub const APPLICATION_VERIFIER_EXTREME_SIZE_REQUEST: u32 = 4;
pub const APPLICATION_VERIFIER_BAD_HEAP_HANDLE: u32 = 5;
pub const APPLICATION_VERIFIER_SWITCHED_HEAP_HANDLE: u32 = 6;
pub const APPLICATION_VERIFIER_DOUBLE_FREE: u32 = 7;
pub const APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK: u32 = 8;
pub const APPLICATION_VERIFIER_DESTROY_PROCESS_HEAP: u32 = 9;
pub const APPLICATION_VERIFIER_UNEXPECTED_EXCEPTION: u32 = 10;
pub const APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK_EXCEPTION_RAISED_FOR_HEADER: u32 = 11;
pub const APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK_EXCEPTION_RAISED_FOR_PROBING: u32 = 12;
pub const APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK_HEADER: u32 = 13;
pub const APPLICATION_VERIFIER_CORRUPTED_FREED_HEAP_BLOCK: u32 = 14;
pub const APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK_SUFFIX: u32 = 15;
pub const APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK_START_STAMP: u32 = 16;
pub const APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK_END_STAMP: u32 = 17;
pub const APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK_PREFIX: u32 = 18;
pub const APPLICATION_VERIFIER_FIRST_CHANCE_ACCESS_VIOLATION: u32 = 19;
pub const APPLICATION_VERIFIER_CORRUPTED_HEAP_LIST: u32 = 20;
pub const APPLICATION_VERIFIER_TERMINATE_THREAD_CALL: u32 = 256;
pub const APPLICATION_VERIFIER_STACK_OVERFLOW: u32 = 257;
pub const APPLICATION_VERIFIER_INVALID_EXIT_PROCESS_CALL: u32 = 258;
pub const APPLICATION_VERIFIER_EXIT_THREAD_OWNS_LOCK: u32 = 512;
pub const APPLICATION_VERIFIER_LOCK_IN_UNLOADED_DLL: u32 = 513;
pub const APPLICATION_VERIFIER_LOCK_IN_FREED_HEAP: u32 = 514;
pub const APPLICATION_VERIFIER_LOCK_DOUBLE_INITIALIZE: u32 = 515;
pub const APPLICATION_VERIFIER_LOCK_IN_FREED_MEMORY: u32 = 516;
pub const APPLICATION_VERIFIER_LOCK_CORRUPTED: u32 = 517;
pub const APPLICATION_VERIFIER_LOCK_INVALID_OWNER: u32 = 518;
pub const APPLICATION_VERIFIER_LOCK_INVALID_RECURSION_COUNT: u32 = 519;
pub const APPLICATION_VERIFIER_LOCK_INVALID_LOCK_COUNT: u32 = 520;
pub const APPLICATION_VERIFIER_LOCK_OVER_RELEASED: u32 = 521;
pub const APPLICATION_VERIFIER_LOCK_NOT_INITIALIZED: u32 = 528;
pub const APPLICATION_VERIFIER_LOCK_ALREADY_INITIALIZED: u32 = 529;
pub const APPLICATION_VERIFIER_LOCK_IN_FREED_VMEM: u32 = 530;
pub const APPLICATION_VERIFIER_LOCK_IN_UNMAPPED_MEM: u32 = 531;
pub const APPLICATION_VERIFIER_THREAD_NOT_LOCK_OWNER: u32 = 532;
pub const APPLICATION_VERIFIER_INVALID_HANDLE: u32 = 768;
pub const APPLICATION_VERIFIER_INVALID_TLS_VALUE: u32 = 769;
pub const APPLICATION_VERIFIER_INCORRECT_WAIT_CALL: u32 = 770;
pub const APPLICATION_VERIFIER_NULL_HANDLE: u32 = 771;
pub const APPLICATION_VERIFIER_WAIT_IN_DLLMAIN: u32 = 772;
pub const APPLICATION_VERIFIER_COM_ERROR: u32 = 1024;
pub const APPLICATION_VERIFIER_COM_API_IN_DLLMAIN: u32 = 1025;
pub const APPLICATION_VERIFIER_COM_UNHANDLED_EXCEPTION: u32 = 1026;
pub const APPLICATION_VERIFIER_COM_UNBALANCED_COINIT: u32 = 1027;
pub const APPLICATION_VERIFIER_COM_UNBALANCED_OLEINIT: u32 = 1028;
pub const APPLICATION_VERIFIER_COM_UNBALANCED_SWC: u32 = 1029;
pub const APPLICATION_VERIFIER_COM_NULL_DACL: u32 = 1030;
pub const APPLICATION_VERIFIER_COM_UNSAFE_IMPERSONATION: u32 = 1031;
pub const APPLICATION_VERIFIER_COM_SMUGGLED_WRAPPER: u32 = 1032;
pub const APPLICATION_VERIFIER_COM_SMUGGLED_PROXY: u32 = 1033;
pub const APPLICATION_VERIFIER_COM_CF_SUCCESS_WITH_NULL: u32 = 1034;
pub const APPLICATION_VERIFIER_COM_GCO_SUCCESS_WITH_NULL: u32 = 1035;
pub const APPLICATION_VERIFIER_COM_OBJECT_IN_FREED_MEMORY: u32 = 1036;
pub const APPLICATION_VERIFIER_COM_OBJECT_IN_UNLOADED_DLL: u32 = 1037;
pub const APPLICATION_VERIFIER_COM_VTBL_IN_FREED_MEMORY: u32 = 1038;
pub const APPLICATION_VERIFIER_COM_VTBL_IN_UNLOADED_DLL: u32 = 1039;
pub const APPLICATION_VERIFIER_COM_HOLDING_LOCKS_ON_CALL: u32 = 1040;
pub const APPLICATION_VERIFIER_RPC_ERROR: u32 = 1280;
pub const APPLICATION_VERIFIER_INVALID_FREEMEM: u32 = 1536;
pub const APPLICATION_VERIFIER_INVALID_ALLOCMEM: u32 = 1537;
pub const APPLICATION_VERIFIER_INVALID_MAPVIEW: u32 = 1538;
pub const APPLICATION_VERIFIER_PROBE_INVALID_ADDRESS: u32 = 1539;
pub const APPLICATION_VERIFIER_PROBE_FREE_MEM: u32 = 1540;
pub const APPLICATION_VERIFIER_PROBE_GUARD_PAGE: u32 = 1541;
pub const APPLICATION_VERIFIER_PROBE_NULL: u32 = 1542;
pub const APPLICATION_VERIFIER_PROBE_INVALID_START_OR_SIZE: u32 = 1543;
pub const APPLICATION_VERIFIER_SIZE_HEAP_UNEXPECTED_EXCEPTION: u32 = 1560;
pub const PERFORMANCE_DATA_VERSION: u32 = 1;
pub const READ_THREAD_PROFILING_FLAG_DISPATCHING: u32 = 1;
pub const READ_THREAD_PROFILING_FLAG_HARDWARE_COUNTERS: u32 = 2;
pub const DLL_PROCESS_ATTACH: u32 = 1;
pub const DLL_THREAD_ATTACH: u32 = 2;
pub const DLL_THREAD_DETACH: u32 = 3;
pub const DLL_PROCESS_DETACH: u32 = 0;
pub const DLL_PROCESS_VERIFIER: u32 = 4;
pub const EVENTLOG_SEQUENTIAL_READ: u32 = 1;
pub const EVENTLOG_SEEK_READ: u32 = 2;
pub const EVENTLOG_FORWARDS_READ: u32 = 4;
pub const EVENTLOG_BACKWARDS_READ: u32 = 8;
pub const EVENTLOG_SUCCESS: u32 = 0;
pub const EVENTLOG_ERROR_TYPE: u32 = 1;
pub const EVENTLOG_WARNING_TYPE: u32 = 2;
pub const EVENTLOG_INFORMATION_TYPE: u32 = 4;
pub const EVENTLOG_AUDIT_SUCCESS: u32 = 8;
pub const EVENTLOG_AUDIT_FAILURE: u32 = 16;
pub const EVENTLOG_START_PAIRED_EVENT: u32 = 1;
pub const EVENTLOG_END_PAIRED_EVENT: u32 = 2;
pub const EVENTLOG_END_ALL_PAIRED_EVENTS: u32 = 4;
pub const EVENTLOG_PAIRED_EVENT_ACTIVE: u32 = 8;
pub const EVENTLOG_PAIRED_EVENT_INACTIVE: u32 = 16;
pub const MAXLOGICALLOGNAMESIZE: u32 = 256;
pub const KEY_QUERY_VALUE: u32 = 1;
pub const KEY_SET_VALUE: u32 = 2;
pub const KEY_CREATE_SUB_KEY: u32 = 4;
pub const KEY_ENUMERATE_SUB_KEYS: u32 = 8;
pub const KEY_NOTIFY: u32 = 16;
pub const KEY_CREATE_LINK: u32 = 32;
pub const KEY_WOW64_64KEY: u32 = 256;
pub const KEY_WOW64_32KEY: u32 = 512;
pub const KEY_WOW64_RES: u32 = 768;
pub const REG_STANDARD_FORMAT: u32 = 1;
pub const REG_LATEST_FORMAT: u32 = 2;
pub const REG_NO_COMPRESSION: u32 = 4;
pub const REG_FORCE_UNLOAD: u32 = 1;
pub const REG_NONE: u32 = 0;
pub const REG_SZ: u32 = 1;
pub const REG_EXPAND_SZ: u32 = 2;
pub const REG_BINARY: u32 = 3;
pub const REG_DWORD: u32 = 4;
pub const REG_DWORD_LITTLE_ENDIAN: u32 = 4;
pub const REG_DWORD_BIG_ENDIAN: u32 = 5;
pub const REG_LINK: u32 = 6;
pub const REG_MULTI_SZ: u32 = 7;
pub const REG_RESOURCE_LIST: u32 = 8;
pub const REG_FULL_RESOURCE_DESCRIPTOR: u32 = 9;
pub const REG_RESOURCE_REQUIREMENTS_LIST: u32 = 10;
pub const REG_QWORD: u32 = 11;
pub const REG_QWORD_LITTLE_ENDIAN: u32 = 11;
pub const SERVICE_KERNEL_DRIVER: u32 = 1;
pub const SERVICE_FILE_SYSTEM_DRIVER: u32 = 2;
pub const SERVICE_ADAPTER: u32 = 4;
pub const SERVICE_RECOGNIZER_DRIVER: u32 = 8;
pub const SERVICE_DRIVER: u32 = 11;
pub const SERVICE_WIN32_OWN_PROCESS: u32 = 16;
pub const SERVICE_WIN32_SHARE_PROCESS: u32 = 32;
pub const SERVICE_WIN32: u32 = 48;
pub const SERVICE_INTERACTIVE_PROCESS: u32 = 256;
pub const SERVICE_TYPE_ALL: u32 = 319;
pub const SERVICE_BOOT_START: u32 = 0;
pub const SERVICE_SYSTEM_START: u32 = 1;
pub const SERVICE_AUTO_START: u32 = 2;
pub const SERVICE_DEMAND_START: u32 = 3;
pub const SERVICE_DISABLED: u32 = 4;
pub const SERVICE_ERROR_IGNORE: u32 = 0;
pub const SERVICE_ERROR_NORMAL: u32 = 1;
pub const SERVICE_ERROR_SEVERE: u32 = 2;
pub const SERVICE_ERROR_CRITICAL: u32 = 3;
pub const CM_SERVICE_NETWORK_BOOT_LOAD: u32 = 1;
pub const CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD: u32 = 2;
pub const CM_SERVICE_USB_DISK_BOOT_LOAD: u32 = 4;
pub const CM_SERVICE_SD_DISK_BOOT_LOAD: u32 = 8;
pub const CM_SERVICE_USB3_DISK_BOOT_LOAD: u32 = 16;
pub const CM_SERVICE_MEASURED_BOOT_LOAD: u32 = 32;
pub const CM_SERVICE_VERIFIER_BOOT_LOAD: u32 = 64;
pub const CM_SERVICE_WINPE_BOOT_LOAD: u32 = 128;
pub const CM_SERVICE_VALID_PROMOTION_MASK: u32 = 255;
pub const TAPE_DRIVE_FIXED: u32 = 1;
pub const TAPE_DRIVE_SELECT: u32 = 2;
pub const TAPE_DRIVE_INITIATOR: u32 = 4;
pub const TAPE_DRIVE_ERASE_SHORT: u32 = 16;
pub const TAPE_DRIVE_ERASE_LONG: u32 = 32;
pub const TAPE_DRIVE_ERASE_BOP_ONLY: u32 = 64;
pub const TAPE_DRIVE_ERASE_IMMEDIATE: u32 = 128;
pub const TAPE_DRIVE_TAPE_CAPACITY: u32 = 256;
pub const TAPE_DRIVE_TAPE_REMAINING: u32 = 512;
pub const TAPE_DRIVE_FIXED_BLOCK: u32 = 1024;
pub const TAPE_DRIVE_VARIABLE_BLOCK: u32 = 2048;
pub const TAPE_DRIVE_WRITE_PROTECT: u32 = 4096;
pub const TAPE_DRIVE_EOT_WZ_SIZE: u32 = 8192;
pub const TAPE_DRIVE_ECC: u32 = 65536;
pub const TAPE_DRIVE_COMPRESSION: u32 = 131072;
pub const TAPE_DRIVE_PADDING: u32 = 262144;
pub const TAPE_DRIVE_REPORT_SMKS: u32 = 524288;
pub const TAPE_DRIVE_GET_ABSOLUTE_BLK: u32 = 1048576;
pub const TAPE_DRIVE_GET_LOGICAL_BLK: u32 = 2097152;
pub const TAPE_DRIVE_SET_EOT_WZ_SIZE: u32 = 4194304;
pub const TAPE_DRIVE_EJECT_MEDIA: u32 = 16777216;
pub const TAPE_DRIVE_CLEAN_REQUESTS: u32 = 33554432;
pub const TAPE_DRIVE_SET_CMP_BOP_ONLY: u32 = 67108864;
pub const TAPE_DRIVE_RESERVED_BIT: u32 = 2147483648;
pub const TAPE_DRIVE_LOAD_UNLOAD: u32 = 2147483649;
pub const TAPE_DRIVE_TENSION: u32 = 2147483650;
pub const TAPE_DRIVE_LOCK_UNLOCK: u32 = 2147483652;
pub const TAPE_DRIVE_REWIND_IMMEDIATE: u32 = 2147483656;
pub const TAPE_DRIVE_SET_BLOCK_SIZE: u32 = 2147483664;
pub const TAPE_DRIVE_LOAD_UNLD_IMMED: u32 = 2147483680;
pub const TAPE_DRIVE_TENSION_IMMED: u32 = 2147483712;
pub const TAPE_DRIVE_LOCK_UNLK_IMMED: u32 = 2147483776;
pub const TAPE_DRIVE_SET_ECC: u32 = 2147483904;
pub const TAPE_DRIVE_SET_COMPRESSION: u32 = 2147484160;
pub const TAPE_DRIVE_SET_PADDING: u32 = 2147484672;
pub const TAPE_DRIVE_SET_REPORT_SMKS: u32 = 2147485696;
pub const TAPE_DRIVE_ABSOLUTE_BLK: u32 = 2147487744;
pub const TAPE_DRIVE_ABS_BLK_IMMED: u32 = 2147491840;
pub const TAPE_DRIVE_LOGICAL_BLK: u32 = 2147500032;
pub const TAPE_DRIVE_LOG_BLK_IMMED: u32 = 2147516416;
pub const TAPE_DRIVE_END_OF_DATA: u32 = 2147549184;
pub const TAPE_DRIVE_RELATIVE_BLKS: u32 = 2147614720;
pub const TAPE_DRIVE_FILEMARKS: u32 = 2147745792;
pub const TAPE_DRIVE_SEQUENTIAL_FMKS: u32 = 2148007936;
pub const TAPE_DRIVE_SETMARKS: u32 = 2148532224;
pub const TAPE_DRIVE_SEQUENTIAL_SMKS: u32 = 2149580800;
pub const TAPE_DRIVE_REVERSE_POSITION: u32 = 2151677952;
pub const TAPE_DRIVE_SPACE_IMMEDIATE: u32 = 2155872256;
pub const TAPE_DRIVE_WRITE_SETMARKS: u32 = 2164260864;
pub const TAPE_DRIVE_WRITE_FILEMARKS: u32 = 2181038080;
pub const TAPE_DRIVE_WRITE_SHORT_FMKS: u32 = 2214592512;
pub const TAPE_DRIVE_WRITE_LONG_FMKS: u32 = 2281701376;
pub const TAPE_DRIVE_WRITE_MARK_IMMED: u32 = 2415919104;
pub const TAPE_DRIVE_FORMAT: u32 = 2684354560;
pub const TAPE_DRIVE_FORMAT_IMMEDIATE: u32 = 3221225472;
pub const TAPE_DRIVE_HIGH_FEATURES: u32 = 2147483648;
pub const TRANSACTION_MANAGER_VOLATILE: u32 = 1;
pub const TRANSACTION_MANAGER_COMMIT_DEFAULT: u32 = 0;
pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_VOLUME: u32 = 2;
pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_HIVES: u32 = 4;
pub const TRANSACTION_MANAGER_COMMIT_LOWEST: u32 = 8;
pub const TRANSACTION_MANAGER_CORRUPT_FOR_RECOVERY: u32 = 16;
pub const TRANSACTION_MANAGER_CORRUPT_FOR_PROGRESS: u32 = 32;
pub const TRANSACTION_MANAGER_MAXIMUM_OPTION: u32 = 63;
pub const TRANSACTION_DO_NOT_PROMOTE: u32 = 1;
pub const TRANSACTION_MAXIMUM_OPTION: u32 = 1;
pub const RESOURCE_MANAGER_VOLATILE: u32 = 1;
pub const RESOURCE_MANAGER_COMMUNICATION: u32 = 2;
pub const RESOURCE_MANAGER_MAXIMUM_OPTION: u32 = 3;
pub const CRM_PROTOCOL_EXPLICIT_MARSHAL_ONLY: u32 = 1;
pub const CRM_PROTOCOL_DYNAMIC_MARSHAL_INFO: u32 = 2;
pub const CRM_PROTOCOL_MAXIMUM_OPTION: u32 = 3;
pub const ENLISTMENT_SUPERIOR: u32 = 1;
pub const ENLISTMENT_MAXIMUM_OPTION: u32 = 1;
pub const TRANSACTION_NOTIFY_MASK: u32 = 1073741823;
pub const TRANSACTION_NOTIFY_PREPREPARE: u32 = 1;
pub const TRANSACTION_NOTIFY_PREPARE: u32 = 2;
pub const TRANSACTION_NOTIFY_COMMIT: u32 = 4;
pub const TRANSACTION_NOTIFY_ROLLBACK: u32 = 8;
pub const TRANSACTION_NOTIFY_PREPREPARE_COMPLETE: u32 = 16;
pub const TRANSACTION_NOTIFY_PREPARE_COMPLETE: u32 = 32;
pub const TRANSACTION_NOTIFY_COMMIT_COMPLETE: u32 = 64;
pub const TRANSACTION_NOTIFY_ROLLBACK_COMPLETE: u32 = 128;
pub const TRANSACTION_NOTIFY_RECOVER: u32 = 256;
pub const TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT: u32 = 512;
pub const TRANSACTION_NOTIFY_DELEGATE_COMMIT: u32 = 1024;
pub const TRANSACTION_NOTIFY_RECOVER_QUERY: u32 = 2048;
pub const TRANSACTION_NOTIFY_ENLIST_PREPREPARE: u32 = 4096;
pub const TRANSACTION_NOTIFY_LAST_RECOVER: u32 = 8192;
pub const TRANSACTION_NOTIFY_INDOUBT: u32 = 16384;
pub const TRANSACTION_NOTIFY_PROPAGATE_PULL: u32 = 32768;
pub const TRANSACTION_NOTIFY_PROPAGATE_PUSH: u32 = 65536;
pub const TRANSACTION_NOTIFY_MARSHAL: u32 = 131072;
pub const TRANSACTION_NOTIFY_ENLIST_MASK: u32 = 262144;
pub const TRANSACTION_NOTIFY_RM_DISCONNECTED: u32 = 16777216;
pub const TRANSACTION_NOTIFY_TM_ONLINE: u32 = 33554432;
pub const TRANSACTION_NOTIFY_COMMIT_REQUEST: u32 = 67108864;
pub const TRANSACTION_NOTIFY_PROMOTE: u32 = 134217728;
pub const TRANSACTION_NOTIFY_PROMOTE_NEW: u32 = 268435456;
pub const TRANSACTION_NOTIFY_REQUEST_OUTCOME: u32 = 536870912;
pub const TRANSACTION_NOTIFY_COMMIT_FINALIZE: u32 = 1073741824;
pub const TRANSACTIONMANAGER_OBJECT_PATH: &[u8; 21] = b"\\TransactionManager\\\0";
pub const TRANSACTION_OBJECT_PATH: &[u8; 14] = b"\\Transaction\\\0";
pub const ENLISTMENT_OBJECT_PATH: &[u8; 13] = b"\\Enlistment\\\0";
pub const RESOURCE_MANAGER_OBJECT_PATH: &[u8; 18] = b"\\ResourceManager\\\0";
pub const TRANSACTION_NOTIFICATION_TM_ONLINE_FLAG_IS_CLUSTERED: u32 = 1;
pub const KTM_MARSHAL_BLOB_VERSION_MAJOR: u32 = 1;
pub const KTM_MARSHAL_BLOB_VERSION_MINOR: u32 = 1;
pub const MAX_TRANSACTION_DESCRIPTION_LENGTH: u32 = 64;
pub const MAX_RESOURCEMANAGER_DESCRIPTION_LENGTH: u32 = 64;
pub const TRANSACTIONMANAGER_QUERY_INFORMATION: u32 = 1;
pub const TRANSACTIONMANAGER_SET_INFORMATION: u32 = 2;
pub const TRANSACTIONMANAGER_RECOVER: u32 = 4;
pub const TRANSACTIONMANAGER_RENAME: u32 = 8;
pub const TRANSACTIONMANAGER_CREATE_RM: u32 = 16;
pub const TRANSACTIONMANAGER_BIND_TRANSACTION: u32 = 32;
pub const TRANSACTION_QUERY_INFORMATION: u32 = 1;
pub const TRANSACTION_SET_INFORMATION: u32 = 2;
pub const TRANSACTION_ENLIST: u32 = 4;
pub const TRANSACTION_COMMIT: u32 = 8;
pub const TRANSACTION_ROLLBACK: u32 = 16;
pub const TRANSACTION_PROPAGATE: u32 = 32;
pub const TRANSACTION_RIGHT_RESERVED1: u32 = 64;
pub const RESOURCEMANAGER_QUERY_INFORMATION: u32 = 1;
pub const RESOURCEMANAGER_SET_INFORMATION: u32 = 2;
pub const RESOURCEMANAGER_RECOVER: u32 = 4;
pub const RESOURCEMANAGER_ENLIST: u32 = 8;
pub const RESOURCEMANAGER_GET_NOTIFICATION: u32 = 16;
pub const RESOURCEMANAGER_REGISTER_PROTOCOL: u32 = 32;
pub const RESOURCEMANAGER_COMPLETE_PROPAGATION: u32 = 64;
pub const ENLISTMENT_QUERY_INFORMATION: u32 = 1;
pub const ENLISTMENT_SET_INFORMATION: u32 = 2;
pub const ENLISTMENT_RECOVER: u32 = 4;
pub const ENLISTMENT_SUBORDINATE_RIGHTS: u32 = 8;
pub const ENLISTMENT_SUPERIOR_RIGHTS: u32 = 16;
pub const WOW64_CONTEXT_i386: u32 = 65536;
pub const WOW64_CONTEXT_i486: u32 = 65536;
pub const WOW64_CONTEXT_EXCEPTION_ACTIVE: u32 = 134217728;
pub const WOW64_CONTEXT_SERVICE_ACTIVE: u32 = 268435456;
pub const WOW64_CONTEXT_EXCEPTION_REQUEST: u32 = 1073741824;
pub const WOW64_CONTEXT_EXCEPTION_REPORTING: u32 = 2147483648;
pub const WOW64_SIZE_OF_80387_REGISTERS: u32 = 80;
pub const WOW64_MAXIMUM_SUPPORTED_EXTENSION: u32 = 512;
pub const ALL_PROCESSOR_GROUPS: u32 = 65535;
pub const ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION: u32 = 1;
pub const ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION: u32 = 2;
pub const ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION: u32 = 3;
pub const ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION: u32 = 4;
pub const ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION: u32 = 5;
pub const ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION: u32 = 6;
pub const ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION: u32 = 7;
pub const ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE: u32 = 8;
pub const ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES: u32 = 9;
pub const ACTIVATION_CONTEXT_SECTION_APPLICATION_SETTINGS: u32 = 10;
pub const ACTIVATION_CONTEXT_SECTION_COMPATIBILITY_INFO: u32 = 11;
pub const ACTIVATION_CONTEXT_SECTION_WINRT_ACTIVATABLE_CLASSES: u32 = 12;
pub const HMONITOR_DECLARED: u32 = 1;
pub const APP_LOCAL_DEVICE_ID_SIZE: u32 = 32;
pub const DM_UPDATE: u32 = 1;
pub const DM_COPY: u32 = 2;
pub const DM_PROMPT: u32 = 4;
pub const DM_MODIFY: u32 = 8;
pub const DM_IN_BUFFER: u32 = 8;
pub const DM_IN_PROMPT: u32 = 4;
pub const DM_OUT_BUFFER: u32 = 2;
pub const DM_OUT_DEFAULT: u32 = 1;
pub const DC_FIELDS: u32 = 1;
pub const DC_PAPERS: u32 = 2;
pub const DC_PAPERSIZE: u32 = 3;
pub const DC_MINEXTENT: u32 = 4;
pub const DC_MAXEXTENT: u32 = 5;
pub const DC_BINS: u32 = 6;
pub const DC_DUPLEX: u32 = 7;
pub const DC_SIZE: u32 = 8;
pub const DC_EXTRA: u32 = 9;
pub const DC_VERSION: u32 = 10;
pub const DC_DRIVER: u32 = 11;
pub const DC_BINNAMES: u32 = 12;
pub const DC_ENUMRESOLUTIONS: u32 = 13;
pub const DC_FILEDEPENDENCIES: u32 = 14;
pub const DC_TRUETYPE: u32 = 15;
pub const DC_PAPERNAMES: u32 = 16;
pub const DC_ORIENTATION: u32 = 17;
pub const DC_COPIES: u32 = 18;
pub const OBJ_INHERIT: u32 = 2;
pub const OBJ_PERMANENT: u32 = 16;
pub const OBJ_EXCLUSIVE: u32 = 32;
pub const OBJ_CASE_INSENSITIVE: u32 = 64;
pub const OBJ_OPENIF: u32 = 128;
pub const OBJ_OPENLINK: u32 = 256;
pub const OBJ_KERNEL_HANDLE: u32 = 512;
pub const OBJ_FORCE_ACCESS_CHECK: u32 = 1024;
pub const OBJ_IGNORE_IMPERSONATED_DEVICEMAP: u32 = 2048;
pub const OBJ_DONT_REPARSE: u32 = 4096;
pub const OBJ_VALID_ATTRIBUTES: u32 = 8178;
pub const FILE_VALID_OPTION_FLAGS: u32 = 16777215;
pub const FILE_VALID_PIPE_OPTION_FLAGS: u32 = 50;
pub const FILE_VALID_MAILSLOT_OPTION_FLAGS: u32 = 50;
pub const FILE_VALID_SET_FLAGS: u32 = 54;
pub const FILE_SUPERSEDED: u32 = 0;
pub const FILE_OPENED: u32 = 1;
pub const FILE_CREATED: u32 = 2;
pub const FILE_OVERWRITTEN: u32 = 3;
pub const FILE_EXISTS: u32 = 4;
pub const FILE_DOES_NOT_EXIST: u32 = 5;
pub const CODEINTEGRITY_OPTION_ENABLED: u32 = 1;
pub const CODEINTEGRITY_OPTION_TESTSIGN: u32 = 2;
pub const CODEINTEGRITY_OPTION_UMCI_ENABLED: u32 = 4;
pub const CODEINTEGRITY_OPTION_UMCI_AUDITMODE_ENABLED: u32 = 8;
pub const CODEINTEGRITY_OPTION_UMCI_EXCLUSIONPATHS_ENABLED: u32 = 16;
pub const CODEINTEGRITY_OPTION_TEST_BUILD: u32 = 32;
pub const CODEINTEGRITY_OPTION_PREPRODUCTION_BUILD: u32 = 64;
pub const CODEINTEGRITY_OPTION_DEBUGMODE_ENABLED: u32 = 128;
pub const CODEINTEGRITY_OPTION_FLIGHT_BUILD: u32 = 256;
pub const CODEINTEGRITY_OPTION_FLIGHTING_ENABLED: u32 = 512;
pub const CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED: u32 = 1024;
pub const CODEINTEGRITY_OPTION_HVCI_KMCI_AUDITMODE_ENABLED: u32 = 2048;
pub const CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED: u32 = 4096;
pub const CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED: u32 = 8192;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
extern "C" {
    pub fn __mingw_get_crt_info() -> *const ::std::os::raw::c_char;
}
pub type ULONG = ::std::os::raw::c_ulong;
pub type PULONG = *mut ULONG;
pub type USHORT = ::std::os::raw::c_ushort;
pub type PUSHORT = *mut USHORT;
pub type UCHAR = ::std::os::raw::c_uchar;
pub type PUCHAR = *mut UCHAR;
pub type PSZ = *mut ::std::os::raw::c_char;
pub type WINBOOL = ::std::os::raw::c_int;
pub type BOOL = ::std::os::raw::c_int;
pub type PBOOL = *mut WINBOOL;
pub type LPBOOL = *mut WINBOOL;
pub type BYTE = ::std::os::raw::c_uchar;
pub type WORD = ::std::os::raw::c_ushort;
pub type DWORD = ::std::os::raw::c_ulong;
pub type FLOAT = f32;
pub type PFLOAT = *mut FLOAT;
pub type PBYTE = *mut BYTE;
pub type LPBYTE = *mut BYTE;
pub type PINT = *mut ::std::os::raw::c_int;
pub type LPINT = *mut ::std::os::raw::c_int;
pub type PWORD = *mut WORD;
pub type LPWORD = *mut WORD;
pub type LPLONG = *mut ::std::os::raw::c_long;
pub type PDWORD = *mut DWORD;
pub type LPDWORD = *mut DWORD;
pub type LPVOID = *mut ::std::os::raw::c_void;
pub type LPCVOID = *const ::std::os::raw::c_void;
pub type INT = ::std::os::raw::c_int;
pub type UINT = ::std::os::raw::c_uint;
pub type PUINT = *mut ::std::os::raw::c_uint;
pub type rsize_t = usize;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type errno_t = ::std::os::raw::c_int;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
pub type time_t = __time64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadmbcinfostruct {
    _unused: [u8; 0],
}
pub type pthreadlocinfo = *mut threadlocaleinfostruct;
pub type pthreadmbcinfo = *mut threadmbcinfostruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lc_time_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct localeinfo_struct {
    pub locinfo: pthreadlocinfo,
    pub mbcinfo: pthreadmbcinfo,
}
#[test]
fn bindgen_test_layout_localeinfo_struct() {
    const UNINIT: ::std::mem::MaybeUninit<localeinfo_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<localeinfo_struct>(),
        16usize,
        concat!("Size of: ", stringify!(localeinfo_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<localeinfo_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(localeinfo_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(localeinfo_struct),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbcinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(localeinfo_struct),
            "::",
            stringify!(mbcinfo)
        )
    );
}
pub type _locale_tstruct = localeinfo_struct;
pub type _locale_t = *mut localeinfo_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagLC_ID {
    pub wLanguage: ::std::os::raw::c_ushort,
    pub wCountry: ::std::os::raw::c_ushort,
    pub wCodePage: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_tagLC_ID() {
    const UNINIT: ::std::mem::MaybeUninit<tagLC_ID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tagLC_ID>(),
        6usize,
        concat!("Size of: ", stringify!(tagLC_ID))
    );
    assert_eq!(
        ::std::mem::align_of::<tagLC_ID>(),
        2usize,
        concat!("Alignment of ", stringify!(tagLC_ID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wLanguage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagLC_ID),
            "::",
            stringify!(wLanguage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wCountry) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tagLC_ID),
            "::",
            stringify!(wCountry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wCodePage) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagLC_ID),
            "::",
            stringify!(wCodePage)
        )
    );
}
pub type LC_ID = tagLC_ID;
pub type LPLC_ID = *mut tagLC_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadlocaleinfostruct {
    pub refcount: ::std::os::raw::c_int,
    pub lc_codepage: ::std::os::raw::c_uint,
    pub lc_collate_cp: ::std::os::raw::c_uint,
    pub lc_handle: [::std::os::raw::c_ulong; 6usize],
    pub lc_id: [LC_ID; 6usize],
    pub lc_category: [threadlocaleinfostruct__bindgen_ty_1; 6usize],
    pub lc_clike: ::std::os::raw::c_int,
    pub mb_cur_max: ::std::os::raw::c_int,
    pub lconv_intl_refcount: *mut ::std::os::raw::c_int,
    pub lconv_num_refcount: *mut ::std::os::raw::c_int,
    pub lconv_mon_refcount: *mut ::std::os::raw::c_int,
    pub lconv: *mut lconv,
    pub ctype1_refcount: *mut ::std::os::raw::c_int,
    pub ctype1: *mut ::std::os::raw::c_ushort,
    pub pctype: *const ::std::os::raw::c_ushort,
    pub pclmap: *const ::std::os::raw::c_uchar,
    pub pcumap: *const ::std::os::raw::c_uchar,
    pub lc_time_curr: *mut __lc_time_data,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadlocaleinfostruct__bindgen_ty_1 {
    pub locale: *mut ::std::os::raw::c_char,
    pub wlocale: *mut wchar_t,
    pub refcount: *mut ::std::os::raw::c_int,
    pub wrefcount: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_threadlocaleinfostruct__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<threadlocaleinfostruct__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<threadlocaleinfostruct__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<threadlocaleinfostruct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locale) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1),
            "::",
            stringify!(locale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wlocale) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1),
            "::",
            stringify!(wlocale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wrefcount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1),
            "::",
            stringify!(wrefcount)
        )
    );
}
#[test]
fn bindgen_test_layout_threadlocaleinfostruct() {
    const UNINIT: ::std::mem::MaybeUninit<threadlocaleinfostruct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<threadlocaleinfostruct>(),
        352usize,
        concat!("Size of: ", stringify!(threadlocaleinfostruct))
    );
    assert_eq!(
        ::std::mem::align_of::<threadlocaleinfostruct>(),
        8usize,
        concat!("Alignment of ", stringify!(threadlocaleinfostruct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lc_codepage) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_codepage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lc_collate_cp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_collate_cp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lc_handle) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lc_id) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lc_category) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_category)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lc_clike) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_clike)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mb_cur_max) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(mb_cur_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lconv_intl_refcount) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lconv_intl_refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lconv_num_refcount) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lconv_num_refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lconv_mon_refcount) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lconv_mon_refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lconv) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lconv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctype1_refcount) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(ctype1_refcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctype1) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(ctype1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pctype) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(pctype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pclmap) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(pclmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcumap) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(pcumap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lc_time_curr) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_time_curr)
        )
    );
}
pub type threadlocinfo = threadlocaleinfostruct;
extern "C" {
    pub static mut __imp__pctype: *mut *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub static mut __imp__wctype: *mut *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub static mut __imp__pwctype: *mut *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub static __newclmap: [::std::os::raw::c_uchar; 0usize];
}
extern "C" {
    pub static __newcumap: [::std::os::raw::c_uchar; 0usize];
}
extern "C" {
    pub static mut __ptlocinfo: pthreadlocinfo;
}
extern "C" {
    pub static mut __ptmbcinfo: pthreadmbcinfo;
}
extern "C" {
    pub static mut __globallocalestatus: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __locale_changed: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __initiallocinfo: threadlocaleinfostruct;
}
extern "C" {
    pub static mut __initiallocalestructinfo: _locale_tstruct;
}
extern "C" {
    pub fn __updatetlocinfo() -> pthreadlocinfo;
}
extern "C" {
    pub fn __updatetmbcinfo() -> pthreadmbcinfo;
}
extern "C" {
    pub fn _isctype(
        _C: ::std::os::raw::c_int,
        _Type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isctype_l(
        _C: ::std::os::raw::c_int,
        _Type: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isalpha_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isupper_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _islower_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isdigit_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isxdigit_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isspace_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ispunct_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalnum(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isalnum_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isprint_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isgraph_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iscntrl_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isascii(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toascii(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iscsymf(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iscsym(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswalpha(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswalpha_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswupper(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswupper_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswlower(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswlower_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswdigit(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswdigit_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswxdigit(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswxdigit_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswspace(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswspace_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswpunct(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswpunct_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswalnum(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswalnum_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswprint(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswprint_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswgraph(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswgraph_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswcntrl(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswcntrl_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswascii(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isleadbyte(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isleadbyte_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn towupper(_C: wint_t) -> wint_t;
}
extern "C" {
    pub fn _towupper_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
extern "C" {
    pub fn towlower(_C: wint_t) -> wint_t;
}
extern "C" {
    pub fn _towlower_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
extern "C" {
    pub fn iswctype(_C: wint_t, _Type: wctype_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_wctype(_C: wint_t, _Type: wctype_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswblank(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __imp___mb_cur_max: *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __C_specific_handler(
        _ExceptionRecord: *mut _EXCEPTION_RECORD,
        _EstablisherFrame: *mut ::std::os::raw::c_void,
        _ContextRecord: *mut _CONTEXT,
        _DispatcherContext: *mut _DISPATCHER_CONTEXT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exception_code() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _exception_info() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _abnormal_termination() -> ::std::os::raw::c_int;
}
pub type _PHNDLR = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XCPT_ACTION {
    pub XcptNum: ::std::os::raw::c_ulong,
    pub SigNum: ::std::os::raw::c_int,
    pub XcptAction: _PHNDLR,
}
#[test]
fn bindgen_test_layout__XCPT_ACTION() {
    const UNINIT: ::std::mem::MaybeUninit<_XCPT_ACTION> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_XCPT_ACTION>(),
        16usize,
        concat!("Size of: ", stringify!(_XCPT_ACTION))
    );
    assert_eq!(
        ::std::mem::align_of::<_XCPT_ACTION>(),
        8usize,
        concat!("Alignment of ", stringify!(_XCPT_ACTION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).XcptNum) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XCPT_ACTION),
            "::",
            stringify!(XcptNum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SigNum) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XCPT_ACTION),
            "::",
            stringify!(SigNum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).XcptAction) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XCPT_ACTION),
            "::",
            stringify!(XcptAction)
        )
    );
}
extern "C" {
    pub static mut _XcptActTab: [_XCPT_ACTION; 0usize];
}
extern "C" {
    pub static mut _XcptActTabCount: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut _XcptActTabSize: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut _First_FPE_Indx: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut _Num_FPE: ::std::os::raw::c_int;
}
extern "C" {
    pub fn __CppXcptFilter(
        _ExceptionNum: ::std::os::raw::c_ulong,
        _ExceptionPtr: *mut _EXCEPTION_POINTERS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _XcptFilter(
        _ExceptionNum: ::std::os::raw::c_ulong,
        _ExceptionPtr: *mut _EXCEPTION_POINTERS,
    ) -> ::std::os::raw::c_int;
}
pub type PEXCEPTION_HANDLER = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut _EXCEPTION_RECORD,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut _CONTEXT,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type POINTER_64_INT = ::std::os::raw::c_ulonglong;
pub type INT8 = ::std::os::raw::c_schar;
pub type PINT8 = *mut ::std::os::raw::c_schar;
pub type INT16 = ::std::os::raw::c_short;
pub type PINT16 = *mut ::std::os::raw::c_short;
pub type INT32 = ::std::os::raw::c_int;
pub type PINT32 = *mut ::std::os::raw::c_int;
pub type INT64 = ::std::os::raw::c_longlong;
pub type PINT64 = *mut ::std::os::raw::c_longlong;
pub type UINT8 = ::std::os::raw::c_uchar;
pub type PUINT8 = *mut ::std::os::raw::c_uchar;
pub type UINT16 = ::std::os::raw::c_ushort;
pub type PUINT16 = *mut ::std::os::raw::c_ushort;
pub type UINT32 = ::std::os::raw::c_uint;
pub type PUINT32 = *mut ::std::os::raw::c_uint;
pub type UINT64 = ::std::os::raw::c_ulonglong;
pub type PUINT64 = *mut ::std::os::raw::c_ulonglong;
pub type LONG32 = ::std::os::raw::c_int;
pub type PLONG32 = *mut ::std::os::raw::c_int;
pub type ULONG32 = ::std::os::raw::c_uint;
pub type PULONG32 = *mut ::std::os::raw::c_uint;
pub type DWORD32 = ::std::os::raw::c_uint;
pub type PDWORD32 = *mut ::std::os::raw::c_uint;
pub type INT_PTR = ::std::os::raw::c_longlong;
pub type PINT_PTR = *mut ::std::os::raw::c_longlong;
pub type UINT_PTR = ::std::os::raw::c_ulonglong;
pub type PUINT_PTR = *mut ::std::os::raw::c_ulonglong;
pub type LONG_PTR = ::std::os::raw::c_longlong;
pub type PLONG_PTR = *mut ::std::os::raw::c_longlong;
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type PULONG_PTR = *mut ::std::os::raw::c_ulonglong;
pub type SHANDLE_PTR = ::std::os::raw::c_longlong;
pub type HANDLE_PTR = ::std::os::raw::c_ulonglong;
pub type UHALF_PTR = ::std::os::raw::c_uint;
pub type PUHALF_PTR = *mut ::std::os::raw::c_uint;
pub type HALF_PTR = ::std::os::raw::c_int;
pub type PHALF_PTR = *mut ::std::os::raw::c_int;
pub type SIZE_T = ULONG_PTR;
pub type PSIZE_T = *mut ULONG_PTR;
pub type SSIZE_T = LONG_PTR;
pub type PSSIZE_T = *mut LONG_PTR;
pub type DWORD_PTR = ULONG_PTR;
pub type PDWORD_PTR = *mut ULONG_PTR;
pub type LONG64 = ::std::os::raw::c_longlong;
pub type PLONG64 = *mut ::std::os::raw::c_longlong;
pub type ULONG64 = ::std::os::raw::c_ulonglong;
pub type PULONG64 = *mut ::std::os::raw::c_ulonglong;
pub type DWORD64 = ::std::os::raw::c_ulonglong;
pub type PDWORD64 = *mut ::std::os::raw::c_ulonglong;
pub type KAFFINITY = ULONG_PTR;
pub type PKAFFINITY = *mut KAFFINITY;
pub type PVOID = *mut ::std::os::raw::c_void;
pub type PVOID64 = *mut ::std::os::raw::c_void;
pub type CHAR = ::std::os::raw::c_char;
pub type SHORT = ::std::os::raw::c_short;
pub type LONG = ::std::os::raw::c_long;
pub type WCHAR = wchar_t;
pub type PWCHAR = *mut WCHAR;
pub type LPWCH = *mut WCHAR;
pub type PWCH = *mut WCHAR;
pub type LPCWCH = *const WCHAR;
pub type PCWCH = *const WCHAR;
pub type NWPSTR = *mut WCHAR;
pub type LPWSTR = *mut WCHAR;
pub type PWSTR = *mut WCHAR;
pub type PZPWSTR = *mut PWSTR;
pub type PCZPWSTR = *const PWSTR;
pub type LPUWSTR = *mut WCHAR;
pub type PUWSTR = *mut WCHAR;
pub type LPCWSTR = *const WCHAR;
pub type PCWSTR = *const WCHAR;
pub type PZPCWSTR = *mut PCWSTR;
pub type LPCUWSTR = *const WCHAR;
pub type PCUWSTR = *const WCHAR;
pub type PZZWSTR = *mut WCHAR;
pub type PCZZWSTR = *const WCHAR;
pub type PUZZWSTR = *mut WCHAR;
pub type PCUZZWSTR = *const WCHAR;
pub type PNZWCH = *mut WCHAR;
pub type PCNZWCH = *const WCHAR;
pub type PUNZWCH = *mut WCHAR;
pub type PCUNZWCH = *const WCHAR;
pub type LPCWCHAR = *const WCHAR;
pub type PCWCHAR = *const WCHAR;
pub type LPCUWCHAR = *const WCHAR;
pub type PCUWCHAR = *const WCHAR;
pub type UCSCHAR = ::std::os::raw::c_ulong;
pub type PUCSCHAR = *mut UCSCHAR;
pub type PCUCSCHAR = *const UCSCHAR;
pub type PUCSSTR = *mut UCSCHAR;
pub type PUUCSSTR = *mut UCSCHAR;
pub type PCUCSSTR = *const UCSCHAR;
pub type PCUUCSSTR = *const UCSCHAR;
pub type PUUCSCHAR = *mut UCSCHAR;
pub type PCUUCSCHAR = *const UCSCHAR;
pub type PCHAR = *mut CHAR;
pub type LPCH = *mut CHAR;
pub type PCH = *mut CHAR;
pub type LPCCH = *const CHAR;
pub type PCCH = *const CHAR;
pub type NPSTR = *mut CHAR;
pub type LPSTR = *mut CHAR;
pub type PSTR = *mut CHAR;
pub type PZPSTR = *mut PSTR;
pub type PCZPSTR = *const PSTR;
pub type LPCSTR = *const CHAR;
pub type PCSTR = *const CHAR;
pub type PZPCSTR = *mut PCSTR;
pub type PZZSTR = *mut CHAR;
pub type PCZZSTR = *const CHAR;
pub type PNZCH = *mut CHAR;
pub type PCNZCH = *const CHAR;
pub type TCHAR = ::std::os::raw::c_char;
pub type PTCHAR = *mut ::std::os::raw::c_char;
pub type TBYTE = ::std::os::raw::c_uchar;
pub type PTBYTE = *mut ::std::os::raw::c_uchar;
pub type LPTCH = LPSTR;
pub type PTCH = LPSTR;
pub type LPCTCH = LPCCH;
pub type PCTCH = LPCCH;
pub type PTSTR = LPSTR;
pub type LPTSTR = LPSTR;
pub type PUTSTR = LPSTR;
pub type LPUTSTR = LPSTR;
pub type PCTSTR = LPCSTR;
pub type LPCTSTR = LPCSTR;
pub type PCUTSTR = LPCSTR;
pub type LPCUTSTR = LPCSTR;
pub type PZZTSTR = PZZSTR;
pub type PUZZTSTR = PZZSTR;
pub type PCZZTSTR = PCZZSTR;
pub type PCUZZTSTR = PCZZSTR;
pub type PZPTSTR = PZPSTR;
pub type PNZTCH = PNZCH;
pub type PUNZTCH = PNZCH;
pub type PCNZTCH = PCNZCH;
pub type PCUNZTCH = PCNZCH;
pub type PSHORT = *mut SHORT;
pub type PLONG = *mut LONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GROUP_AFFINITY {
    pub Mask: KAFFINITY,
    pub Group: WORD,
    pub Reserved: [WORD; 3usize],
}
#[test]
fn bindgen_test_layout__GROUP_AFFINITY() {
    const UNINIT: ::std::mem::MaybeUninit<_GROUP_AFFINITY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GROUP_AFFINITY>(),
        16usize,
        concat!("Size of: ", stringify!(_GROUP_AFFINITY))
    );
    assert_eq!(
        ::std::mem::align_of::<_GROUP_AFFINITY>(),
        8usize,
        concat!("Alignment of ", stringify!(_GROUP_AFFINITY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GROUP_AFFINITY),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Group) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GROUP_AFFINITY),
            "::",
            stringify!(Group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_GROUP_AFFINITY),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type GROUP_AFFINITY = _GROUP_AFFINITY;
pub type PGROUP_AFFINITY = *mut _GROUP_AFFINITY;
pub type HANDLE = *mut ::std::os::raw::c_void;
pub type PHANDLE = *mut HANDLE;
pub type FCHAR = BYTE;
pub type FSHORT = WORD;
pub type FLONG = DWORD;
pub type HRESULT = LONG;
pub type CCHAR = ::std::os::raw::c_char;
pub type LCID = DWORD;
pub type PLCID = PDWORD;
pub type LANGID = WORD;
pub const COMPARTMENT_ID_UNSPECIFIED_COMPARTMENT_ID: COMPARTMENT_ID = 0;
pub const COMPARTMENT_ID_DEFAULT_COMPARTMENT_ID: COMPARTMENT_ID = 1;
pub type COMPARTMENT_ID = ::std::os::raw::c_uint;
pub type PCOMPARTMENT_ID = *mut COMPARTMENT_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLOAT128 {
    pub LowPart: ::std::os::raw::c_longlong,
    pub HighPart: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__FLOAT128() {
    const UNINIT: ::std::mem::MaybeUninit<_FLOAT128> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FLOAT128>(),
        16usize,
        concat!("Size of: ", stringify!(_FLOAT128))
    );
    assert_eq!(
        ::std::mem::align_of::<_FLOAT128>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLOAT128))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOAT128),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOAT128),
            "::",
            stringify!(HighPart)
        )
    );
}
pub type FLOAT128 = _FLOAT128;
pub type PFLOAT128 = *mut FLOAT128;
pub type LONGLONG = ::std::os::raw::c_longlong;
pub type ULONGLONG = ::std::os::raw::c_ulonglong;
pub type PLONGLONG = *mut LONGLONG;
pub type PULONGLONG = *mut ULONGLONG;
pub type USN = LONGLONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_LARGE_INTEGER__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(HighPart)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_LARGE_INTEGER__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(HighPart)
        )
    );
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER() {
    const UNINIT: ::std::mem::MaybeUninit<_LARGE_INTEGER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER))
    );
    assert_eq!(
        ::std::mem::align_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QuadPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER),
            "::",
            stringify!(QuadPart)
        )
    );
}
pub type LARGE_INTEGER = _LARGE_INTEGER;
pub type PLARGE_INTEGER = *mut LARGE_INTEGER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
    pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
    pub u: _ULARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: DWORD,
    pub HighPart: DWORD,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_ULARGE_INTEGER__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(HighPart)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: DWORD,
    pub HighPart: DWORD,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_ULARGE_INTEGER__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(HighPart)
        )
    );
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER() {
    const UNINIT: ::std::mem::MaybeUninit<_ULARGE_INTEGER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ULARGE_INTEGER>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER))
    );
    assert_eq!(
        ::std::mem::align_of::<_ULARGE_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QuadPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER),
            "::",
            stringify!(QuadPart)
        )
    );
}
pub type ULARGE_INTEGER = _ULARGE_INTEGER;
pub type PULARGE_INTEGER = *mut ULARGE_INTEGER;
pub type RTL_REFERENCE_COUNT = LONG_PTR;
pub type PRTL_REFERENCE_COUNT = *mut LONG_PTR;
pub type RTL_REFERENCE_COUNT32 = LONG;
pub type PRTL_REFERENCE_COUNT32 = *mut LONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LUID() {
    const UNINIT: ::std::mem::MaybeUninit<_LUID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LUID>(),
        8usize,
        concat!("Size of: ", stringify!(_LUID))
    );
    assert_eq!(
        ::std::mem::align_of::<_LUID>(),
        4usize,
        concat!("Alignment of ", stringify!(_LUID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LUID),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LUID),
            "::",
            stringify!(HighPart)
        )
    );
}
pub type LUID = _LUID;
pub type PLUID = *mut _LUID;
pub type DWORDLONG = ULONGLONG;
pub type PDWORDLONG = *mut DWORDLONG;
extern "C" {
    pub fn _rotl8(
        Value: ::std::os::raw::c_uchar,
        Shift: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _rotl16(
        Value: ::std::os::raw::c_ushort,
        Shift: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _rotr8(
        Value: ::std::os::raw::c_uchar,
        Shift: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _rotr16(
        Value: ::std::os::raw::c_ushort,
        Shift: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _rotl(
        Value: ::std::os::raw::c_uint,
        Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _rotr(
        Value: ::std::os::raw::c_uint,
        Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _rotl64(
        Value: ::std::os::raw::c_ulonglong,
        Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr64(
        Value: ::std::os::raw::c_ulonglong,
        Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
pub type BOOLEAN = BYTE;
pub type PBOOLEAN = *mut BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LIST_ENTRY {
    pub Flink: *mut _LIST_ENTRY,
    pub Blink: *mut _LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__LIST_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_LIST_ENTRY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LIST_ENTRY>(),
        16usize,
        concat!("Size of: ", stringify!(_LIST_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_LIST_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_LIST_ENTRY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flink) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LIST_ENTRY),
            "::",
            stringify!(Flink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Blink) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_LIST_ENTRY),
            "::",
            stringify!(Blink)
        )
    );
}
pub type LIST_ENTRY = _LIST_ENTRY;
pub type PLIST_ENTRY = *mut _LIST_ENTRY;
pub type PRLIST_ENTRY = *mut _LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SINGLE_LIST_ENTRY {
    pub Next: *mut _SINGLE_LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__SINGLE_LIST_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_SINGLE_LIST_ENTRY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SINGLE_LIST_ENTRY>(),
        8usize,
        concat!("Size of: ", stringify!(_SINGLE_LIST_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SINGLE_LIST_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_SINGLE_LIST_ENTRY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SINGLE_LIST_ENTRY),
            "::",
            stringify!(Next)
        )
    );
}
pub type SINGLE_LIST_ENTRY = _SINGLE_LIST_ENTRY;
pub type PSINGLE_LIST_ENTRY = *mut _SINGLE_LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LIST_ENTRY32 {
    pub Flink: DWORD,
    pub Blink: DWORD,
}
#[test]
fn bindgen_test_layout_LIST_ENTRY32() {
    const UNINIT: ::std::mem::MaybeUninit<LIST_ENTRY32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LIST_ENTRY32>(),
        8usize,
        concat!("Size of: ", stringify!(LIST_ENTRY32))
    );
    assert_eq!(
        ::std::mem::align_of::<LIST_ENTRY32>(),
        4usize,
        concat!("Alignment of ", stringify!(LIST_ENTRY32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flink) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LIST_ENTRY32),
            "::",
            stringify!(Flink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Blink) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LIST_ENTRY32),
            "::",
            stringify!(Blink)
        )
    );
}
pub type PLIST_ENTRY32 = *mut LIST_ENTRY32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LIST_ENTRY64 {
    pub Flink: ULONGLONG,
    pub Blink: ULONGLONG,
}
#[test]
fn bindgen_test_layout_LIST_ENTRY64() {
    const UNINIT: ::std::mem::MaybeUninit<LIST_ENTRY64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LIST_ENTRY64>(),
        16usize,
        concat!("Size of: ", stringify!(LIST_ENTRY64))
    );
    assert_eq!(
        ::std::mem::align_of::<LIST_ENTRY64>(),
        8usize,
        concat!("Alignment of ", stringify!(LIST_ENTRY64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flink) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LIST_ENTRY64),
            "::",
            stringify!(Flink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Blink) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LIST_ENTRY64),
            "::",
            stringify!(Blink)
        )
    );
}
pub type PLIST_ENTRY64 = *mut LIST_ENTRY64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUID {
    pub Data1: ::std::os::raw::c_ulong,
    pub Data2: ::std::os::raw::c_ushort,
    pub Data3: ::std::os::raw::c_ushort,
    pub Data4: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout__GUID() {
    const UNINIT: ::std::mem::MaybeUninit<_GUID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUID>(),
        16usize,
        concat!("Size of: ", stringify!(_GUID))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUID>(),
        4usize,
        concat!("Alignment of ", stringify!(_GUID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data3) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data4) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data4)
        )
    );
}
pub type GUID = _GUID;
pub type LPGUID = *mut GUID;
pub type LPCGUID = *const GUID;
pub type IID = GUID;
pub type LPIID = *mut IID;
pub type CLSID = GUID;
pub type LPCLSID = *mut CLSID;
pub type FMTID = GUID;
pub type LPFMTID = *mut FMTID;
extern "C" {
    pub fn _memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memchr(
        _Buf: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _memicmp_l(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcpy_s(
        _dest: *mut ::std::os::raw::c_void,
        _numberOfElements: usize,
        _src: *const ::std::os::raw::c_void,
        _count: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn mempcpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        _Dst: *mut ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strset(
        _Str: *mut ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strset_l(
        _Str: *mut ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcpy(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlen(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strnlen(_Str: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn memmove(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _strdup(_Src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        _Str: *const ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _stricmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcmpi(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricmp_l(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcoll_l(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll_l(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll_l(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll_l(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strerror(_ErrMsg: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlwr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp_l(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strnset(
        _Str: *mut ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strnset_l(
        str_: *mut ::std::os::raw::c_char,
        c: ::std::os::raw::c_int,
        count: usize,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        _Str: *const ::std::os::raw::c_char,
        _Ch: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strrev(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strstr(
        _Str: *const ::std::os::raw::c_char,
        _SubStr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        _Str: *mut ::std::os::raw::c_char,
        _Delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        _Str: *mut ::std::os::raw::c_char,
        _Delim: *const ::std::os::raw::c_char,
        __last: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        _Dst: *mut ::std::os::raw::c_char,
        _Src: *const ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strxfrm_l(
        _Dst: *mut ::std::os::raw::c_char,
        _Src: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(_Src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmpi(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stricmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlwr(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnicmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strnset(
        _Str: *mut ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrev(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strset(
        _Str: *mut ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strupr(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _wcsdup(_Str: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(_Dest: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcschr(
        _Str: *const ::std::os::raw::c_ushort,
        _Ch: ::std::os::raw::c_ushort,
    ) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn wcscmp(
        _Str1: *const ::std::os::raw::c_ushort,
        _Str2: *const ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscpy(_Dest: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(_Str: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcslen(_Str: *const ::std::os::raw::c_ushort) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcsnlen(_Src: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn wcsncat(_Dest: *mut wchar_t, _Source: *const wchar_t, _Count: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncmp(
        _Str1: *const ::std::os::raw::c_ushort,
        _Str2: *const ::std::os::raw::c_ushort,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncpy(_Dest: *mut wchar_t, _Source: *const wchar_t, _Count: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsncpy_l(
        _Dest: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
        _Locale: _locale_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcspbrk(_Str: *const wchar_t, _Control: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsspn(_Str: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstok(_Str: *mut wchar_t, _Delim: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror(_ErrNum: ::std::os::raw::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn __wcserror(_Str: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsicmp(_Str1: *const wchar_t, _Str2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(
        _Str1: *const wchar_t,
        _Str2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp(
        _Str1: *const wchar_t,
        _Str2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(
        _Str1: *const wchar_t,
        _Str2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnset(_Str: *mut wchar_t, _Val: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsrev(_Str: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsset(_Str: *mut wchar_t, _Val: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsxfrm(_Dst: *mut wchar_t, _Src: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _wcsxfrm_l(
        _Dst: *mut wchar_t,
        _Src: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wcscoll(_Str1: *const wchar_t, _Str2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcscoll_l(
        _Str1: *const wchar_t,
        _Str2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll(_Str1: *const wchar_t, _Str2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(
        _Str1: *const wchar_t,
        _Str2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll(
        _Str1: *const wchar_t,
        _Str2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(
        _Str1: *const wchar_t,
        _Str2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll(
        _Str1: *const wchar_t,
        _Str2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(
        _Str1: *const wchar_t,
        _Str2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsdup(_Str: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicmp(_Str1: *const wchar_t, _Str2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnicmp(
        _Str1: *const wchar_t,
        _Str2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnset(_Str: *mut wchar_t, _Val: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrev(_Str: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsset(_Str: *mut wchar_t, _Val: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslwr(_Str: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsupr(_Str: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicoll(_Str1: *const wchar_t, _Str2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strset_s(
        _Dst: *mut ::std::os::raw::c_char,
        _DstSize: usize,
        _Value: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _strerror_s(
        _Buf: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrMsg: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror_s(
        _Buf: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrNum: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _strlwr_s(_Str: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strlwr_s_l(
        _Str: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strnset_s(
        _Str: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _strupr_s(_Str: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strupr_s_l(
        _Str: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strncat_s(
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInChars: usize,
        _Src: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _strncat_s_l(
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInChars: usize,
        _Src: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strcpy_s(
        _Dst: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Src: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strncpy_s(
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInChars: usize,
        _Src: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _strncpy_s_l(
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInChars: usize,
        _Src: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strtok_s(
        _Str: *mut ::std::os::raw::c_char,
        _Delim: *const ::std::os::raw::c_char,
        _Context: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strtok_s_l(
        _Str: *mut ::std::os::raw::c_char,
        _Delim: *const ::std::os::raw::c_char,
        _Context: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat_s(
        _Dst: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Src: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn memmove_s(
        _dest: *mut ::std::os::raw::c_void,
        _numberOfElements: usize,
        _src: *const ::std::os::raw::c_void,
        _count: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(
        _Str: *mut wchar_t,
        _Delim: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror_s(
        _Buf: *mut wchar_t,
        _SizeInWords: usize,
        _ErrNum: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn __wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrMsg: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset_s(
        _Dst: *mut wchar_t,
        _DstSizeInWords: usize,
        _Val: wchar_t,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsset_s(_Str: *mut wchar_t, _SizeInWords: usize, _Val: wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_s(_Str: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_s_l(_Str: *mut wchar_t, _SizeInWords: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_s(_Str: *mut wchar_t, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_s_l(_Str: *mut wchar_t, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(_Dst: *mut wchar_t, _SizeInWords: rsize_t, _Src: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn wcscat_s(_Dst: *mut wchar_t, _SizeInWords: rsize_t, _Src: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(
        _Dst: *mut wchar_t,
        _DstSizeInChars: usize,
        _Src: *const wchar_t,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsncat_s_l(
        _Dst: *mut wchar_t,
        _DstSizeInChars: usize,
        _Src: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(
        _Dst: *mut wchar_t,
        _DstSizeInChars: usize,
        _Src: *const wchar_t,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsncpy_s_l(
        _Dst: *mut wchar_t,
        _DstSizeInChars: usize,
        _Src: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstok_s_l(
        _Str: *mut wchar_t,
        _Delim: *const wchar_t,
        _Context: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsset_s_l(
        _Str: *mut wchar_t,
        _SizeInChars: usize,
        _Val: wchar_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset_s_l(
        _Str: *mut wchar_t,
        _SizeInChars: usize,
        _Val: wchar_t,
        _Count: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECTID {
    pub Lineage: GUID,
    pub Uniquifier: DWORD,
}
#[test]
fn bindgen_test_layout__OBJECTID() {
    const UNINIT: ::std::mem::MaybeUninit<_OBJECTID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OBJECTID>(),
        20usize,
        concat!("Size of: ", stringify!(_OBJECTID))
    );
    assert_eq!(
        ::std::mem::align_of::<_OBJECTID>(),
        4usize,
        concat!("Alignment of ", stringify!(_OBJECTID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Lineage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECTID),
            "::",
            stringify!(Lineage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Uniquifier) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECTID),
            "::",
            stringify!(Uniquifier)
        )
    );
}
pub type OBJECTID = _OBJECTID;
pub type PEXCEPTION_ROUTINE = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut _EXCEPTION_RECORD,
        arg2: PVOID,
        arg3: *mut _CONTEXT,
        arg4: PVOID,
    ) -> ::std::os::raw::c_int,
>;
pub type KSPIN_LOCK = ULONG_PTR;
pub type PKSPIN_LOCK = *mut KSPIN_LOCK;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _M128A {
    pub Low: ULONGLONG,
    pub High: LONGLONG,
}
#[test]
fn bindgen_test_layout__M128A() {
    const UNINIT: ::std::mem::MaybeUninit<_M128A> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_M128A>(),
        16usize,
        concat!("Size of: ", stringify!(_M128A))
    );
    assert_eq!(
        ::std::mem::align_of::<_M128A>(),
        16usize,
        concat!("Alignment of ", stringify!(_M128A))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_M128A),
            "::",
            stringify!(Low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).High) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_M128A),
            "::",
            stringify!(High)
        )
    );
}
pub type M128A = _M128A;
pub type PM128A = *mut _M128A;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_FORMAT {
    pub ControlWord: WORD,
    pub StatusWord: WORD,
    pub TagWord: BYTE,
    pub Reserved1: BYTE,
    pub ErrorOpcode: WORD,
    pub ErrorOffset: DWORD,
    pub ErrorSelector: WORD,
    pub Reserved2: WORD,
    pub DataOffset: DWORD,
    pub DataSelector: WORD,
    pub Reserved3: WORD,
    pub MxCsr: DWORD,
    pub MxCsr_Mask: DWORD,
    pub FloatRegisters: [M128A; 8usize],
    pub XmmRegisters: [M128A; 16usize],
    pub Reserved4: [BYTE; 96usize],
}
#[test]
fn bindgen_test_layout__XSAVE_FORMAT() {
    const UNINIT: ::std::mem::MaybeUninit<_XSAVE_FORMAT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_XSAVE_FORMAT>(),
        512usize,
        concat!("Size of: ", stringify!(_XSAVE_FORMAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_XSAVE_FORMAT>(),
        16usize,
        concat!("Alignment of ", stringify!(_XSAVE_FORMAT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ControlWord) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(ControlWord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatusWord) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(StatusWord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TagWord) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(TagWord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ErrorOpcode) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(ErrorOpcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ErrorOffset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(ErrorOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ErrorSelector) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(ErrorSelector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(DataOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataSelector) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(DataSelector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MxCsr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(MxCsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MxCsr_Mask) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(MxCsr_Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FloatRegisters) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(FloatRegisters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).XmmRegisters) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(XmmRegisters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(Reserved4)
        )
    );
}
pub type XSAVE_FORMAT = _XSAVE_FORMAT;
pub type PXSAVE_FORMAT = *mut _XSAVE_FORMAT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_CET_U_FORMAT {
    pub Ia32CetUMsr: DWORD64,
    pub Ia32Pl3SspMsr: DWORD64,
}
#[test]
fn bindgen_test_layout__XSAVE_CET_U_FORMAT() {
    const UNINIT: ::std::mem::MaybeUninit<_XSAVE_CET_U_FORMAT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_XSAVE_CET_U_FORMAT>(),
        16usize,
        concat!("Size of: ", stringify!(_XSAVE_CET_U_FORMAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_XSAVE_CET_U_FORMAT>(),
        8usize,
        concat!("Alignment of ", stringify!(_XSAVE_CET_U_FORMAT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ia32CetUMsr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_CET_U_FORMAT),
            "::",
            stringify!(Ia32CetUMsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ia32Pl3SspMsr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_CET_U_FORMAT),
            "::",
            stringify!(Ia32Pl3SspMsr)
        )
    );
}
pub type XSAVE_CET_U_FORMAT = _XSAVE_CET_U_FORMAT;
pub type PXSAVE_CET_U_FORMAT = *mut _XSAVE_CET_U_FORMAT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_AREA_HEADER {
    pub Mask: DWORD64,
    pub Reserved: [DWORD64; 7usize],
}
#[test]
fn bindgen_test_layout__XSAVE_AREA_HEADER() {
    const UNINIT: ::std::mem::MaybeUninit<_XSAVE_AREA_HEADER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_XSAVE_AREA_HEADER>(),
        64usize,
        concat!("Size of: ", stringify!(_XSAVE_AREA_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_XSAVE_AREA_HEADER>(),
        8usize,
        concat!("Alignment of ", stringify!(_XSAVE_AREA_HEADER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_AREA_HEADER),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_AREA_HEADER),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type XSAVE_AREA_HEADER = _XSAVE_AREA_HEADER;
pub type PXSAVE_AREA_HEADER = *mut _XSAVE_AREA_HEADER;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_AREA {
    pub LegacyState: XSAVE_FORMAT,
    pub Header: XSAVE_AREA_HEADER,
}
#[test]
fn bindgen_test_layout__XSAVE_AREA() {
    const UNINIT: ::std::mem::MaybeUninit<_XSAVE_AREA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_XSAVE_AREA>(),
        576usize,
        concat!("Size of: ", stringify!(_XSAVE_AREA))
    );
    assert_eq!(
        ::std::mem::align_of::<_XSAVE_AREA>(),
        16usize,
        concat!("Alignment of ", stringify!(_XSAVE_AREA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LegacyState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_AREA),
            "::",
            stringify!(LegacyState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_AREA),
            "::",
            stringify!(Header)
        )
    );
}
pub type XSAVE_AREA = _XSAVE_AREA;
pub type PXSAVE_AREA = *mut _XSAVE_AREA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSTATE_CONTEXT {
    pub Mask: DWORD64,
    pub Length: DWORD,
    pub Reserved1: DWORD,
    pub Area: PXSAVE_AREA,
    pub Buffer: PVOID,
}
#[test]
fn bindgen_test_layout__XSTATE_CONTEXT() {
    const UNINIT: ::std::mem::MaybeUninit<_XSTATE_CONTEXT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_XSTATE_CONTEXT>(),
        32usize,
        concat!("Size of: ", stringify!(_XSTATE_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<_XSTATE_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_XSTATE_CONTEXT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONTEXT),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONTEXT),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONTEXT),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONTEXT),
            "::",
            stringify!(Area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONTEXT),
            "::",
            stringify!(Buffer)
        )
    );
}
pub type XSTATE_CONTEXT = _XSTATE_CONTEXT;
pub type PXSTATE_CONTEXT = *mut _XSTATE_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KERNEL_CET_CONTEXT {
    pub Ssp: DWORD64,
    pub Rip: DWORD64,
    pub SegCs: WORD,
    pub __bindgen_anon_1: _KERNEL_CET_CONTEXT__bindgen_ty_1,
    pub Fill: [WORD; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KERNEL_CET_CONTEXT__bindgen_ty_1 {
    pub AllFlags: WORD,
    pub __bindgen_anon_1: _KERNEL_CET_CONTEXT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KERNEL_CET_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout__KERNEL_CET_CONTEXT__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_KERNEL_CET_CONTEXT__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(_KERNEL_CET_CONTEXT__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_KERNEL_CET_CONTEXT__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_KERNEL_CET_CONTEXT__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _KERNEL_CET_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn UseWrss(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UseWrss(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PopShadowStackOne(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PopShadowStackOne(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Unused(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_Unused(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UseWrss: WORD,
        PopShadowStackOne: WORD,
        Unused: WORD,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UseWrss: u16 = unsafe { ::std::mem::transmute(UseWrss) };
            UseWrss as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PopShadowStackOne: u16 = unsafe { ::std::mem::transmute(PopShadowStackOne) };
            PopShadowStackOne as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let Unused: u16 = unsafe { ::std::mem::transmute(Unused) };
            Unused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__KERNEL_CET_CONTEXT__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_KERNEL_CET_CONTEXT__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_KERNEL_CET_CONTEXT__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(_KERNEL_CET_CONTEXT__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_KERNEL_CET_CONTEXT__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_KERNEL_CET_CONTEXT__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KERNEL_CET_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(AllFlags)
        )
    );
}
#[test]
fn bindgen_test_layout__KERNEL_CET_CONTEXT() {
    const UNINIT: ::std::mem::MaybeUninit<_KERNEL_CET_CONTEXT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_KERNEL_CET_CONTEXT>(),
        24usize,
        concat!("Size of: ", stringify!(_KERNEL_CET_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<_KERNEL_CET_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_KERNEL_CET_CONTEXT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ssp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KERNEL_CET_CONTEXT),
            "::",
            stringify!(Ssp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rip) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KERNEL_CET_CONTEXT),
            "::",
            stringify!(Rip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SegCs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KERNEL_CET_CONTEXT),
            "::",
            stringify!(SegCs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Fill) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KERNEL_CET_CONTEXT),
            "::",
            stringify!(Fill)
        )
    );
}
pub type KERNEL_CET_CONTEXT = _KERNEL_CET_CONTEXT;
pub type PKERNEL_CET_CONTEXT = *mut _KERNEL_CET_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_AMD64 {
    pub Count: DWORD,
    pub ScopeRecord: [_SCOPE_TABLE_AMD64__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_AMD64__bindgen_ty_1 {
    pub BeginAddress: DWORD,
    pub EndAddress: DWORD,
    pub HandlerAddress: DWORD,
    pub JumpTarget: DWORD,
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_AMD64__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SCOPE_TABLE_AMD64__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SCOPE_TABLE_AMD64__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SCOPE_TABLE_AMD64__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BeginAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1),
            "::",
            stringify!(BeginAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndAddress) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1),
            "::",
            stringify!(EndAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HandlerAddress) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1),
            "::",
            stringify!(HandlerAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JumpTarget) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1),
            "::",
            stringify!(JumpTarget)
        )
    );
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_AMD64() {
    const UNINIT: ::std::mem::MaybeUninit<_SCOPE_TABLE_AMD64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SCOPE_TABLE_AMD64>(),
        20usize,
        concat!("Size of: ", stringify!(_SCOPE_TABLE_AMD64))
    );
    assert_eq!(
        ::std::mem::align_of::<_SCOPE_TABLE_AMD64>(),
        4usize,
        concat!("Alignment of ", stringify!(_SCOPE_TABLE_AMD64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_AMD64),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ScopeRecord) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_AMD64),
            "::",
            stringify!(ScopeRecord)
        )
    );
}
pub type SCOPE_TABLE_AMD64 = _SCOPE_TABLE_AMD64;
pub type PSCOPE_TABLE_AMD64 = *mut _SCOPE_TABLE_AMD64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __uintr_frame {
    pub rip: ::std::os::raw::c_ulonglong,
    pub rflags: ::std::os::raw::c_ulonglong,
    pub rsp: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout___uintr_frame() {
    const UNINIT: ::std::mem::MaybeUninit<__uintr_frame> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__uintr_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__uintr_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__uintr_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__uintr_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rip) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__uintr_frame),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rflags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__uintr_frame),
            "::",
            stringify!(rflags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__uintr_frame),
            "::",
            stringify!(rsp)
        )
    );
}
pub const _CMPCCX_ENUM__CMPCCX_O: _CMPCCX_ENUM = 0;
pub const _CMPCCX_ENUM__CMPCCX_NO: _CMPCCX_ENUM = 1;
pub const _CMPCCX_ENUM__CMPCCX_B: _CMPCCX_ENUM = 2;
pub const _CMPCCX_ENUM__CMPCCX_NB: _CMPCCX_ENUM = 3;
pub const _CMPCCX_ENUM__CMPCCX_Z: _CMPCCX_ENUM = 4;
pub const _CMPCCX_ENUM__CMPCCX_NZ: _CMPCCX_ENUM = 5;
pub const _CMPCCX_ENUM__CMPCCX_BE: _CMPCCX_ENUM = 6;
pub const _CMPCCX_ENUM__CMPCCX_NBE: _CMPCCX_ENUM = 7;
pub const _CMPCCX_ENUM__CMPCCX_S: _CMPCCX_ENUM = 8;
pub const _CMPCCX_ENUM__CMPCCX_NS: _CMPCCX_ENUM = 9;
pub const _CMPCCX_ENUM__CMPCCX_P: _CMPCCX_ENUM = 10;
pub const _CMPCCX_ENUM__CMPCCX_NP: _CMPCCX_ENUM = 11;
pub const _CMPCCX_ENUM__CMPCCX_L: _CMPCCX_ENUM = 12;
pub const _CMPCCX_ENUM__CMPCCX_NL: _CMPCCX_ENUM = 13;
pub const _CMPCCX_ENUM__CMPCCX_LE: _CMPCCX_ENUM = 14;
pub const _CMPCCX_ENUM__CMPCCX_NLE: _CMPCCX_ENUM = 15;
pub type _CMPCCX_ENUM = ::std::os::raw::c_uint;
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128_u = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
extern "C" {
    pub fn _itow_s(
        _Val: ::std::os::raw::c_int,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltow_s(
        _Val: ::std::os::raw::c_long,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultow_s(
        _Val: ::std::os::raw::c_ulong,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _wgetenv_s(
        _ReturnSize: *mut usize,
        _DstBuf: *mut wchar_t,
        _DstSizeInWords: usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wdupenv_s(
        _Buffer: *mut *mut wchar_t,
        _BufferSizeInWords: *mut usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64tow_s(
        _Val: ::std::os::raw::c_longlong,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64tow_s(
        _Val: ::std::os::raw::c_ulonglong,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _wmakepath_s(
        _PathResult: *mut wchar_t,
        _SizeInWords: usize,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wputenv_s(_Name: *const wchar_t, _Value: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv_s(
        _Filename: *const wchar_t,
        _EnvVar: *const wchar_t,
        _ResultPath: *mut wchar_t,
        _SizeInWords: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsplitpath_s(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _DriveSizeInWords: usize,
        _Dir: *mut wchar_t,
        _DirSizeInWords: usize,
        _Filename: *mut wchar_t,
        _FilenameSizeInWords: usize,
        _Ext: *mut wchar_t,
        _ExtSizeInWords: usize,
    ) -> errno_t;
}
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__div_t() {
    const UNINIT: ::std::mem::MaybeUninit<_div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_div_t>(),
        8usize,
        concat!("Size of: ", stringify!(_div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout__LDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDOUBLE>(),
        10usize,
        concat!("Size of: ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDOUBLE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDOUBLE),
            "::",
            stringify!(ld)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__CRT_DOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_DOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_DOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[test]
fn bindgen_test_layout__CRT_FLOAT() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_FLOAT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Size of: ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_FLOAT),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _LONGDOUBLE {
    pub x: u128,
}
#[test]
fn bindgen_test_layout__LONGDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LONGDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LONGDOUBLE>(),
        16usize,
        concat!("Size of: ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LONGDOUBLE>(),
        16usize,
        concat!("Alignment of ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LONGDOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
#[test]
fn bindgen_test_layout__LDBL12() {
    const UNINIT: ::std::mem::MaybeUninit<_LDBL12> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDBL12>(),
        12usize,
        concat!("Size of: ", stringify!(_LDBL12))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDBL12>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDBL12))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld12) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDBL12),
            "::",
            stringify!(ld12)
        )
    );
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const wchar_t,
        arg2: *const wchar_t,
        arg3: *const wchar_t,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn _set_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub static mut _sys_errlist: [*mut ::std::os::raw::c_char; 1usize];
}
extern "C" {
    pub static mut _sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p___argv() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__fmode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut wchar_t) -> errno_t;
}
extern "C" {
    pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub static mut __imp___argc: *mut ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __imp___argv: *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __imp___wargv: *mut *mut *mut wchar_t;
}
extern "C" {
    pub static mut __imp__environ: *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __imp__wenviron: *mut *mut *mut wchar_t;
}
extern "C" {
    pub static mut __imp__pgmptr: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __imp__wpgmptr: *mut *mut wchar_t;
}
extern "C" {
    pub static mut __imp__osplatform: *mut ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut __imp__osver: *mut ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut __imp__winver: *mut ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut __imp__winmajor: *mut ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut __imp__winminor: *mut ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _get_osplatform(_Value: *mut ::std::os::raw::c_uint) -> errno_t;
}
extern "C" {
    pub fn _get_osver(_Value: *mut ::std::os::raw::c_uint) -> errno_t;
}
extern "C" {
    pub fn _get_winver(_Value: *mut ::std::os::raw::c_uint) -> errno_t;
}
extern "C" {
    pub fn _get_winmajor(_Value: *mut ::std::os::raw::c_uint) -> errno_t;
}
extern "C" {
    pub fn _get_winminor(_Value: *mut ::std::os::raw::c_uint) -> errno_t;
}
extern "C" {
    pub fn exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn _set_abort_behavior(
        _Flags: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn abs(_X: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(_X: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn atoi(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoi_l(
        _Str: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atol_l(
        _Str: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn bsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn _byteswap_ushort(_Short: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Long: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Int64: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _itoa(
        _Value: ::std::os::raw::c_int,
        _Dest: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _i64toa(
        _Val: ::std::os::raw::c_longlong,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ui64toa(
        _Val: ::std::os::raw::c_ulonglong,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoui64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long)
        -> ldiv_t;
}
extern "C" {
    pub fn _ltoa(
        _Value: ::std::os::raw::c_long,
        _Dest: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_l(
        _Ch: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(_Str: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _mbstrlen_l(_Str: *const ::std::os::raw::c_char, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn _mbstrnlen(_Str: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _mbstrnlen_l(
        _Str: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn mbtowc(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_l(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _mbstowcs_l(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn mkstemp(template_name: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn __strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn __mingw_strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn __mingw_strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn __mingw_strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn _strtof_l(
        _Str: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn _strtod_l(
        _Str: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        _Str: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_l(
        _Str: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        _Str: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(
        _Str: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Dest: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_l(
        _MbCh: *mut ::std::os::raw::c_char,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _wcstombs_l(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn calloc(
        _NumOfElements: ::std::os::raw::c_ulonglong,
        _SizeOfElements: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(_Memory: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn malloc(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        _Memory: *mut ::std::os::raw::c_void,
        _NewSize: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Memory: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Memory: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Memory: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _itow(
        _Value: ::std::os::raw::c_int,
        _Dest: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ltow(
        _Value: ::std::os::raw::c_long,
        _Dest: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ultow(
        _Value: ::std::os::raw::c_ulong,
        _Dest: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn __mingw_wcstod(_Str: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn __mingw_wcstof(nptr: *const wchar_t, endptr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn __mingw_wcstold(arg1: *const wchar_t, arg2: *mut *mut wchar_t) -> u128;
}
extern "C" {
    pub fn wcstold(arg1: *const wchar_t, arg2: *mut *mut wchar_t) -> u128;
}
extern "C" {
    pub fn _wcstod_l(_Str: *const wchar_t, _EndPtr: *mut *mut wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wcstof_l(_Str: *const wchar_t, _EndPtr: *mut *mut wchar_t, _Locale: _locale_t) -> f32;
}
extern "C" {
    pub fn wcstol(
        _Str: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wcstol_l(
        _Str: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoul(
        _Str: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(
        _Str: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wsystem(_Command: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtof(_Str: *const wchar_t) -> f64;
}
extern "C" {
    pub fn _wtof_l(_Str: *const wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_Str: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtoi_l(_Str: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtol(_Str: *const wchar_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtol_l(_Str: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _i64tow(
        _Val: ::std::os::raw::c_longlong,
        _DstBuf: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ui64tow(
        _Val: ::std::os::raw::c_ulonglong,
        _DstBuf: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtoi64(_Str: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_Str: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(
        _Str: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(
        _Str: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(
        _Str: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(
        _Str: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wputenv(_EnvString: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fullpath(
        _FullPath: *mut ::std::os::raw::c_char,
        _Path: *const ::std::os::raw::c_char,
        _SizeInBytes: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt(
        _Val: f64,
        _NumOfDigits: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt(
        _Val: f64,
        _NumOfDec: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _gcvt(
        _Val: f64,
        _NumOfDigits: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _atodbl(
        _Result: *mut _CRT_DOUBLE,
        _Str: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl(
        _Result: *mut _LDOUBLE,
        _Str: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt(
        _Result: *mut _CRT_FLOAT,
        _Str: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl_l(
        _Result: *mut _CRT_DOUBLE,
        _Str: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl_l(
        _Result: *mut _LDOUBLE,
        _Str: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt_l(
        _Result: *mut _CRT_FLOAT,
        _Str: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _lrotl(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _lrotr(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _makepath(
        _Path: *mut ::std::os::raw::c_char,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn perror(_ErrMsg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn _searchenv(
        _Filename: *const ::std::os::raw::c_char,
        _EnvVar: *const ::std::os::raw::c_char,
        _ResultPath: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _Dir: *mut ::std::os::raw::c_char,
        _Filename: *mut ::std::os::raw::c_char,
        _Ext: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn _wfullpath(
        _FullPath: *mut wchar_t,
        _Path: *const wchar_t,
        _SizeInWords: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wmakepath(
        _ResultPath: *mut wchar_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    );
}
extern "C" {
    pub fn _wperror(_ErrMsg: *const wchar_t);
}
extern "C" {
    pub fn _wsearchenv(
        _Filename: *const wchar_t,
        _EnvVar: *const wchar_t,
        _ResultPath: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _Dir: *mut wchar_t,
        _Filename: *mut wchar_t,
        _Ext: *mut wchar_t,
    );
}
extern "C" {
    pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ecvt(
        _Val: f64,
        _NumOfDigits: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        _Val: f64,
        _NumOfDec: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        _Val: f64,
        _NumOfDigits: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        _Val: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ltoa(
        _Val: ::std::os::raw::c_long,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ultoa(
        _Val: ::std::os::raw::c_ulong,
        _Dstbuf: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoll(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wtoll(arg1: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lltoa(
        arg1: ::std::os::raw::c_longlong,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ulltoa(
        arg1: ::std::os::raw::c_ulonglong,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lltow(
        arg1: ::std::os::raw::c_longlong,
        arg2: *mut wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn ulltow(
        arg1: ::std::os::raw::c_ulonglong,
        arg2: *mut wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn bsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _dupenv_s(
        _PBuffer: *mut *mut ::std::os::raw::c_char,
        _PBufferSizeInBytes: *mut usize,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn getenv_s(
        _ReturnSize: *mut usize,
        _DstBuf: *mut ::std::os::raw::c_char,
        _DstSize: rsize_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _itoa_s(
        _Value: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64toa_s(
        _Val: ::std::os::raw::c_longlong,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64toa_s(
        _Val: ::std::os::raw::c_ulonglong,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltoa_s(
        _Val: ::std::os::raw::c_long,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _mbstowcs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultoa_s(
        _Val: ::std::os::raw::c_ulong,
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn wctomb_s(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _WCh: wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctomb_s_l(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstombs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _ecvt_s(
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Val: f64,
        _NumOfDights: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _fcvt_s(
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Val: f64,
        _NumOfDec: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _gcvt_s(
        _DstBuf: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Val: f64,
        _NumOfDigits: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _makepath_s(
        _PathResult: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _putenv_s(
        _Name: *const ::std::os::raw::c_char,
        _Value: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv_s(
        _Filename: *const ::std::os::raw::c_char,
        _EnvVar: *const ::std::os::raw::c_char,
        _ResultPath: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _splitpath_s(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _DriveSize: usize,
        _Dir: *mut ::std::os::raw::c_char,
        _DirSize: usize,
        _Filename: *mut ::std::os::raw::c_char,
        _FilenameSize: usize,
        _Ext: *mut ::std::os::raw::c_char,
        _ExtSize: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn qsort_s(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _PtFuncCompare: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        _Context: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _heapinfo {
    pub _pentry: *mut ::std::os::raw::c_int,
    pub _size: usize,
    pub _useflag: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__heapinfo() {
    const UNINIT: ::std::mem::MaybeUninit<_heapinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_heapinfo>(),
        24usize,
        concat!("Size of: ", stringify!(_heapinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_heapinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_heapinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pentry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_heapinfo),
            "::",
            stringify!(_pentry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_heapinfo),
            "::",
            stringify!(_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._useflag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_heapinfo),
            "::",
            stringify!(_useflag)
        )
    );
}
pub type _HEAPINFO = _heapinfo;
extern "C" {
    pub static mut _amblksiz: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __mingw_aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mingw_aligned_free(_Memory: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __mingw_aligned_offset_realloc(
        _Memory: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mingw_aligned_realloc(
        _Memory: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _resetstkoflw() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_malloc_crt_max_wait(_NewValue: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _expand(
        _Memory: *mut ::std::os::raw::c_void,
        _NewSize: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize(_Memory: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _get_sbh_threshold() -> usize;
}
extern "C" {
    pub fn _set_sbh_threshold(_NewValue: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_amblksiz(_Value: usize) -> errno_t;
}
extern "C" {
    pub fn _get_amblksiz(_Value: *mut usize) -> errno_t;
}
extern "C" {
    pub fn _heapadd(_Memory: *mut ::std::os::raw::c_void, _Size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapchk() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapset(_Fill: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapwalk(_EntryInfo: *mut _HEAPINFO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapused(_Used: *mut usize, _Commit: *mut usize) -> usize;
}
extern "C" {
    pub fn _get_heap_handle() -> isize;
}
extern "C" {
    pub fn _mm_sfence();
}
extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _mm_setcsr(__i: ::std::os::raw::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __m128d_u = [f64; 2usize];
pub type __m128i_u = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
pub type __v8hf = [__BindgenFloat16; 8usize];
pub type __m128h = [__BindgenFloat16; 8usize];
pub type __m128h_u = [__BindgenFloat16; 8usize];
pub type __v8bf = u128;
pub type __m128bh = u128;
extern "C" {
    pub fn _mm_clflush(__p: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mm_lfence();
}
extern "C" {
    pub fn _mm_mfence();
}
extern "C" {
    pub fn _mm_pause();
}
pub type __v4df = [f64; 4usize];
pub type __v8sf = [f32; 8usize];
pub type __v4di = [::std::os::raw::c_longlong; 4usize];
pub type __v8si = [::std::os::raw::c_int; 8usize];
pub type __v16hi = [::std::os::raw::c_short; 16usize];
pub type __v32qi = [::std::os::raw::c_char; 32usize];
pub type __v4du = [::std::os::raw::c_ulonglong; 4usize];
pub type __v8su = [::std::os::raw::c_uint; 8usize];
pub type __v16hu = [::std::os::raw::c_ushort; 16usize];
pub type __v32qu = [::std::os::raw::c_uchar; 32usize];
pub type __v32qs = [::std::os::raw::c_schar; 32usize];
pub type __m256 = [f32; 8usize];
pub type __m256d = [f64; 4usize];
pub type __m256i = [::std::os::raw::c_longlong; 4usize];
pub type __m256_u = [f32; 8usize];
pub type __m256d_u = [f64; 4usize];
pub type __m256i_u = [::std::os::raw::c_longlong; 4usize];
pub type __v16hf = [__BindgenFloat16; 16usize];
pub type __m256h = [__BindgenFloat16; 16usize];
pub type __m256h_u = [__BindgenFloat16; 16usize];
pub type __v16bf = [u8; 32usize];
pub type __m256bh = [u8; 32usize];
pub type __v64qi = [::std::os::raw::c_char; 64usize];
pub type __v32hi = [::std::os::raw::c_short; 32usize];
pub type __v8df = [f64; 8usize];
pub type __v16sf = [f32; 16usize];
pub type __v8di = [::std::os::raw::c_longlong; 8usize];
pub type __v16si = [::std::os::raw::c_int; 16usize];
pub type __v64qu = [::std::os::raw::c_uchar; 64usize];
pub type __v32hu = [::std::os::raw::c_ushort; 32usize];
pub type __v8du = [::std::os::raw::c_ulonglong; 8usize];
pub type __v16su = [::std::os::raw::c_uint; 16usize];
pub type __v64qs = [::std::os::raw::c_schar; 64usize];
pub type __m512 = [f32; 16usize];
pub type __m512d = [f64; 8usize];
pub type __m512i = [::std::os::raw::c_longlong; 8usize];
pub type __m512_u = [f32; 16usize];
pub type __m512d_u = [f64; 8usize];
pub type __m512i_u = [::std::os::raw::c_longlong; 8usize];
pub type __mmask8 = ::std::os::raw::c_uchar;
pub type __mmask16 = ::std::os::raw::c_ushort;
pub const _MM_CMPINT_ENUM__MM_CMPINT_EQ: _MM_CMPINT_ENUM = 0;
pub const _MM_CMPINT_ENUM__MM_CMPINT_LT: _MM_CMPINT_ENUM = 1;
pub const _MM_CMPINT_ENUM__MM_CMPINT_LE: _MM_CMPINT_ENUM = 2;
pub const _MM_CMPINT_ENUM__MM_CMPINT_UNUSED: _MM_CMPINT_ENUM = 3;
pub const _MM_CMPINT_ENUM__MM_CMPINT_NE: _MM_CMPINT_ENUM = 4;
pub const _MM_CMPINT_ENUM__MM_CMPINT_NLT: _MM_CMPINT_ENUM = 5;
pub const _MM_CMPINT_ENUM__MM_CMPINT_NLE: _MM_CMPINT_ENUM = 6;
pub type _MM_CMPINT_ENUM = ::std::os::raw::c_uint;
pub const _MM_PERM_ENUM__MM_PERM_AAAA: _MM_PERM_ENUM = 0;
pub const _MM_PERM_ENUM__MM_PERM_AAAB: _MM_PERM_ENUM = 1;
pub const _MM_PERM_ENUM__MM_PERM_AAAC: _MM_PERM_ENUM = 2;
pub const _MM_PERM_ENUM__MM_PERM_AAAD: _MM_PERM_ENUM = 3;
pub const _MM_PERM_ENUM__MM_PERM_AABA: _MM_PERM_ENUM = 4;
pub const _MM_PERM_ENUM__MM_PERM_AABB: _MM_PERM_ENUM = 5;
pub const _MM_PERM_ENUM__MM_PERM_AABC: _MM_PERM_ENUM = 6;
pub const _MM_PERM_ENUM__MM_PERM_AABD: _MM_PERM_ENUM = 7;
pub const _MM_PERM_ENUM__MM_PERM_AACA: _MM_PERM_ENUM = 8;
pub const _MM_PERM_ENUM__MM_PERM_AACB: _MM_PERM_ENUM = 9;
pub const _MM_PERM_ENUM__MM_PERM_AACC: _MM_PERM_ENUM = 10;
pub const _MM_PERM_ENUM__MM_PERM_AACD: _MM_PERM_ENUM = 11;
pub const _MM_PERM_ENUM__MM_PERM_AADA: _MM_PERM_ENUM = 12;
pub const _MM_PERM_ENUM__MM_PERM_AADB: _MM_PERM_ENUM = 13;
pub const _MM_PERM_ENUM__MM_PERM_AADC: _MM_PERM_ENUM = 14;
pub const _MM_PERM_ENUM__MM_PERM_AADD: _MM_PERM_ENUM = 15;
pub const _MM_PERM_ENUM__MM_PERM_ABAA: _MM_PERM_ENUM = 16;
pub const _MM_PERM_ENUM__MM_PERM_ABAB: _MM_PERM_ENUM = 17;
pub const _MM_PERM_ENUM__MM_PERM_ABAC: _MM_PERM_ENUM = 18;
pub const _MM_PERM_ENUM__MM_PERM_ABAD: _MM_PERM_ENUM = 19;
pub const _MM_PERM_ENUM__MM_PERM_ABBA: _MM_PERM_ENUM = 20;
pub const _MM_PERM_ENUM__MM_PERM_ABBB: _MM_PERM_ENUM = 21;
pub const _MM_PERM_ENUM__MM_PERM_ABBC: _MM_PERM_ENUM = 22;
pub const _MM_PERM_ENUM__MM_PERM_ABBD: _MM_PERM_ENUM = 23;
pub const _MM_PERM_ENUM__MM_PERM_ABCA: _MM_PERM_ENUM = 24;
pub const _MM_PERM_ENUM__MM_PERM_ABCB: _MM_PERM_ENUM = 25;
pub const _MM_PERM_ENUM__MM_PERM_ABCC: _MM_PERM_ENUM = 26;
pub const _MM_PERM_ENUM__MM_PERM_ABCD: _MM_PERM_ENUM = 27;
pub const _MM_PERM_ENUM__MM_PERM_ABDA: _MM_PERM_ENUM = 28;
pub const _MM_PERM_ENUM__MM_PERM_ABDB: _MM_PERM_ENUM = 29;
pub const _MM_PERM_ENUM__MM_PERM_ABDC: _MM_PERM_ENUM = 30;
pub const _MM_PERM_ENUM__MM_PERM_ABDD: _MM_PERM_ENUM = 31;
pub const _MM_PERM_ENUM__MM_PERM_ACAA: _MM_PERM_ENUM = 32;
pub const _MM_PERM_ENUM__MM_PERM_ACAB: _MM_PERM_ENUM = 33;
pub const _MM_PERM_ENUM__MM_PERM_ACAC: _MM_PERM_ENUM = 34;
pub const _MM_PERM_ENUM__MM_PERM_ACAD: _MM_PERM_ENUM = 35;
pub const _MM_PERM_ENUM__MM_PERM_ACBA: _MM_PERM_ENUM = 36;
pub const _MM_PERM_ENUM__MM_PERM_ACBB: _MM_PERM_ENUM = 37;
pub const _MM_PERM_ENUM__MM_PERM_ACBC: _MM_PERM_ENUM = 38;
pub const _MM_PERM_ENUM__MM_PERM_ACBD: _MM_PERM_ENUM = 39;
pub const _MM_PERM_ENUM__MM_PERM_ACCA: _MM_PERM_ENUM = 40;
pub const _MM_PERM_ENUM__MM_PERM_ACCB: _MM_PERM_ENUM = 41;
pub const _MM_PERM_ENUM__MM_PERM_ACCC: _MM_PERM_ENUM = 42;
pub const _MM_PERM_ENUM__MM_PERM_ACCD: _MM_PERM_ENUM = 43;
pub const _MM_PERM_ENUM__MM_PERM_ACDA: _MM_PERM_ENUM = 44;
pub const _MM_PERM_ENUM__MM_PERM_ACDB: _MM_PERM_ENUM = 45;
pub const _MM_PERM_ENUM__MM_PERM_ACDC: _MM_PERM_ENUM = 46;
pub const _MM_PERM_ENUM__MM_PERM_ACDD: _MM_PERM_ENUM = 47;
pub const _MM_PERM_ENUM__MM_PERM_ADAA: _MM_PERM_ENUM = 48;
pub const _MM_PERM_ENUM__MM_PERM_ADAB: _MM_PERM_ENUM = 49;
pub const _MM_PERM_ENUM__MM_PERM_ADAC: _MM_PERM_ENUM = 50;
pub const _MM_PERM_ENUM__MM_PERM_ADAD: _MM_PERM_ENUM = 51;
pub const _MM_PERM_ENUM__MM_PERM_ADBA: _MM_PERM_ENUM = 52;
pub const _MM_PERM_ENUM__MM_PERM_ADBB: _MM_PERM_ENUM = 53;
pub const _MM_PERM_ENUM__MM_PERM_ADBC: _MM_PERM_ENUM = 54;
pub const _MM_PERM_ENUM__MM_PERM_ADBD: _MM_PERM_ENUM = 55;
pub const _MM_PERM_ENUM__MM_PERM_ADCA: _MM_PERM_ENUM = 56;
pub const _MM_PERM_ENUM__MM_PERM_ADCB: _MM_PERM_ENUM = 57;
pub const _MM_PERM_ENUM__MM_PERM_ADCC: _MM_PERM_ENUM = 58;
pub const _MM_PERM_ENUM__MM_PERM_ADCD: _MM_PERM_ENUM = 59;
pub const _MM_PERM_ENUM__MM_PERM_ADDA: _MM_PERM_ENUM = 60;
pub const _MM_PERM_ENUM__MM_PERM_ADDB: _MM_PERM_ENUM = 61;
pub const _MM_PERM_ENUM__MM_PERM_ADDC: _MM_PERM_ENUM = 62;
pub const _MM_PERM_ENUM__MM_PERM_ADDD: _MM_PERM_ENUM = 63;
pub const _MM_PERM_ENUM__MM_PERM_BAAA: _MM_PERM_ENUM = 64;
pub const _MM_PERM_ENUM__MM_PERM_BAAB: _MM_PERM_ENUM = 65;
pub const _MM_PERM_ENUM__MM_PERM_BAAC: _MM_PERM_ENUM = 66;
pub const _MM_PERM_ENUM__MM_PERM_BAAD: _MM_PERM_ENUM = 67;
pub const _MM_PERM_ENUM__MM_PERM_BABA: _MM_PERM_ENUM = 68;
pub const _MM_PERM_ENUM__MM_PERM_BABB: _MM_PERM_ENUM = 69;
pub const _MM_PERM_ENUM__MM_PERM_BABC: _MM_PERM_ENUM = 70;
pub const _MM_PERM_ENUM__MM_PERM_BABD: _MM_PERM_ENUM = 71;
pub const _MM_PERM_ENUM__MM_PERM_BACA: _MM_PERM_ENUM = 72;
pub const _MM_PERM_ENUM__MM_PERM_BACB: _MM_PERM_ENUM = 73;
pub const _MM_PERM_ENUM__MM_PERM_BACC: _MM_PERM_ENUM = 74;
pub const _MM_PERM_ENUM__MM_PERM_BACD: _MM_PERM_ENUM = 75;
pub const _MM_PERM_ENUM__MM_PERM_BADA: _MM_PERM_ENUM = 76;
pub const _MM_PERM_ENUM__MM_PERM_BADB: _MM_PERM_ENUM = 77;
pub const _MM_PERM_ENUM__MM_PERM_BADC: _MM_PERM_ENUM = 78;
pub const _MM_PERM_ENUM__MM_PERM_BADD: _MM_PERM_ENUM = 79;
pub const _MM_PERM_ENUM__MM_PERM_BBAA: _MM_PERM_ENUM = 80;
pub const _MM_PERM_ENUM__MM_PERM_BBAB: _MM_PERM_ENUM = 81;
pub const _MM_PERM_ENUM__MM_PERM_BBAC: _MM_PERM_ENUM = 82;
pub const _MM_PERM_ENUM__MM_PERM_BBAD: _MM_PERM_ENUM = 83;
pub const _MM_PERM_ENUM__MM_PERM_BBBA: _MM_PERM_ENUM = 84;
pub const _MM_PERM_ENUM__MM_PERM_BBBB: _MM_PERM_ENUM = 85;
pub const _MM_PERM_ENUM__MM_PERM_BBBC: _MM_PERM_ENUM = 86;
pub const _MM_PERM_ENUM__MM_PERM_BBBD: _MM_PERM_ENUM = 87;
pub const _MM_PERM_ENUM__MM_PERM_BBCA: _MM_PERM_ENUM = 88;
pub const _MM_PERM_ENUM__MM_PERM_BBCB: _MM_PERM_ENUM = 89;
pub const _MM_PERM_ENUM__MM_PERM_BBCC: _MM_PERM_ENUM = 90;
pub const _MM_PERM_ENUM__MM_PERM_BBCD: _MM_PERM_ENUM = 91;
pub const _MM_PERM_ENUM__MM_PERM_BBDA: _MM_PERM_ENUM = 92;
pub const _MM_PERM_ENUM__MM_PERM_BBDB: _MM_PERM_ENUM = 93;
pub const _MM_PERM_ENUM__MM_PERM_BBDC: _MM_PERM_ENUM = 94;
pub const _MM_PERM_ENUM__MM_PERM_BBDD: _MM_PERM_ENUM = 95;
pub const _MM_PERM_ENUM__MM_PERM_BCAA: _MM_PERM_ENUM = 96;
pub const _MM_PERM_ENUM__MM_PERM_BCAB: _MM_PERM_ENUM = 97;
pub const _MM_PERM_ENUM__MM_PERM_BCAC: _MM_PERM_ENUM = 98;
pub const _MM_PERM_ENUM__MM_PERM_BCAD: _MM_PERM_ENUM = 99;
pub const _MM_PERM_ENUM__MM_PERM_BCBA: _MM_PERM_ENUM = 100;
pub const _MM_PERM_ENUM__MM_PERM_BCBB: _MM_PERM_ENUM = 101;
pub const _MM_PERM_ENUM__MM_PERM_BCBC: _MM_PERM_ENUM = 102;
pub const _MM_PERM_ENUM__MM_PERM_BCBD: _MM_PERM_ENUM = 103;
pub const _MM_PERM_ENUM__MM_PERM_BCCA: _MM_PERM_ENUM = 104;
pub const _MM_PERM_ENUM__MM_PERM_BCCB: _MM_PERM_ENUM = 105;
pub const _MM_PERM_ENUM__MM_PERM_BCCC: _MM_PERM_ENUM = 106;
pub const _MM_PERM_ENUM__MM_PERM_BCCD: _MM_PERM_ENUM = 107;
pub const _MM_PERM_ENUM__MM_PERM_BCDA: _MM_PERM_ENUM = 108;
pub const _MM_PERM_ENUM__MM_PERM_BCDB: _MM_PERM_ENUM = 109;
pub const _MM_PERM_ENUM__MM_PERM_BCDC: _MM_PERM_ENUM = 110;
pub const _MM_PERM_ENUM__MM_PERM_BCDD: _MM_PERM_ENUM = 111;
pub const _MM_PERM_ENUM__MM_PERM_BDAA: _MM_PERM_ENUM = 112;
pub const _MM_PERM_ENUM__MM_PERM_BDAB: _MM_PERM_ENUM = 113;
pub const _MM_PERM_ENUM__MM_PERM_BDAC: _MM_PERM_ENUM = 114;
pub const _MM_PERM_ENUM__MM_PERM_BDAD: _MM_PERM_ENUM = 115;
pub const _MM_PERM_ENUM__MM_PERM_BDBA: _MM_PERM_ENUM = 116;
pub const _MM_PERM_ENUM__MM_PERM_BDBB: _MM_PERM_ENUM = 117;
pub const _MM_PERM_ENUM__MM_PERM_BDBC: _MM_PERM_ENUM = 118;
pub const _MM_PERM_ENUM__MM_PERM_BDBD: _MM_PERM_ENUM = 119;
pub const _MM_PERM_ENUM__MM_PERM_BDCA: _MM_PERM_ENUM = 120;
pub const _MM_PERM_ENUM__MM_PERM_BDCB: _MM_PERM_ENUM = 121;
pub const _MM_PERM_ENUM__MM_PERM_BDCC: _MM_PERM_ENUM = 122;
pub const _MM_PERM_ENUM__MM_PERM_BDCD: _MM_PERM_ENUM = 123;
pub const _MM_PERM_ENUM__MM_PERM_BDDA: _MM_PERM_ENUM = 124;
pub const _MM_PERM_ENUM__MM_PERM_BDDB: _MM_PERM_ENUM = 125;
pub const _MM_PERM_ENUM__MM_PERM_BDDC: _MM_PERM_ENUM = 126;
pub const _MM_PERM_ENUM__MM_PERM_BDDD: _MM_PERM_ENUM = 127;
pub const _MM_PERM_ENUM__MM_PERM_CAAA: _MM_PERM_ENUM = 128;
pub const _MM_PERM_ENUM__MM_PERM_CAAB: _MM_PERM_ENUM = 129;
pub const _MM_PERM_ENUM__MM_PERM_CAAC: _MM_PERM_ENUM = 130;
pub const _MM_PERM_ENUM__MM_PERM_CAAD: _MM_PERM_ENUM = 131;
pub const _MM_PERM_ENUM__MM_PERM_CABA: _MM_PERM_ENUM = 132;
pub const _MM_PERM_ENUM__MM_PERM_CABB: _MM_PERM_ENUM = 133;
pub const _MM_PERM_ENUM__MM_PERM_CABC: _MM_PERM_ENUM = 134;
pub const _MM_PERM_ENUM__MM_PERM_CABD: _MM_PERM_ENUM = 135;
pub const _MM_PERM_ENUM__MM_PERM_CACA: _MM_PERM_ENUM = 136;
pub const _MM_PERM_ENUM__MM_PERM_CACB: _MM_PERM_ENUM = 137;
pub const _MM_PERM_ENUM__MM_PERM_CACC: _MM_PERM_ENUM = 138;
pub const _MM_PERM_ENUM__MM_PERM_CACD: _MM_PERM_ENUM = 139;
pub const _MM_PERM_ENUM__MM_PERM_CADA: _MM_PERM_ENUM = 140;
pub const _MM_PERM_ENUM__MM_PERM_CADB: _MM_PERM_ENUM = 141;
pub const _MM_PERM_ENUM__MM_PERM_CADC: _MM_PERM_ENUM = 142;
pub const _MM_PERM_ENUM__MM_PERM_CADD: _MM_PERM_ENUM = 143;
pub const _MM_PERM_ENUM__MM_PERM_CBAA: _MM_PERM_ENUM = 144;
pub const _MM_PERM_ENUM__MM_PERM_CBAB: _MM_PERM_ENUM = 145;
pub const _MM_PERM_ENUM__MM_PERM_CBAC: _MM_PERM_ENUM = 146;
pub const _MM_PERM_ENUM__MM_PERM_CBAD: _MM_PERM_ENUM = 147;
pub const _MM_PERM_ENUM__MM_PERM_CBBA: _MM_PERM_ENUM = 148;
pub const _MM_PERM_ENUM__MM_PERM_CBBB: _MM_PERM_ENUM = 149;
pub const _MM_PERM_ENUM__MM_PERM_CBBC: _MM_PERM_ENUM = 150;
pub const _MM_PERM_ENUM__MM_PERM_CBBD: _MM_PERM_ENUM = 151;
pub const _MM_PERM_ENUM__MM_PERM_CBCA: _MM_PERM_ENUM = 152;
pub const _MM_PERM_ENUM__MM_PERM_CBCB: _MM_PERM_ENUM = 153;
pub const _MM_PERM_ENUM__MM_PERM_CBCC: _MM_PERM_ENUM = 154;
pub const _MM_PERM_ENUM__MM_PERM_CBCD: _MM_PERM_ENUM = 155;
pub const _MM_PERM_ENUM__MM_PERM_CBDA: _MM_PERM_ENUM = 156;
pub const _MM_PERM_ENUM__MM_PERM_CBDB: _MM_PERM_ENUM = 157;
pub const _MM_PERM_ENUM__MM_PERM_CBDC: _MM_PERM_ENUM = 158;
pub const _MM_PERM_ENUM__MM_PERM_CBDD: _MM_PERM_ENUM = 159;
pub const _MM_PERM_ENUM__MM_PERM_CCAA: _MM_PERM_ENUM = 160;
pub const _MM_PERM_ENUM__MM_PERM_CCAB: _MM_PERM_ENUM = 161;
pub const _MM_PERM_ENUM__MM_PERM_CCAC: _MM_PERM_ENUM = 162;
pub const _MM_PERM_ENUM__MM_PERM_CCAD: _MM_PERM_ENUM = 163;
pub const _MM_PERM_ENUM__MM_PERM_CCBA: _MM_PERM_ENUM = 164;
pub const _MM_PERM_ENUM__MM_PERM_CCBB: _MM_PERM_ENUM = 165;
pub const _MM_PERM_ENUM__MM_PERM_CCBC: _MM_PERM_ENUM = 166;
pub const _MM_PERM_ENUM__MM_PERM_CCBD: _MM_PERM_ENUM = 167;
pub const _MM_PERM_ENUM__MM_PERM_CCCA: _MM_PERM_ENUM = 168;
pub const _MM_PERM_ENUM__MM_PERM_CCCB: _MM_PERM_ENUM = 169;
pub const _MM_PERM_ENUM__MM_PERM_CCCC: _MM_PERM_ENUM = 170;
pub const _MM_PERM_ENUM__MM_PERM_CCCD: _MM_PERM_ENUM = 171;
pub const _MM_PERM_ENUM__MM_PERM_CCDA: _MM_PERM_ENUM = 172;
pub const _MM_PERM_ENUM__MM_PERM_CCDB: _MM_PERM_ENUM = 173;
pub const _MM_PERM_ENUM__MM_PERM_CCDC: _MM_PERM_ENUM = 174;
pub const _MM_PERM_ENUM__MM_PERM_CCDD: _MM_PERM_ENUM = 175;
pub const _MM_PERM_ENUM__MM_PERM_CDAA: _MM_PERM_ENUM = 176;
pub const _MM_PERM_ENUM__MM_PERM_CDAB: _MM_PERM_ENUM = 177;
pub const _MM_PERM_ENUM__MM_PERM_CDAC: _MM_PERM_ENUM = 178;
pub const _MM_PERM_ENUM__MM_PERM_CDAD: _MM_PERM_ENUM = 179;
pub const _MM_PERM_ENUM__MM_PERM_CDBA: _MM_PERM_ENUM = 180;
pub const _MM_PERM_ENUM__MM_PERM_CDBB: _MM_PERM_ENUM = 181;
pub const _MM_PERM_ENUM__MM_PERM_CDBC: _MM_PERM_ENUM = 182;
pub const _MM_PERM_ENUM__MM_PERM_CDBD: _MM_PERM_ENUM = 183;
pub const _MM_PERM_ENUM__MM_PERM_CDCA: _MM_PERM_ENUM = 184;
pub const _MM_PERM_ENUM__MM_PERM_CDCB: _MM_PERM_ENUM = 185;
pub const _MM_PERM_ENUM__MM_PERM_CDCC: _MM_PERM_ENUM = 186;
pub const _MM_PERM_ENUM__MM_PERM_CDCD: _MM_PERM_ENUM = 187;
pub const _MM_PERM_ENUM__MM_PERM_CDDA: _MM_PERM_ENUM = 188;
pub const _MM_PERM_ENUM__MM_PERM_CDDB: _MM_PERM_ENUM = 189;
pub const _MM_PERM_ENUM__MM_PERM_CDDC: _MM_PERM_ENUM = 190;
pub const _MM_PERM_ENUM__MM_PERM_CDDD: _MM_PERM_ENUM = 191;
pub const _MM_PERM_ENUM__MM_PERM_DAAA: _MM_PERM_ENUM = 192;
pub const _MM_PERM_ENUM__MM_PERM_DAAB: _MM_PERM_ENUM = 193;
pub const _MM_PERM_ENUM__MM_PERM_DAAC: _MM_PERM_ENUM = 194;
pub const _MM_PERM_ENUM__MM_PERM_DAAD: _MM_PERM_ENUM = 195;
pub const _MM_PERM_ENUM__MM_PERM_DABA: _MM_PERM_ENUM = 196;
pub const _MM_PERM_ENUM__MM_PERM_DABB: _MM_PERM_ENUM = 197;
pub const _MM_PERM_ENUM__MM_PERM_DABC: _MM_PERM_ENUM = 198;
pub const _MM_PERM_ENUM__MM_PERM_DABD: _MM_PERM_ENUM = 199;
pub const _MM_PERM_ENUM__MM_PERM_DACA: _MM_PERM_ENUM = 200;
pub const _MM_PERM_ENUM__MM_PERM_DACB: _MM_PERM_ENUM = 201;
pub const _MM_PERM_ENUM__MM_PERM_DACC: _MM_PERM_ENUM = 202;
pub const _MM_PERM_ENUM__MM_PERM_DACD: _MM_PERM_ENUM = 203;
pub const _MM_PERM_ENUM__MM_PERM_DADA: _MM_PERM_ENUM = 204;
pub const _MM_PERM_ENUM__MM_PERM_DADB: _MM_PERM_ENUM = 205;
pub const _MM_PERM_ENUM__MM_PERM_DADC: _MM_PERM_ENUM = 206;
pub const _MM_PERM_ENUM__MM_PERM_DADD: _MM_PERM_ENUM = 207;
pub const _MM_PERM_ENUM__MM_PERM_DBAA: _MM_PERM_ENUM = 208;
pub const _MM_PERM_ENUM__MM_PERM_DBAB: _MM_PERM_ENUM = 209;
pub const _MM_PERM_ENUM__MM_PERM_DBAC: _MM_PERM_ENUM = 210;
pub const _MM_PERM_ENUM__MM_PERM_DBAD: _MM_PERM_ENUM = 211;
pub const _MM_PERM_ENUM__MM_PERM_DBBA: _MM_PERM_ENUM = 212;
pub const _MM_PERM_ENUM__MM_PERM_DBBB: _MM_PERM_ENUM = 213;
pub const _MM_PERM_ENUM__MM_PERM_DBBC: _MM_PERM_ENUM = 214;
pub const _MM_PERM_ENUM__MM_PERM_DBBD: _MM_PERM_ENUM = 215;
pub const _MM_PERM_ENUM__MM_PERM_DBCA: _MM_PERM_ENUM = 216;
pub const _MM_PERM_ENUM__MM_PERM_DBCB: _MM_PERM_ENUM = 217;
pub const _MM_PERM_ENUM__MM_PERM_DBCC: _MM_PERM_ENUM = 218;
pub const _MM_PERM_ENUM__MM_PERM_DBCD: _MM_PERM_ENUM = 219;
pub const _MM_PERM_ENUM__MM_PERM_DBDA: _MM_PERM_ENUM = 220;
pub const _MM_PERM_ENUM__MM_PERM_DBDB: _MM_PERM_ENUM = 221;
pub const _MM_PERM_ENUM__MM_PERM_DBDC: _MM_PERM_ENUM = 222;
pub const _MM_PERM_ENUM__MM_PERM_DBDD: _MM_PERM_ENUM = 223;
pub const _MM_PERM_ENUM__MM_PERM_DCAA: _MM_PERM_ENUM = 224;
pub const _MM_PERM_ENUM__MM_PERM_DCAB: _MM_PERM_ENUM = 225;
pub const _MM_PERM_ENUM__MM_PERM_DCAC: _MM_PERM_ENUM = 226;
pub const _MM_PERM_ENUM__MM_PERM_DCAD: _MM_PERM_ENUM = 227;
pub const _MM_PERM_ENUM__MM_PERM_DCBA: _MM_PERM_ENUM = 228;
pub const _MM_PERM_ENUM__MM_PERM_DCBB: _MM_PERM_ENUM = 229;
pub const _MM_PERM_ENUM__MM_PERM_DCBC: _MM_PERM_ENUM = 230;
pub const _MM_PERM_ENUM__MM_PERM_DCBD: _MM_PERM_ENUM = 231;
pub const _MM_PERM_ENUM__MM_PERM_DCCA: _MM_PERM_ENUM = 232;
pub const _MM_PERM_ENUM__MM_PERM_DCCB: _MM_PERM_ENUM = 233;
pub const _MM_PERM_ENUM__MM_PERM_DCCC: _MM_PERM_ENUM = 234;
pub const _MM_PERM_ENUM__MM_PERM_DCCD: _MM_PERM_ENUM = 235;
pub const _MM_PERM_ENUM__MM_PERM_DCDA: _MM_PERM_ENUM = 236;
pub const _MM_PERM_ENUM__MM_PERM_DCDB: _MM_PERM_ENUM = 237;
pub const _MM_PERM_ENUM__MM_PERM_DCDC: _MM_PERM_ENUM = 238;
pub const _MM_PERM_ENUM__MM_PERM_DCDD: _MM_PERM_ENUM = 239;
pub const _MM_PERM_ENUM__MM_PERM_DDAA: _MM_PERM_ENUM = 240;
pub const _MM_PERM_ENUM__MM_PERM_DDAB: _MM_PERM_ENUM = 241;
pub const _MM_PERM_ENUM__MM_PERM_DDAC: _MM_PERM_ENUM = 242;
pub const _MM_PERM_ENUM__MM_PERM_DDAD: _MM_PERM_ENUM = 243;
pub const _MM_PERM_ENUM__MM_PERM_DDBA: _MM_PERM_ENUM = 244;
pub const _MM_PERM_ENUM__MM_PERM_DDBB: _MM_PERM_ENUM = 245;
pub const _MM_PERM_ENUM__MM_PERM_DDBC: _MM_PERM_ENUM = 246;
pub const _MM_PERM_ENUM__MM_PERM_DDBD: _MM_PERM_ENUM = 247;
pub const _MM_PERM_ENUM__MM_PERM_DDCA: _MM_PERM_ENUM = 248;
pub const _MM_PERM_ENUM__MM_PERM_DDCB: _MM_PERM_ENUM = 249;
pub const _MM_PERM_ENUM__MM_PERM_DDCC: _MM_PERM_ENUM = 250;
pub const _MM_PERM_ENUM__MM_PERM_DDCD: _MM_PERM_ENUM = 251;
pub const _MM_PERM_ENUM__MM_PERM_DDDA: _MM_PERM_ENUM = 252;
pub const _MM_PERM_ENUM__MM_PERM_DDDB: _MM_PERM_ENUM = 253;
pub const _MM_PERM_ENUM__MM_PERM_DDDC: _MM_PERM_ENUM = 254;
pub const _MM_PERM_ENUM__MM_PERM_DDDD: _MM_PERM_ENUM = 255;
pub type _MM_PERM_ENUM = ::std::os::raw::c_uint;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_1_2: _MM_MANTISSA_NORM_ENUM = 0;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_p5_2: _MM_MANTISSA_NORM_ENUM = 1;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_p5_1: _MM_MANTISSA_NORM_ENUM = 2;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_p75_1p5: _MM_MANTISSA_NORM_ENUM = 3;
pub type _MM_MANTISSA_NORM_ENUM = ::std::os::raw::c_uint;
pub const _MM_MANTISSA_SIGN_ENUM__MM_MANT_SIGN_src: _MM_MANTISSA_SIGN_ENUM = 0;
pub const _MM_MANTISSA_SIGN_ENUM__MM_MANT_SIGN_zero: _MM_MANTISSA_SIGN_ENUM = 1;
pub const _MM_MANTISSA_SIGN_ENUM__MM_MANT_SIGN_nan: _MM_MANTISSA_SIGN_ENUM = 2;
pub type _MM_MANTISSA_SIGN_ENUM = ::std::os::raw::c_uint;
pub const _MM_TERNLOG_ENUM__MM_TERNLOG_A: _MM_TERNLOG_ENUM = 240;
pub const _MM_TERNLOG_ENUM__MM_TERNLOG_B: _MM_TERNLOG_ENUM = 204;
pub const _MM_TERNLOG_ENUM__MM_TERNLOG_C: _MM_TERNLOG_ENUM = 170;
pub type _MM_TERNLOG_ENUM = ::std::os::raw::c_uint;
pub type __v2hi = [::std::os::raw::c_short; 2usize];
pub type __v4qi = [::std::os::raw::c_char; 4usize];
pub type __v2qi = [::std::os::raw::c_char; 2usize];
pub type __mmask32 = ::std::os::raw::c_uint;
pub type __mmask64 = ::std::os::raw::c_ulonglong;
pub type __v32hf = [__BindgenFloat16; 32usize];
pub type __m512h = [__BindgenFloat16; 32usize];
pub type __m512h_u = [__BindgenFloat16; 32usize];
pub type __v32bf = [u8; 64usize];
pub type __m512bh = [u8; 64usize];
pub type __bfloat16 = u16;
pub type _tile1024i = [::std::os::raw::c_int; 256usize];
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct __tile1024i_str {
    pub row: ::std::os::raw::c_ushort,
    pub col: ::std::os::raw::c_ushort,
    pub __bindgen_padding_0: [u64; 7usize],
    pub tile: _tile1024i,
}
#[test]
fn bindgen_test_layout___tile1024i_str() {
    const UNINIT: ::std::mem::MaybeUninit<__tile1024i_str> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__tile1024i_str>(),
        1088usize,
        concat!("Size of: ", stringify!(__tile1024i_str))
    );
    assert_eq!(
        ::std::mem::align_of::<__tile1024i_str>(),
        64usize,
        concat!("Alignment of ", stringify!(__tile1024i_str))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).row) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tile1024i_str),
            "::",
            stringify!(row)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).col) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__tile1024i_str),
            "::",
            stringify!(col)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tile) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__tile1024i_str),
            "::",
            stringify!(tile)
        )
    );
}
pub type __tile1024i = __tile1024i_str;
pub type __v2sf = [f32; 2usize];
extern "C" {
    pub fn __getcallerseflags() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __segmentlimit(Selector: DWORD) -> DWORD;
}
extern "C" {
    pub fn __mulh(Multiplier: LONGLONG, Multiplicand: LONGLONG) -> LONGLONG;
}
extern "C" {
    pub fn __umulh(Multiplier: ULONGLONG, Multiplicand: ULONGLONG) -> ULONGLONG;
}
extern "C" {
    pub fn __shiftleft128(LowPart: DWORD64, HighPart: DWORD64, Shift: BYTE) -> DWORD64;
}
extern "C" {
    pub fn __shiftright128(LowPart: DWORD64, HighPart: DWORD64, Shift: BYTE) -> DWORD64;
}
extern "C" {
    pub fn _mul128(Multiplier: LONG64, Multiplicand: LONG64, HighProduct: *mut LONG64) -> LONG64;
}
extern "C" {
    pub fn _umul128(
        Multiplier: DWORD64,
        Multiplicand: DWORD64,
        HighProduct: *mut DWORD64,
    ) -> DWORD64;
}
extern "C" {
    pub fn MultiplyExtract128(Multiplier: LONG64, Multiplicand: LONG64, Shift: BYTE) -> LONG64;
}
extern "C" {
    pub fn UnsignedMultiplyExtract128(
        Multiplier: DWORD64,
        Multiplicand: DWORD64,
        Shift: BYTE,
    ) -> DWORD64;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _XMM_SAVE_AREA32 {
    pub ControlWord: WORD,
    pub StatusWord: WORD,
    pub TagWord: BYTE,
    pub Reserved1: BYTE,
    pub ErrorOpcode: WORD,
    pub ErrorOffset: DWORD,
    pub ErrorSelector: WORD,
    pub Reserved2: WORD,
    pub DataOffset: DWORD,
    pub DataSelector: WORD,
    pub Reserved3: WORD,
    pub MxCsr: DWORD,
    pub MxCsr_Mask: DWORD,
    pub FloatRegisters: [M128A; 8usize],
    pub XmmRegisters: [M128A; 16usize],
    pub Reserved4: [BYTE; 96usize],
}
#[test]
fn bindgen_test_layout__XMM_SAVE_AREA32() {
    const UNINIT: ::std::mem::MaybeUninit<_XMM_SAVE_AREA32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_XMM_SAVE_AREA32>(),
        512usize,
        concat!("Size of: ", stringify!(_XMM_SAVE_AREA32))
    );
    assert_eq!(
        ::std::mem::align_of::<_XMM_SAVE_AREA32>(),
        16usize,
        concat!("Alignment of ", stringify!(_XMM_SAVE_AREA32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ControlWord) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XMM_SAVE_AREA32),
            "::",
            stringify!(ControlWord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatusWord) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_XMM_SAVE_AREA32),
            "::",
            stringify!(StatusWord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TagWord) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XMM_SAVE_AREA32),
            "::",
            stringify!(TagWord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_XMM_SAVE_AREA32),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ErrorOpcode) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_XMM_SAVE_AREA32),
            "::",
            stringify!(ErrorOpcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ErrorOffset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XMM_SAVE_AREA32),
            "::",
            stringify!(ErrorOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ErrorSelector) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_XMM_SAVE_AREA32),
            "::",
            stringify!(ErrorSelector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_XMM_SAVE_AREA32),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XMM_SAVE_AREA32),
            "::",
            stringify!(DataOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataSelector) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_XMM_SAVE_AREA32),
            "::",
            stringify!(DataSelector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_XMM_SAVE_AREA32),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MxCsr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XMM_SAVE_AREA32),
            "::",
            stringify!(MxCsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MxCsr_Mask) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_XMM_SAVE_AREA32),
            "::",
            stringify!(MxCsr_Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FloatRegisters) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_XMM_SAVE_AREA32),
            "::",
            stringify!(FloatRegisters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).XmmRegisters) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_XMM_SAVE_AREA32),
            "::",
            stringify!(XmmRegisters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_XMM_SAVE_AREA32),
            "::",
            stringify!(Reserved4)
        )
    );
}
pub type XMM_SAVE_AREA32 = _XMM_SAVE_AREA32;
pub type PXMM_SAVE_AREA32 = *mut _XMM_SAVE_AREA32;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _CONTEXT {
    pub P1Home: DWORD64,
    pub P2Home: DWORD64,
    pub P3Home: DWORD64,
    pub P4Home: DWORD64,
    pub P5Home: DWORD64,
    pub P6Home: DWORD64,
    pub ContextFlags: DWORD,
    pub MxCsr: DWORD,
    pub SegCs: WORD,
    pub SegDs: WORD,
    pub SegEs: WORD,
    pub SegFs: WORD,
    pub SegGs: WORD,
    pub SegSs: WORD,
    pub EFlags: DWORD,
    pub Dr0: DWORD64,
    pub Dr1: DWORD64,
    pub Dr2: DWORD64,
    pub Dr3: DWORD64,
    pub Dr6: DWORD64,
    pub Dr7: DWORD64,
    pub Rax: DWORD64,
    pub Rcx: DWORD64,
    pub Rdx: DWORD64,
    pub Rbx: DWORD64,
    pub Rsp: DWORD64,
    pub Rbp: DWORD64,
    pub Rsi: DWORD64,
    pub Rdi: DWORD64,
    pub R8: DWORD64,
    pub R9: DWORD64,
    pub R10: DWORD64,
    pub R11: DWORD64,
    pub R12: DWORD64,
    pub R13: DWORD64,
    pub R14: DWORD64,
    pub R15: DWORD64,
    pub Rip: DWORD64,
    pub __bindgen_anon_1: _CONTEXT__bindgen_ty_1,
    pub VectorRegister: [M128A; 26usize],
    pub VectorControl: DWORD64,
    pub DebugControl: DWORD64,
    pub LastBranchToRip: DWORD64,
    pub LastBranchFromRip: DWORD64,
    pub LastExceptionToRip: DWORD64,
    pub LastExceptionFromRip: DWORD64,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _CONTEXT__bindgen_ty_1 {
    pub FltSave: XMM_SAVE_AREA32,
    pub FloatSave: XMM_SAVE_AREA32,
    pub __bindgen_anon_1: _CONTEXT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub Header: [M128A; 2usize],
    pub Legacy: [M128A; 8usize],
    pub Xmm0: M128A,
    pub Xmm1: M128A,
    pub Xmm2: M128A,
    pub Xmm3: M128A,
    pub Xmm4: M128A,
    pub Xmm5: M128A,
    pub Xmm6: M128A,
    pub Xmm7: M128A,
    pub Xmm8: M128A,
    pub Xmm9: M128A,
    pub Xmm10: M128A,
    pub Xmm11: M128A,
    pub Xmm12: M128A,
    pub Xmm13: M128A,
    pub Xmm14: M128A,
    pub Xmm15: M128A,
}
#[test]
fn bindgen_test_layout__CONTEXT__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_CONTEXT__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>(),
        416usize,
        concat!(
            "Size of: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Legacy) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Legacy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm0) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm1) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm2) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm3) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm4) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm5) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm6) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm7) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm8) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm9) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm10) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm11) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm12) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm13) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm13)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm14) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm14)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm15) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm15)
        )
    );
}
#[test]
fn bindgen_test_layout__CONTEXT__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_CONTEXT__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CONTEXT__bindgen_ty_1>(),
        512usize,
        concat!("Size of: ", stringify!(_CONTEXT__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_CONTEXT__bindgen_ty_1>(),
        16usize,
        concat!("Alignment of ", stringify!(_CONTEXT__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FltSave) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(FltSave)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FloatSave) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(FloatSave)
        )
    );
}
#[test]
fn bindgen_test_layout__CONTEXT() {
    const UNINIT: ::std::mem::MaybeUninit<_CONTEXT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CONTEXT>(),
        1232usize,
        concat!("Size of: ", stringify!(_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<_CONTEXT>(),
        16usize,
        concat!("Alignment of ", stringify!(_CONTEXT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).P1Home) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(P1Home)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).P2Home) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(P2Home)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).P3Home) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(P3Home)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).P4Home) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(P4Home)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).P5Home) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(P5Home)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).P6Home) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(P6Home)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ContextFlags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(ContextFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MxCsr) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(MxCsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SegCs) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(SegCs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SegDs) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(SegDs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SegEs) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(SegEs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SegFs) as usize - ptr as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(SegFs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SegGs) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(SegGs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SegSs) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(SegSs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EFlags) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(EFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Dr0) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Dr0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Dr1) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Dr1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Dr2) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Dr2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Dr3) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Dr3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Dr6) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Dr6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Dr7) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Dr7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rax) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Rax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rcx) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Rcx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rdx) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Rdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rbx) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Rbx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rsp) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Rsp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rbp) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Rbp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rsi) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Rsi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rdi) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Rdi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).R8) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(R8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).R9) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(R9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).R10) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(R10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).R11) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(R11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).R12) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(R12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).R13) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(R13)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).R14) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(R14)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).R15) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(R15)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rip) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Rip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VectorRegister) as usize - ptr as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(VectorRegister)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VectorControl) as usize - ptr as usize },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(VectorControl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DebugControl) as usize - ptr as usize },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(DebugControl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastBranchToRip) as usize - ptr as usize },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(LastBranchToRip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastBranchFromRip) as usize - ptr as usize },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(LastBranchFromRip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastExceptionToRip) as usize - ptr as usize },
        1216usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(LastExceptionToRip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastExceptionFromRip) as usize - ptr as usize },
        1224usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(LastExceptionFromRip)
        )
    );
}
pub type CONTEXT = _CONTEXT;
pub type PCONTEXT = *mut _CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RUNTIME_FUNCTION {
    pub BeginAddress: DWORD,
    pub EndAddress: DWORD,
    pub UnwindData: DWORD,
}
#[test]
fn bindgen_test_layout__RUNTIME_FUNCTION() {
    const UNINIT: ::std::mem::MaybeUninit<_RUNTIME_FUNCTION> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RUNTIME_FUNCTION>(),
        12usize,
        concat!("Size of: ", stringify!(_RUNTIME_FUNCTION))
    );
    assert_eq!(
        ::std::mem::align_of::<_RUNTIME_FUNCTION>(),
        4usize,
        concat!("Alignment of ", stringify!(_RUNTIME_FUNCTION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BeginAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RUNTIME_FUNCTION),
            "::",
            stringify!(BeginAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndAddress) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_RUNTIME_FUNCTION),
            "::",
            stringify!(EndAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnwindData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RUNTIME_FUNCTION),
            "::",
            stringify!(UnwindData)
        )
    );
}
pub type RUNTIME_FUNCTION = _RUNTIME_FUNCTION;
pub type PRUNTIME_FUNCTION = *mut _RUNTIME_FUNCTION;
pub type PGET_RUNTIME_FUNCTION_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(ControlPc: DWORD64, Context: PVOID) -> PRUNTIME_FUNCTION,
>;
pub type POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        Process: HANDLE,
        TableAddress: PVOID,
        Entries: PDWORD,
        Functions: *mut PRUNTIME_FUNCTION,
    ) -> DWORD,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LDT_ENTRY {
    pub LimitLow: WORD,
    pub BaseLow: WORD,
    pub HighWord: _LDT_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDT_ENTRY__bindgen_ty_1 {
    pub Bytes: _LDT_ENTRY__bindgen_ty_1__bindgen_ty_1,
    pub Bits: _LDT_ENTRY__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDT_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub BaseMid: BYTE,
    pub Flags1: BYTE,
    pub Flags2: BYTE,
    pub BaseHi: BYTE,
}
#[test]
fn bindgen_test_layout__LDT_ENTRY__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BaseMid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(BaseMid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags1) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Flags1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags2) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BaseHi) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(BaseHi)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _LDT_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__LDT_ENTRY__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2)
        )
    );
}
impl _LDT_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn BaseMid(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BaseMid(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Type(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Dpl(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Dpl(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Pres(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Pres(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LimitHi(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LimitHi(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Sys(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Sys(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved_0(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved_0(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Default_Big(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Default_Big(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Granularity(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Granularity(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BaseHi(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BaseHi(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BaseMid: DWORD,
        Type: DWORD,
        Dpl: DWORD,
        Pres: DWORD,
        LimitHi: DWORD,
        Sys: DWORD,
        Reserved_0: DWORD,
        Default_Big: DWORD,
        Granularity: DWORD,
        BaseHi: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let BaseMid: u32 = unsafe { ::std::mem::transmute(BaseMid) };
            BaseMid as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let Type: u32 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let Dpl: u32 = unsafe { ::std::mem::transmute(Dpl) };
            Dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Pres: u32 = unsafe { ::std::mem::transmute(Pres) };
            Pres as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let LimitHi: u32 = unsafe { ::std::mem::transmute(LimitHi) };
            LimitHi as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let Sys: u32 = unsafe { ::std::mem::transmute(Sys) };
            Sys as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let Reserved_0: u32 = unsafe { ::std::mem::transmute(Reserved_0) };
            Reserved_0 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let Default_Big: u32 = unsafe { ::std::mem::transmute(Default_Big) };
            Default_Big as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let Granularity: u32 = unsafe { ::std::mem::transmute(Granularity) };
            Granularity as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let BaseHi: u32 = unsafe { ::std::mem::transmute(BaseHi) };
            BaseHi as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__LDT_ENTRY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_LDT_ENTRY__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDT_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_LDT_ENTRY__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDT_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_LDT_ENTRY__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDT_ENTRY__bindgen_ty_1),
            "::",
            stringify!(Bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDT_ENTRY__bindgen_ty_1),
            "::",
            stringify!(Bits)
        )
    );
}
#[test]
fn bindgen_test_layout__LDT_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_LDT_ENTRY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDT_ENTRY>(),
        8usize,
        concat!("Size of: ", stringify!(_LDT_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDT_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_LDT_ENTRY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LimitLow) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDT_ENTRY),
            "::",
            stringify!(LimitLow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BaseLow) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDT_ENTRY),
            "::",
            stringify!(BaseLow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighWord) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDT_ENTRY),
            "::",
            stringify!(HighWord)
        )
    );
}
pub type LDT_ENTRY = _LDT_ENTRY;
pub type PLDT_ENTRY = *mut _LDT_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD {
    pub ExceptionCode: DWORD,
    pub ExceptionFlags: DWORD,
    pub ExceptionRecord: *mut _EXCEPTION_RECORD,
    pub ExceptionAddress: PVOID,
    pub NumberParameters: DWORD,
    pub ExceptionInformation: [ULONG_PTR; 15usize],
}
#[test]
fn bindgen_test_layout__EXCEPTION_RECORD() {
    const UNINIT: ::std::mem::MaybeUninit<_EXCEPTION_RECORD> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_EXCEPTION_RECORD>(),
        152usize,
        concat!("Size of: ", stringify!(_EXCEPTION_RECORD))
    );
    assert_eq!(
        ::std::mem::align_of::<_EXCEPTION_RECORD>(),
        8usize,
        concat!("Alignment of ", stringify!(_EXCEPTION_RECORD))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionRecord) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionRecord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionAddress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberParameters) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(NumberParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionInformation) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionInformation)
        )
    );
}
pub type EXCEPTION_RECORD = _EXCEPTION_RECORD;
pub type PEXCEPTION_RECORD = *mut EXCEPTION_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD32 {
    pub ExceptionCode: DWORD,
    pub ExceptionFlags: DWORD,
    pub ExceptionRecord: DWORD,
    pub ExceptionAddress: DWORD,
    pub NumberParameters: DWORD,
    pub ExceptionInformation: [DWORD; 15usize],
}
#[test]
fn bindgen_test_layout__EXCEPTION_RECORD32() {
    const UNINIT: ::std::mem::MaybeUninit<_EXCEPTION_RECORD32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_EXCEPTION_RECORD32>(),
        80usize,
        concat!("Size of: ", stringify!(_EXCEPTION_RECORD32))
    );
    assert_eq!(
        ::std::mem::align_of::<_EXCEPTION_RECORD32>(),
        4usize,
        concat!("Alignment of ", stringify!(_EXCEPTION_RECORD32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD32),
            "::",
            stringify!(ExceptionCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD32),
            "::",
            stringify!(ExceptionFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionRecord) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD32),
            "::",
            stringify!(ExceptionRecord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionAddress) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD32),
            "::",
            stringify!(ExceptionAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberParameters) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD32),
            "::",
            stringify!(NumberParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionInformation) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD32),
            "::",
            stringify!(ExceptionInformation)
        )
    );
}
pub type EXCEPTION_RECORD32 = _EXCEPTION_RECORD32;
pub type PEXCEPTION_RECORD32 = *mut _EXCEPTION_RECORD32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD64 {
    pub ExceptionCode: DWORD,
    pub ExceptionFlags: DWORD,
    pub ExceptionRecord: DWORD64,
    pub ExceptionAddress: DWORD64,
    pub NumberParameters: DWORD,
    pub __unusedAlignment: DWORD,
    pub ExceptionInformation: [DWORD64; 15usize],
}
#[test]
fn bindgen_test_layout__EXCEPTION_RECORD64() {
    const UNINIT: ::std::mem::MaybeUninit<_EXCEPTION_RECORD64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_EXCEPTION_RECORD64>(),
        152usize,
        concat!("Size of: ", stringify!(_EXCEPTION_RECORD64))
    );
    assert_eq!(
        ::std::mem::align_of::<_EXCEPTION_RECORD64>(),
        8usize,
        concat!("Alignment of ", stringify!(_EXCEPTION_RECORD64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD64),
            "::",
            stringify!(ExceptionCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD64),
            "::",
            stringify!(ExceptionFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionRecord) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD64),
            "::",
            stringify!(ExceptionRecord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionAddress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD64),
            "::",
            stringify!(ExceptionAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberParameters) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD64),
            "::",
            stringify!(NumberParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__unusedAlignment) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD64),
            "::",
            stringify!(__unusedAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionInformation) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD64),
            "::",
            stringify!(ExceptionInformation)
        )
    );
}
pub type EXCEPTION_RECORD64 = _EXCEPTION_RECORD64;
pub type PEXCEPTION_RECORD64 = *mut _EXCEPTION_RECORD64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_POINTERS {
    pub ExceptionRecord: PEXCEPTION_RECORD,
    pub ContextRecord: PCONTEXT,
}
#[test]
fn bindgen_test_layout__EXCEPTION_POINTERS() {
    const UNINIT: ::std::mem::MaybeUninit<_EXCEPTION_POINTERS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_EXCEPTION_POINTERS>(),
        16usize,
        concat!("Size of: ", stringify!(_EXCEPTION_POINTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_EXCEPTION_POINTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(_EXCEPTION_POINTERS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionRecord) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_POINTERS),
            "::",
            stringify!(ExceptionRecord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ContextRecord) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_POINTERS),
            "::",
            stringify!(ContextRecord)
        )
    );
}
pub type EXCEPTION_POINTERS = _EXCEPTION_POINTERS;
pub type PEXCEPTION_POINTERS = *mut _EXCEPTION_POINTERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNWIND_HISTORY_TABLE_ENTRY {
    pub ImageBase: ULONG64,
    pub FunctionEntry: PRUNTIME_FUNCTION,
}
#[test]
fn bindgen_test_layout__UNWIND_HISTORY_TABLE_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_UNWIND_HISTORY_TABLE_ENTRY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_UNWIND_HISTORY_TABLE_ENTRY>(),
        16usize,
        concat!("Size of: ", stringify!(_UNWIND_HISTORY_TABLE_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_UNWIND_HISTORY_TABLE_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_UNWIND_HISTORY_TABLE_ENTRY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ImageBase) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNWIND_HISTORY_TABLE_ENTRY),
            "::",
            stringify!(ImageBase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FunctionEntry) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNWIND_HISTORY_TABLE_ENTRY),
            "::",
            stringify!(FunctionEntry)
        )
    );
}
pub type UNWIND_HISTORY_TABLE_ENTRY = _UNWIND_HISTORY_TABLE_ENTRY;
pub type PUNWIND_HISTORY_TABLE_ENTRY = *mut _UNWIND_HISTORY_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNWIND_HISTORY_TABLE {
    pub Count: ULONG,
    pub LocalHint: BYTE,
    pub GlobalHint: BYTE,
    pub Search: BYTE,
    pub Once: BYTE,
    pub LowAddress: ULONG64,
    pub HighAddress: ULONG64,
    pub Entry: [UNWIND_HISTORY_TABLE_ENTRY; 12usize],
}
#[test]
fn bindgen_test_layout__UNWIND_HISTORY_TABLE() {
    const UNINIT: ::std::mem::MaybeUninit<_UNWIND_HISTORY_TABLE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_UNWIND_HISTORY_TABLE>(),
        216usize,
        concat!("Size of: ", stringify!(_UNWIND_HISTORY_TABLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_UNWIND_HISTORY_TABLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_UNWIND_HISTORY_TABLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNWIND_HISTORY_TABLE),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LocalHint) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNWIND_HISTORY_TABLE),
            "::",
            stringify!(LocalHint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GlobalHint) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNWIND_HISTORY_TABLE),
            "::",
            stringify!(GlobalHint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Search) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNWIND_HISTORY_TABLE),
            "::",
            stringify!(Search)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Once) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNWIND_HISTORY_TABLE),
            "::",
            stringify!(Once)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LowAddress) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNWIND_HISTORY_TABLE),
            "::",
            stringify!(LowAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighAddress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNWIND_HISTORY_TABLE),
            "::",
            stringify!(HighAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Entry) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNWIND_HISTORY_TABLE),
            "::",
            stringify!(Entry)
        )
    );
}
pub type UNWIND_HISTORY_TABLE = _UNWIND_HISTORY_TABLE;
pub type PUNWIND_HISTORY_TABLE = *mut _UNWIND_HISTORY_TABLE;
pub type DISPATCHER_CONTEXT = _DISPATCHER_CONTEXT;
pub type PDISPATCHER_CONTEXT = *mut _DISPATCHER_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_CONTEXT {
    pub ControlPc: ULONG64,
    pub ImageBase: ULONG64,
    pub FunctionEntry: PRUNTIME_FUNCTION,
    pub EstablisherFrame: ULONG64,
    pub TargetIp: ULONG64,
    pub ContextRecord: PCONTEXT,
    pub LanguageHandler: PEXCEPTION_ROUTINE,
    pub HandlerData: PVOID,
    pub HistoryTable: PUNWIND_HISTORY_TABLE,
    pub ScopeIndex: ULONG,
    pub Fill0: ULONG,
}
#[test]
fn bindgen_test_layout__DISPATCHER_CONTEXT() {
    const UNINIT: ::std::mem::MaybeUninit<_DISPATCHER_CONTEXT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_DISPATCHER_CONTEXT>(),
        80usize,
        concat!("Size of: ", stringify!(_DISPATCHER_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<_DISPATCHER_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_DISPATCHER_CONTEXT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ControlPc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(ControlPc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ImageBase) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(ImageBase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FunctionEntry) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(FunctionEntry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EstablisherFrame) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(EstablisherFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetIp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(TargetIp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ContextRecord) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(ContextRecord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LanguageHandler) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(LanguageHandler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HandlerData) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(HandlerData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HistoryTable) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(HistoryTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ScopeIndex) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(ScopeIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Fill0) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(Fill0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KNONVOLATILE_CONTEXT_POINTERS {
    pub FloatingContext: [PM128A; 16usize],
    pub IntegerContext: [PULONG64; 16usize],
}
#[test]
fn bindgen_test_layout__KNONVOLATILE_CONTEXT_POINTERS() {
    const UNINIT: ::std::mem::MaybeUninit<_KNONVOLATILE_CONTEXT_POINTERS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_KNONVOLATILE_CONTEXT_POINTERS>(),
        256usize,
        concat!("Size of: ", stringify!(_KNONVOLATILE_CONTEXT_POINTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_KNONVOLATILE_CONTEXT_POINTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(_KNONVOLATILE_CONTEXT_POINTERS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FloatingContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS),
            "::",
            stringify!(FloatingContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IntegerContext) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS),
            "::",
            stringify!(IntegerContext)
        )
    );
}
pub type KNONVOLATILE_CONTEXT_POINTERS = _KNONVOLATILE_CONTEXT_POINTERS;
pub type PKNONVOLATILE_CONTEXT_POINTERS = *mut _KNONVOLATILE_CONTEXT_POINTERS;
pub type PACCESS_TOKEN = PVOID;
pub type PSECURITY_DESCRIPTOR = PVOID;
pub type PSID = PVOID;
pub type PCLAIMS_BLOB = PVOID;
pub type ACCESS_MASK = DWORD;
pub type PACCESS_MASK = *mut ACCESS_MASK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GENERIC_MAPPING {
    pub GenericRead: ACCESS_MASK,
    pub GenericWrite: ACCESS_MASK,
    pub GenericExecute: ACCESS_MASK,
    pub GenericAll: ACCESS_MASK,
}
#[test]
fn bindgen_test_layout__GENERIC_MAPPING() {
    const UNINIT: ::std::mem::MaybeUninit<_GENERIC_MAPPING> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GENERIC_MAPPING>(),
        16usize,
        concat!("Size of: ", stringify!(_GENERIC_MAPPING))
    );
    assert_eq!(
        ::std::mem::align_of::<_GENERIC_MAPPING>(),
        4usize,
        concat!("Alignment of ", stringify!(_GENERIC_MAPPING))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GenericRead) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericRead)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GenericWrite) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericWrite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GenericExecute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericExecute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GenericAll) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericAll)
        )
    );
}
pub type GENERIC_MAPPING = _GENERIC_MAPPING;
pub type PGENERIC_MAPPING = *mut GENERIC_MAPPING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID_AND_ATTRIBUTES {
    pub Luid: LUID,
    pub Attributes: DWORD,
}
#[test]
fn bindgen_test_layout__LUID_AND_ATTRIBUTES() {
    const UNINIT: ::std::mem::MaybeUninit<_LUID_AND_ATTRIBUTES> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LUID_AND_ATTRIBUTES>(),
        12usize,
        concat!("Size of: ", stringify!(_LUID_AND_ATTRIBUTES))
    );
    assert_eq!(
        ::std::mem::align_of::<_LUID_AND_ATTRIBUTES>(),
        4usize,
        concat!("Alignment of ", stringify!(_LUID_AND_ATTRIBUTES))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Luid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LUID_AND_ATTRIBUTES),
            "::",
            stringify!(Luid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Attributes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_LUID_AND_ATTRIBUTES),
            "::",
            stringify!(Attributes)
        )
    );
}
pub type LUID_AND_ATTRIBUTES = _LUID_AND_ATTRIBUTES;
pub type PLUID_AND_ATTRIBUTES = *mut _LUID_AND_ATTRIBUTES;
pub type LUID_AND_ATTRIBUTES_ARRAY = [LUID_AND_ATTRIBUTES; 1usize];
pub type PLUID_AND_ATTRIBUTES_ARRAY = *mut LUID_AND_ATTRIBUTES_ARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_IDENTIFIER_AUTHORITY {
    pub Value: [BYTE; 6usize],
}
#[test]
fn bindgen_test_layout__SID_IDENTIFIER_AUTHORITY() {
    const UNINIT: ::std::mem::MaybeUninit<_SID_IDENTIFIER_AUTHORITY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SID_IDENTIFIER_AUTHORITY>(),
        6usize,
        concat!("Size of: ", stringify!(_SID_IDENTIFIER_AUTHORITY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SID_IDENTIFIER_AUTHORITY>(),
        1usize,
        concat!("Alignment of ", stringify!(_SID_IDENTIFIER_AUTHORITY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID_IDENTIFIER_AUTHORITY),
            "::",
            stringify!(Value)
        )
    );
}
pub type SID_IDENTIFIER_AUTHORITY = _SID_IDENTIFIER_AUTHORITY;
pub type PSID_IDENTIFIER_AUTHORITY = *mut _SID_IDENTIFIER_AUTHORITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID {
    pub Revision: BYTE,
    pub SubAuthorityCount: BYTE,
    pub IdentifierAuthority: SID_IDENTIFIER_AUTHORITY,
    pub SubAuthority: [DWORD; 1usize],
}
#[test]
fn bindgen_test_layout__SID() {
    const UNINIT: ::std::mem::MaybeUninit<_SID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SID>(),
        12usize,
        concat!("Size of: ", stringify!(_SID))
    );
    assert_eq!(
        ::std::mem::align_of::<_SID>(),
        4usize,
        concat!("Alignment of ", stringify!(_SID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Revision) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(Revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SubAuthorityCount) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(SubAuthorityCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IdentifierAuthority) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(IdentifierAuthority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SubAuthority) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(SubAuthority)
        )
    );
}
pub type SID = _SID;
pub type PISID = *mut _SID;
pub const _SID_NAME_USE_SidTypeUser: _SID_NAME_USE = 1;
pub const _SID_NAME_USE_SidTypeGroup: _SID_NAME_USE = 2;
pub const _SID_NAME_USE_SidTypeDomain: _SID_NAME_USE = 3;
pub const _SID_NAME_USE_SidTypeAlias: _SID_NAME_USE = 4;
pub const _SID_NAME_USE_SidTypeWellKnownGroup: _SID_NAME_USE = 5;
pub const _SID_NAME_USE_SidTypeDeletedAccount: _SID_NAME_USE = 6;
pub const _SID_NAME_USE_SidTypeInvalid: _SID_NAME_USE = 7;
pub const _SID_NAME_USE_SidTypeUnknown: _SID_NAME_USE = 8;
pub const _SID_NAME_USE_SidTypeComputer: _SID_NAME_USE = 9;
pub const _SID_NAME_USE_SidTypeLabel: _SID_NAME_USE = 10;
pub const _SID_NAME_USE_SidTypeLogonSession: _SID_NAME_USE = 11;
pub type _SID_NAME_USE = ::std::os::raw::c_uint;
pub use self::_SID_NAME_USE as SID_NAME_USE;
pub type PSID_NAME_USE = *mut _SID_NAME_USE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_AND_ATTRIBUTES {
    pub Sid: PSID,
    pub Attributes: DWORD,
}
#[test]
fn bindgen_test_layout__SID_AND_ATTRIBUTES() {
    const UNINIT: ::std::mem::MaybeUninit<_SID_AND_ATTRIBUTES> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SID_AND_ATTRIBUTES>(),
        16usize,
        concat!("Size of: ", stringify!(_SID_AND_ATTRIBUTES))
    );
    assert_eq!(
        ::std::mem::align_of::<_SID_AND_ATTRIBUTES>(),
        8usize,
        concat!("Alignment of ", stringify!(_SID_AND_ATTRIBUTES))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID_AND_ATTRIBUTES),
            "::",
            stringify!(Sid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Attributes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID_AND_ATTRIBUTES),
            "::",
            stringify!(Attributes)
        )
    );
}
pub type SID_AND_ATTRIBUTES = _SID_AND_ATTRIBUTES;
pub type PSID_AND_ATTRIBUTES = *mut _SID_AND_ATTRIBUTES;
pub type SID_AND_ATTRIBUTES_ARRAY = [SID_AND_ATTRIBUTES; 1usize];
pub type PSID_AND_ATTRIBUTES_ARRAY = *mut SID_AND_ATTRIBUTES_ARRAY;
pub type SID_HASH_ENTRY = ULONG_PTR;
pub type PSID_HASH_ENTRY = *mut ULONG_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_AND_ATTRIBUTES_HASH {
    pub SidCount: DWORD,
    pub SidAttr: PSID_AND_ATTRIBUTES,
    pub Hash: [SID_HASH_ENTRY; 32usize],
}
#[test]
fn bindgen_test_layout__SID_AND_ATTRIBUTES_HASH() {
    const UNINIT: ::std::mem::MaybeUninit<_SID_AND_ATTRIBUTES_HASH> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SID_AND_ATTRIBUTES_HASH>(),
        272usize,
        concat!("Size of: ", stringify!(_SID_AND_ATTRIBUTES_HASH))
    );
    assert_eq!(
        ::std::mem::align_of::<_SID_AND_ATTRIBUTES_HASH>(),
        8usize,
        concat!("Alignment of ", stringify!(_SID_AND_ATTRIBUTES_HASH))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID_AND_ATTRIBUTES_HASH),
            "::",
            stringify!(SidCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidAttr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID_AND_ATTRIBUTES_HASH),
            "::",
            stringify!(SidAttr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Hash) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID_AND_ATTRIBUTES_HASH),
            "::",
            stringify!(Hash)
        )
    );
}
pub type SID_AND_ATTRIBUTES_HASH = _SID_AND_ATTRIBUTES_HASH;
pub type PSID_AND_ATTRIBUTES_HASH = *mut _SID_AND_ATTRIBUTES_HASH;
pub const WELL_KNOWN_SID_TYPE_WinNullSid: WELL_KNOWN_SID_TYPE = 0;
pub const WELL_KNOWN_SID_TYPE_WinWorldSid: WELL_KNOWN_SID_TYPE = 1;
pub const WELL_KNOWN_SID_TYPE_WinLocalSid: WELL_KNOWN_SID_TYPE = 2;
pub const WELL_KNOWN_SID_TYPE_WinCreatorOwnerSid: WELL_KNOWN_SID_TYPE = 3;
pub const WELL_KNOWN_SID_TYPE_WinCreatorGroupSid: WELL_KNOWN_SID_TYPE = 4;
pub const WELL_KNOWN_SID_TYPE_WinCreatorOwnerServerSid: WELL_KNOWN_SID_TYPE = 5;
pub const WELL_KNOWN_SID_TYPE_WinCreatorGroupServerSid: WELL_KNOWN_SID_TYPE = 6;
pub const WELL_KNOWN_SID_TYPE_WinNtAuthoritySid: WELL_KNOWN_SID_TYPE = 7;
pub const WELL_KNOWN_SID_TYPE_WinDialupSid: WELL_KNOWN_SID_TYPE = 8;
pub const WELL_KNOWN_SID_TYPE_WinNetworkSid: WELL_KNOWN_SID_TYPE = 9;
pub const WELL_KNOWN_SID_TYPE_WinBatchSid: WELL_KNOWN_SID_TYPE = 10;
pub const WELL_KNOWN_SID_TYPE_WinInteractiveSid: WELL_KNOWN_SID_TYPE = 11;
pub const WELL_KNOWN_SID_TYPE_WinServiceSid: WELL_KNOWN_SID_TYPE = 12;
pub const WELL_KNOWN_SID_TYPE_WinAnonymousSid: WELL_KNOWN_SID_TYPE = 13;
pub const WELL_KNOWN_SID_TYPE_WinProxySid: WELL_KNOWN_SID_TYPE = 14;
pub const WELL_KNOWN_SID_TYPE_WinEnterpriseControllersSid: WELL_KNOWN_SID_TYPE = 15;
pub const WELL_KNOWN_SID_TYPE_WinSelfSid: WELL_KNOWN_SID_TYPE = 16;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticatedUserSid: WELL_KNOWN_SID_TYPE = 17;
pub const WELL_KNOWN_SID_TYPE_WinRestrictedCodeSid: WELL_KNOWN_SID_TYPE = 18;
pub const WELL_KNOWN_SID_TYPE_WinTerminalServerSid: WELL_KNOWN_SID_TYPE = 19;
pub const WELL_KNOWN_SID_TYPE_WinRemoteLogonIdSid: WELL_KNOWN_SID_TYPE = 20;
pub const WELL_KNOWN_SID_TYPE_WinLogonIdsSid: WELL_KNOWN_SID_TYPE = 21;
pub const WELL_KNOWN_SID_TYPE_WinLocalSystemSid: WELL_KNOWN_SID_TYPE = 22;
pub const WELL_KNOWN_SID_TYPE_WinLocalServiceSid: WELL_KNOWN_SID_TYPE = 23;
pub const WELL_KNOWN_SID_TYPE_WinNetworkServiceSid: WELL_KNOWN_SID_TYPE = 24;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinDomainSid: WELL_KNOWN_SID_TYPE = 25;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinAdministratorsSid: WELL_KNOWN_SID_TYPE = 26;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinUsersSid: WELL_KNOWN_SID_TYPE = 27;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinGuestsSid: WELL_KNOWN_SID_TYPE = 28;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinPowerUsersSid: WELL_KNOWN_SID_TYPE = 29;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinAccountOperatorsSid: WELL_KNOWN_SID_TYPE = 30;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinSystemOperatorsSid: WELL_KNOWN_SID_TYPE = 31;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinPrintOperatorsSid: WELL_KNOWN_SID_TYPE = 32;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinBackupOperatorsSid: WELL_KNOWN_SID_TYPE = 33;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinReplicatorSid: WELL_KNOWN_SID_TYPE = 34;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinPreWindows2000CompatibleAccessSid: WELL_KNOWN_SID_TYPE = 35;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinRemoteDesktopUsersSid: WELL_KNOWN_SID_TYPE = 36;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinNetworkConfigurationOperatorsSid: WELL_KNOWN_SID_TYPE = 37;
pub const WELL_KNOWN_SID_TYPE_WinAccountAdministratorSid: WELL_KNOWN_SID_TYPE = 38;
pub const WELL_KNOWN_SID_TYPE_WinAccountGuestSid: WELL_KNOWN_SID_TYPE = 39;
pub const WELL_KNOWN_SID_TYPE_WinAccountKrbtgtSid: WELL_KNOWN_SID_TYPE = 40;
pub const WELL_KNOWN_SID_TYPE_WinAccountDomainAdminsSid: WELL_KNOWN_SID_TYPE = 41;
pub const WELL_KNOWN_SID_TYPE_WinAccountDomainUsersSid: WELL_KNOWN_SID_TYPE = 42;
pub const WELL_KNOWN_SID_TYPE_WinAccountDomainGuestsSid: WELL_KNOWN_SID_TYPE = 43;
pub const WELL_KNOWN_SID_TYPE_WinAccountComputersSid: WELL_KNOWN_SID_TYPE = 44;
pub const WELL_KNOWN_SID_TYPE_WinAccountControllersSid: WELL_KNOWN_SID_TYPE = 45;
pub const WELL_KNOWN_SID_TYPE_WinAccountCertAdminsSid: WELL_KNOWN_SID_TYPE = 46;
pub const WELL_KNOWN_SID_TYPE_WinAccountSchemaAdminsSid: WELL_KNOWN_SID_TYPE = 47;
pub const WELL_KNOWN_SID_TYPE_WinAccountEnterpriseAdminsSid: WELL_KNOWN_SID_TYPE = 48;
pub const WELL_KNOWN_SID_TYPE_WinAccountPolicyAdminsSid: WELL_KNOWN_SID_TYPE = 49;
pub const WELL_KNOWN_SID_TYPE_WinAccountRasAndIasServersSid: WELL_KNOWN_SID_TYPE = 50;
pub const WELL_KNOWN_SID_TYPE_WinNTLMAuthenticationSid: WELL_KNOWN_SID_TYPE = 51;
pub const WELL_KNOWN_SID_TYPE_WinDigestAuthenticationSid: WELL_KNOWN_SID_TYPE = 52;
pub const WELL_KNOWN_SID_TYPE_WinSChannelAuthenticationSid: WELL_KNOWN_SID_TYPE = 53;
pub const WELL_KNOWN_SID_TYPE_WinThisOrganizationSid: WELL_KNOWN_SID_TYPE = 54;
pub const WELL_KNOWN_SID_TYPE_WinOtherOrganizationSid: WELL_KNOWN_SID_TYPE = 55;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinIncomingForestTrustBuildersSid: WELL_KNOWN_SID_TYPE = 56;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinPerfMonitoringUsersSid: WELL_KNOWN_SID_TYPE = 57;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinPerfLoggingUsersSid: WELL_KNOWN_SID_TYPE = 58;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinAuthorizationAccessSid: WELL_KNOWN_SID_TYPE = 59;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinTerminalServerLicenseServersSid: WELL_KNOWN_SID_TYPE = 60;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinDCOMUsersSid: WELL_KNOWN_SID_TYPE = 61;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinIUsersSid: WELL_KNOWN_SID_TYPE = 62;
pub const WELL_KNOWN_SID_TYPE_WinIUserSid: WELL_KNOWN_SID_TYPE = 63;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinCryptoOperatorsSid: WELL_KNOWN_SID_TYPE = 64;
pub const WELL_KNOWN_SID_TYPE_WinUntrustedLabelSid: WELL_KNOWN_SID_TYPE = 65;
pub const WELL_KNOWN_SID_TYPE_WinLowLabelSid: WELL_KNOWN_SID_TYPE = 66;
pub const WELL_KNOWN_SID_TYPE_WinMediumLabelSid: WELL_KNOWN_SID_TYPE = 67;
pub const WELL_KNOWN_SID_TYPE_WinHighLabelSid: WELL_KNOWN_SID_TYPE = 68;
pub const WELL_KNOWN_SID_TYPE_WinSystemLabelSid: WELL_KNOWN_SID_TYPE = 69;
pub const WELL_KNOWN_SID_TYPE_WinWriteRestrictedCodeSid: WELL_KNOWN_SID_TYPE = 70;
pub const WELL_KNOWN_SID_TYPE_WinCreatorOwnerRightsSid: WELL_KNOWN_SID_TYPE = 71;
pub const WELL_KNOWN_SID_TYPE_WinCacheablePrincipalsGroupSid: WELL_KNOWN_SID_TYPE = 72;
pub const WELL_KNOWN_SID_TYPE_WinNonCacheablePrincipalsGroupSid: WELL_KNOWN_SID_TYPE = 73;
pub const WELL_KNOWN_SID_TYPE_WinEnterpriseReadonlyControllersSid: WELL_KNOWN_SID_TYPE = 74;
pub const WELL_KNOWN_SID_TYPE_WinAccountReadonlyControllersSid: WELL_KNOWN_SID_TYPE = 75;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinEventLogReadersGroup: WELL_KNOWN_SID_TYPE = 76;
pub const WELL_KNOWN_SID_TYPE_WinNewEnterpriseReadonlyControllersSid: WELL_KNOWN_SID_TYPE = 77;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinCertSvcDComAccessGroup: WELL_KNOWN_SID_TYPE = 78;
pub const WELL_KNOWN_SID_TYPE_WinMediumPlusLabelSid: WELL_KNOWN_SID_TYPE = 79;
pub const WELL_KNOWN_SID_TYPE_WinLocalLogonSid: WELL_KNOWN_SID_TYPE = 80;
pub const WELL_KNOWN_SID_TYPE_WinConsoleLogonSid: WELL_KNOWN_SID_TYPE = 81;
pub const WELL_KNOWN_SID_TYPE_WinThisOrganizationCertificateSid: WELL_KNOWN_SID_TYPE = 82;
pub const WELL_KNOWN_SID_TYPE_WinApplicationPackageAuthoritySid: WELL_KNOWN_SID_TYPE = 83;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinAnyPackageSid: WELL_KNOWN_SID_TYPE = 84;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityInternetClientSid: WELL_KNOWN_SID_TYPE = 85;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityInternetClientServerSid: WELL_KNOWN_SID_TYPE = 86;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityPrivateNetworkClientServerSid: WELL_KNOWN_SID_TYPE = 87;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityPicturesLibrarySid: WELL_KNOWN_SID_TYPE = 88;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityVideosLibrarySid: WELL_KNOWN_SID_TYPE = 89;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityMusicLibrarySid: WELL_KNOWN_SID_TYPE = 90;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityDocumentsLibrarySid: WELL_KNOWN_SID_TYPE = 91;
pub const WELL_KNOWN_SID_TYPE_WinCapabilitySharedUserCertificatesSid: WELL_KNOWN_SID_TYPE = 92;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityEnterpriseAuthenticationSid: WELL_KNOWN_SID_TYPE = 93;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityRemovableStorageSid: WELL_KNOWN_SID_TYPE = 94;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinRDSRemoteAccessServersSid: WELL_KNOWN_SID_TYPE = 95;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinRDSEndpointServersSid: WELL_KNOWN_SID_TYPE = 96;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinRDSManagementServersSid: WELL_KNOWN_SID_TYPE = 97;
pub const WELL_KNOWN_SID_TYPE_WinUserModeDriversSid: WELL_KNOWN_SID_TYPE = 98;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinHyperVAdminsSid: WELL_KNOWN_SID_TYPE = 99;
pub const WELL_KNOWN_SID_TYPE_WinAccountCloneableControllersSid: WELL_KNOWN_SID_TYPE = 100;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinAccessControlAssistanceOperatorsSid: WELL_KNOWN_SID_TYPE =
    101;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinRemoteManagementUsersSid: WELL_KNOWN_SID_TYPE = 102;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticationAuthorityAssertedSid: WELL_KNOWN_SID_TYPE = 103;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticationServiceAssertedSid: WELL_KNOWN_SID_TYPE = 104;
pub const WELL_KNOWN_SID_TYPE_WinLocalAccountSid: WELL_KNOWN_SID_TYPE = 105;
pub const WELL_KNOWN_SID_TYPE_WinLocalAccountAndAdministratorSid: WELL_KNOWN_SID_TYPE = 106;
pub const WELL_KNOWN_SID_TYPE_WinAccountProtectedUsersSid: WELL_KNOWN_SID_TYPE = 107;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityAppointmentsSid: WELL_KNOWN_SID_TYPE = 108;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityContactsSid: WELL_KNOWN_SID_TYPE = 109;
pub const WELL_KNOWN_SID_TYPE_WinAccountDefaultSystemManagedSid: WELL_KNOWN_SID_TYPE = 110;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinDefaultSystemManagedGroupSid: WELL_KNOWN_SID_TYPE = 111;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinStorageReplicaAdminsSid: WELL_KNOWN_SID_TYPE = 112;
pub const WELL_KNOWN_SID_TYPE_WinAccountKeyAdminsSid: WELL_KNOWN_SID_TYPE = 113;
pub const WELL_KNOWN_SID_TYPE_WinAccountEnterpriseKeyAdminsSid: WELL_KNOWN_SID_TYPE = 114;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticationKeyTrustSid: WELL_KNOWN_SID_TYPE = 115;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticationKeyPropertyMFASid: WELL_KNOWN_SID_TYPE = 116;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticationKeyPropertyAttestationSid: WELL_KNOWN_SID_TYPE = 117;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticationFreshKeyAuthSid: WELL_KNOWN_SID_TYPE = 118;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinDeviceOwnersSid: WELL_KNOWN_SID_TYPE = 119;
pub type WELL_KNOWN_SID_TYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACL {
    pub AclRevision: BYTE,
    pub Sbz1: BYTE,
    pub AclSize: WORD,
    pub AceCount: WORD,
    pub Sbz2: WORD,
}
#[test]
fn bindgen_test_layout__ACL() {
    const UNINIT: ::std::mem::MaybeUninit<_ACL> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ACL>(),
        8usize,
        concat!("Size of: ", stringify!(_ACL))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACL>(),
        2usize,
        concat!("Alignment of ", stringify!(_ACL))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AclRevision) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACL),
            "::",
            stringify!(AclRevision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sbz1) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACL),
            "::",
            stringify!(Sbz1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AclSize) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACL),
            "::",
            stringify!(AclSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AceCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACL),
            "::",
            stringify!(AceCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sbz2) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACL),
            "::",
            stringify!(Sbz2)
        )
    );
}
pub type ACL = _ACL;
pub type PACL = *mut ACL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACE_HEADER {
    pub AceType: BYTE,
    pub AceFlags: BYTE,
    pub AceSize: WORD,
}
#[test]
fn bindgen_test_layout__ACE_HEADER() {
    const UNINIT: ::std::mem::MaybeUninit<_ACE_HEADER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ACE_HEADER>(),
        4usize,
        concat!("Size of: ", stringify!(_ACE_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACE_HEADER>(),
        2usize,
        concat!("Alignment of ", stringify!(_ACE_HEADER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AceType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACE_HEADER),
            "::",
            stringify!(AceType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AceFlags) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACE_HEADER),
            "::",
            stringify!(AceFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AceSize) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACE_HEADER),
            "::",
            stringify!(AceSize)
        )
    );
}
pub type ACE_HEADER = _ACE_HEADER;
pub type PACE_HEADER = *mut ACE_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_ALLOWED_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_ALLOWED_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_ACCESS_ALLOWED_ACE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ACCESS_ALLOWED_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_ACCESS_ALLOWED_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACCESS_ALLOWED_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACCESS_ALLOWED_ACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type ACCESS_ALLOWED_ACE = _ACCESS_ALLOWED_ACE;
pub type PACCESS_ALLOWED_ACE = *mut ACCESS_ALLOWED_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_DENIED_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_DENIED_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_ACCESS_DENIED_ACE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ACCESS_DENIED_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_ACCESS_DENIED_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACCESS_DENIED_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACCESS_DENIED_ACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type ACCESS_DENIED_ACE = _ACCESS_DENIED_ACE;
pub type PACCESS_DENIED_ACE = *mut ACCESS_DENIED_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_AUDIT_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_AUDIT_ACE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_AUDIT_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_SYSTEM_AUDIT_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_AUDIT_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_AUDIT_ACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_AUDIT_ACE = _SYSTEM_AUDIT_ACE;
pub type PSYSTEM_AUDIT_ACE = *mut SYSTEM_AUDIT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ALARM_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_ALARM_ACE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_ALARM_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_SYSTEM_ALARM_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_ALARM_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_ALARM_ACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_ALARM_ACE = _SYSTEM_ALARM_ACE;
pub type PSYSTEM_ALARM_ACE = *mut SYSTEM_ALARM_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_RESOURCE_ATTRIBUTE_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_RESOURCE_ATTRIBUTE_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_RESOURCE_ATTRIBUTE_ACE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_RESOURCE_ATTRIBUTE_ACE = _SYSTEM_RESOURCE_ATTRIBUTE_ACE;
pub type PSYSTEM_RESOURCE_ATTRIBUTE_ACE = *mut _SYSTEM_RESOURCE_ATTRIBUTE_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_SCOPED_POLICY_ID_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_SCOPED_POLICY_ID_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_SCOPED_POLICY_ID_ACE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_SCOPED_POLICY_ID_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_SCOPED_POLICY_ID_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_SCOPED_POLICY_ID_ACE = _SYSTEM_SCOPED_POLICY_ID_ACE;
pub type PSYSTEM_SCOPED_POLICY_ID_ACE = *mut _SYSTEM_SCOPED_POLICY_ID_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_MANDATORY_LABEL_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_MANDATORY_LABEL_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_MANDATORY_LABEL_ACE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_MANDATORY_LABEL_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_SYSTEM_MANDATORY_LABEL_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_MANDATORY_LABEL_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_MANDATORY_LABEL_ACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_MANDATORY_LABEL_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_MANDATORY_LABEL_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_MANDATORY_LABEL_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_MANDATORY_LABEL_ACE = _SYSTEM_MANDATORY_LABEL_ACE;
pub type PSYSTEM_MANDATORY_LABEL_ACE = *mut _SYSTEM_MANDATORY_LABEL_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_PROCESS_TRUST_LABEL_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_PROCESS_TRUST_LABEL_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_PROCESS_TRUST_LABEL_ACE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_PROCESS_TRUST_LABEL_ACE = _SYSTEM_PROCESS_TRUST_LABEL_ACE;
pub type PSYSTEM_PROCESS_TRUST_LABEL_ACE = *mut _SYSTEM_PROCESS_TRUST_LABEL_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ACCESS_FILTER_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ACCESS_FILTER_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_ACCESS_FILTER_ACE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_ACCESS_FILTER_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_SYSTEM_ACCESS_FILTER_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_ACCESS_FILTER_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_ACCESS_FILTER_ACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ACCESS_FILTER_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ACCESS_FILTER_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ACCESS_FILTER_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_ACCESS_FILTER_ACE = _SYSTEM_ACCESS_FILTER_ACE;
pub type PSYSTEM_ACCESS_FILTER_ACE = *mut _SYSTEM_ACCESS_FILTER_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_ALLOWED_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_ALLOWED_OBJECT_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_ACCESS_ALLOWED_OBJECT_ACE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ACCESS_ALLOWED_OBJECT_ACE>(),
        48usize,
        concat!("Size of: ", stringify!(_ACCESS_ALLOWED_OBJECT_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACCESS_ALLOWED_OBJECT_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACCESS_ALLOWED_OBJECT_ACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_OBJECT_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_OBJECT_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_OBJECT_ACE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_OBJECT_ACE),
            "::",
            stringify!(ObjectType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InheritedObjectType) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_OBJECT_ACE),
            "::",
            stringify!(InheritedObjectType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_OBJECT_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type ACCESS_ALLOWED_OBJECT_ACE = _ACCESS_ALLOWED_OBJECT_ACE;
pub type PACCESS_ALLOWED_OBJECT_ACE = *mut _ACCESS_ALLOWED_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_DENIED_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_DENIED_OBJECT_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_ACCESS_DENIED_OBJECT_ACE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ACCESS_DENIED_OBJECT_ACE>(),
        48usize,
        concat!("Size of: ", stringify!(_ACCESS_DENIED_OBJECT_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACCESS_DENIED_OBJECT_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACCESS_DENIED_OBJECT_ACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_OBJECT_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_OBJECT_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_OBJECT_ACE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_OBJECT_ACE),
            "::",
            stringify!(ObjectType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InheritedObjectType) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_OBJECT_ACE),
            "::",
            stringify!(InheritedObjectType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_OBJECT_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type ACCESS_DENIED_OBJECT_ACE = _ACCESS_DENIED_OBJECT_ACE;
pub type PACCESS_DENIED_OBJECT_ACE = *mut _ACCESS_DENIED_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_AUDIT_OBJECT_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_AUDIT_OBJECT_ACE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_AUDIT_OBJECT_ACE>(),
        48usize,
        concat!("Size of: ", stringify!(_SYSTEM_AUDIT_OBJECT_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_AUDIT_OBJECT_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_AUDIT_OBJECT_ACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
            "::",
            stringify!(ObjectType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InheritedObjectType) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
            "::",
            stringify!(InheritedObjectType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_AUDIT_OBJECT_ACE = _SYSTEM_AUDIT_OBJECT_ACE;
pub type PSYSTEM_AUDIT_OBJECT_ACE = *mut _SYSTEM_AUDIT_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ALARM_OBJECT_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_ALARM_OBJECT_ACE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_ALARM_OBJECT_ACE>(),
        48usize,
        concat!("Size of: ", stringify!(_SYSTEM_ALARM_OBJECT_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_ALARM_OBJECT_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_ALARM_OBJECT_ACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_OBJECT_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_OBJECT_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_OBJECT_ACE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_OBJECT_ACE),
            "::",
            stringify!(ObjectType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InheritedObjectType) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_OBJECT_ACE),
            "::",
            stringify!(InheritedObjectType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_OBJECT_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_ALARM_OBJECT_ACE = _SYSTEM_ALARM_OBJECT_ACE;
pub type PSYSTEM_ALARM_OBJECT_ACE = *mut _SYSTEM_ALARM_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_ALLOWED_CALLBACK_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_ALLOWED_CALLBACK_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_ACCESS_ALLOWED_CALLBACK_ACE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ACCESS_ALLOWED_CALLBACK_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_ACCESS_ALLOWED_CALLBACK_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACCESS_ALLOWED_CALLBACK_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACCESS_ALLOWED_CALLBACK_ACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_CALLBACK_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_CALLBACK_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_CALLBACK_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type ACCESS_ALLOWED_CALLBACK_ACE = _ACCESS_ALLOWED_CALLBACK_ACE;
pub type PACCESS_ALLOWED_CALLBACK_ACE = *mut _ACCESS_ALLOWED_CALLBACK_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_DENIED_CALLBACK_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_DENIED_CALLBACK_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_ACCESS_DENIED_CALLBACK_ACE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ACCESS_DENIED_CALLBACK_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_ACCESS_DENIED_CALLBACK_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACCESS_DENIED_CALLBACK_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACCESS_DENIED_CALLBACK_ACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_CALLBACK_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_CALLBACK_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_CALLBACK_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type ACCESS_DENIED_CALLBACK_ACE = _ACCESS_DENIED_CALLBACK_ACE;
pub type PACCESS_DENIED_CALLBACK_ACE = *mut _ACCESS_DENIED_CALLBACK_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_CALLBACK_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_AUDIT_CALLBACK_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_AUDIT_CALLBACK_ACE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_AUDIT_CALLBACK_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_SYSTEM_AUDIT_CALLBACK_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_AUDIT_CALLBACK_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_AUDIT_CALLBACK_ACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_CALLBACK_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_CALLBACK_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_CALLBACK_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_AUDIT_CALLBACK_ACE = _SYSTEM_AUDIT_CALLBACK_ACE;
pub type PSYSTEM_AUDIT_CALLBACK_ACE = *mut _SYSTEM_AUDIT_CALLBACK_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_CALLBACK_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ALARM_CALLBACK_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_ALARM_CALLBACK_ACE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_ALARM_CALLBACK_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_SYSTEM_ALARM_CALLBACK_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_ALARM_CALLBACK_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_ALARM_CALLBACK_ACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_CALLBACK_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_CALLBACK_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_CALLBACK_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_ALARM_CALLBACK_ACE = _SYSTEM_ALARM_CALLBACK_ACE;
pub type PSYSTEM_ALARM_CALLBACK_ACE = *mut _SYSTEM_ALARM_CALLBACK_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_ALLOWED_CALLBACK_OBJECT_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE>(),
        48usize,
        concat!("Size of: ", stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(ObjectType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InheritedObjectType) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(InheritedObjectType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type ACCESS_ALLOWED_CALLBACK_OBJECT_ACE = _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE;
pub type PACCESS_ALLOWED_CALLBACK_OBJECT_ACE = *mut _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_DENIED_CALLBACK_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_DENIED_CALLBACK_OBJECT_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_ACCESS_DENIED_CALLBACK_OBJECT_ACE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ACCESS_DENIED_CALLBACK_OBJECT_ACE>(),
        48usize,
        concat!("Size of: ", stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACCESS_DENIED_CALLBACK_OBJECT_ACE>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(ObjectType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InheritedObjectType) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(InheritedObjectType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type ACCESS_DENIED_CALLBACK_OBJECT_ACE = _ACCESS_DENIED_CALLBACK_OBJECT_ACE;
pub type PACCESS_DENIED_CALLBACK_OBJECT_ACE = *mut _ACCESS_DENIED_CALLBACK_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_AUDIT_CALLBACK_OBJECT_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>(),
        48usize,
        concat!("Size of: ", stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(ObjectType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InheritedObjectType) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(InheritedObjectType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_AUDIT_CALLBACK_OBJECT_ACE = _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE;
pub type PSYSTEM_AUDIT_CALLBACK_OBJECT_ACE = *mut _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_CALLBACK_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ALARM_CALLBACK_OBJECT_ACE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>(),
        48usize,
        concat!("Size of: ", stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(ObjectType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InheritedObjectType) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(InheritedObjectType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidStart) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_ALARM_CALLBACK_OBJECT_ACE = _SYSTEM_ALARM_CALLBACK_OBJECT_ACE;
pub type PSYSTEM_ALARM_CALLBACK_OBJECT_ACE = *mut _SYSTEM_ALARM_CALLBACK_OBJECT_ACE;
pub const _ACL_INFORMATION_CLASS_AclRevisionInformation: _ACL_INFORMATION_CLASS = 1;
pub const _ACL_INFORMATION_CLASS_AclSizeInformation: _ACL_INFORMATION_CLASS = 2;
pub type _ACL_INFORMATION_CLASS = ::std::os::raw::c_uint;
pub use self::_ACL_INFORMATION_CLASS as ACL_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACL_REVISION_INFORMATION {
    pub AclRevision: DWORD,
}
#[test]
fn bindgen_test_layout__ACL_REVISION_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_ACL_REVISION_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ACL_REVISION_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_ACL_REVISION_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACL_REVISION_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACL_REVISION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AclRevision) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACL_REVISION_INFORMATION),
            "::",
            stringify!(AclRevision)
        )
    );
}
pub type ACL_REVISION_INFORMATION = _ACL_REVISION_INFORMATION;
pub type PACL_REVISION_INFORMATION = *mut ACL_REVISION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACL_SIZE_INFORMATION {
    pub AceCount: DWORD,
    pub AclBytesInUse: DWORD,
    pub AclBytesFree: DWORD,
}
#[test]
fn bindgen_test_layout__ACL_SIZE_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_ACL_SIZE_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ACL_SIZE_INFORMATION>(),
        12usize,
        concat!("Size of: ", stringify!(_ACL_SIZE_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACL_SIZE_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACL_SIZE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AceCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACL_SIZE_INFORMATION),
            "::",
            stringify!(AceCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AclBytesInUse) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACL_SIZE_INFORMATION),
            "::",
            stringify!(AclBytesInUse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AclBytesFree) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACL_SIZE_INFORMATION),
            "::",
            stringify!(AclBytesFree)
        )
    );
}
pub type ACL_SIZE_INFORMATION = _ACL_SIZE_INFORMATION;
pub type PACL_SIZE_INFORMATION = *mut ACL_SIZE_INFORMATION;
pub type SECURITY_DESCRIPTOR_CONTROL = WORD;
pub type PSECURITY_DESCRIPTOR_CONTROL = *mut WORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_DESCRIPTOR_RELATIVE {
    pub Revision: BYTE,
    pub Sbz1: BYTE,
    pub Control: SECURITY_DESCRIPTOR_CONTROL,
    pub Owner: DWORD,
    pub Group: DWORD,
    pub Sacl: DWORD,
    pub Dacl: DWORD,
}
#[test]
fn bindgen_test_layout__SECURITY_DESCRIPTOR_RELATIVE() {
    const UNINIT: ::std::mem::MaybeUninit<_SECURITY_DESCRIPTOR_RELATIVE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SECURITY_DESCRIPTOR_RELATIVE>(),
        20usize,
        concat!("Size of: ", stringify!(_SECURITY_DESCRIPTOR_RELATIVE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SECURITY_DESCRIPTOR_RELATIVE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SECURITY_DESCRIPTOR_RELATIVE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Revision) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
            "::",
            stringify!(Revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sbz1) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
            "::",
            stringify!(Sbz1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Control) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
            "::",
            stringify!(Control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Owner) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
            "::",
            stringify!(Owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Group) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
            "::",
            stringify!(Group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sacl) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
            "::",
            stringify!(Sacl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Dacl) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
            "::",
            stringify!(Dacl)
        )
    );
}
pub type SECURITY_DESCRIPTOR_RELATIVE = _SECURITY_DESCRIPTOR_RELATIVE;
pub type PISECURITY_DESCRIPTOR_RELATIVE = *mut _SECURITY_DESCRIPTOR_RELATIVE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_DESCRIPTOR {
    pub Revision: BYTE,
    pub Sbz1: BYTE,
    pub Control: SECURITY_DESCRIPTOR_CONTROL,
    pub Owner: PSID,
    pub Group: PSID,
    pub Sacl: PACL,
    pub Dacl: PACL,
}
#[test]
fn bindgen_test_layout__SECURITY_DESCRIPTOR() {
    const UNINIT: ::std::mem::MaybeUninit<_SECURITY_DESCRIPTOR> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SECURITY_DESCRIPTOR>(),
        40usize,
        concat!("Size of: ", stringify!(_SECURITY_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_SECURITY_DESCRIPTOR>(),
        8usize,
        concat!("Alignment of ", stringify!(_SECURITY_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Revision) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR),
            "::",
            stringify!(Revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sbz1) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR),
            "::",
            stringify!(Sbz1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Control) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR),
            "::",
            stringify!(Control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR),
            "::",
            stringify!(Owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Group) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR),
            "::",
            stringify!(Group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sacl) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR),
            "::",
            stringify!(Sacl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Dacl) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR),
            "::",
            stringify!(Dacl)
        )
    );
}
pub type SECURITY_DESCRIPTOR = _SECURITY_DESCRIPTOR;
pub type PISECURITY_DESCRIPTOR = *mut _SECURITY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_OBJECT_AI_PARAMS {
    pub Size: DWORD,
    pub ConstraintMask: DWORD,
}
#[test]
fn bindgen_test_layout__SECURITY_OBJECT_AI_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_SECURITY_OBJECT_AI_PARAMS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SECURITY_OBJECT_AI_PARAMS>(),
        8usize,
        concat!("Size of: ", stringify!(_SECURITY_OBJECT_AI_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_SECURITY_OBJECT_AI_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_SECURITY_OBJECT_AI_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_OBJECT_AI_PARAMS),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConstraintMask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_OBJECT_AI_PARAMS),
            "::",
            stringify!(ConstraintMask)
        )
    );
}
pub type SECURITY_OBJECT_AI_PARAMS = _SECURITY_OBJECT_AI_PARAMS;
pub type PSECURITY_OBJECT_AI_PARAMS = *mut _SECURITY_OBJECT_AI_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_TYPE_LIST {
    pub Level: WORD,
    pub Sbz: WORD,
    pub ObjectType: *mut GUID,
}
#[test]
fn bindgen_test_layout__OBJECT_TYPE_LIST() {
    const UNINIT: ::std::mem::MaybeUninit<_OBJECT_TYPE_LIST> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OBJECT_TYPE_LIST>(),
        16usize,
        concat!("Size of: ", stringify!(_OBJECT_TYPE_LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<_OBJECT_TYPE_LIST>(),
        8usize,
        concat!("Alignment of ", stringify!(_OBJECT_TYPE_LIST))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_LIST),
            "::",
            stringify!(Level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sbz) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_LIST),
            "::",
            stringify!(Sbz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_LIST),
            "::",
            stringify!(ObjectType)
        )
    );
}
pub type OBJECT_TYPE_LIST = _OBJECT_TYPE_LIST;
pub type POBJECT_TYPE_LIST = *mut _OBJECT_TYPE_LIST;
pub const _AUDIT_EVENT_TYPE_AuditEventObjectAccess: _AUDIT_EVENT_TYPE = 0;
pub const _AUDIT_EVENT_TYPE_AuditEventDirectoryServiceAccess: _AUDIT_EVENT_TYPE = 1;
pub type _AUDIT_EVENT_TYPE = ::std::os::raw::c_uint;
pub use self::_AUDIT_EVENT_TYPE as AUDIT_EVENT_TYPE;
pub type PAUDIT_EVENT_TYPE = *mut _AUDIT_EVENT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRIVILEGE_SET {
    pub PrivilegeCount: DWORD,
    pub Control: DWORD,
    pub Privilege: [LUID_AND_ATTRIBUTES; 1usize],
}
#[test]
fn bindgen_test_layout__PRIVILEGE_SET() {
    const UNINIT: ::std::mem::MaybeUninit<_PRIVILEGE_SET> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PRIVILEGE_SET>(),
        20usize,
        concat!("Size of: ", stringify!(_PRIVILEGE_SET))
    );
    assert_eq!(
        ::std::mem::align_of::<_PRIVILEGE_SET>(),
        4usize,
        concat!("Alignment of ", stringify!(_PRIVILEGE_SET))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrivilegeCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PRIVILEGE_SET),
            "::",
            stringify!(PrivilegeCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Control) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PRIVILEGE_SET),
            "::",
            stringify!(Control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Privilege) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PRIVILEGE_SET),
            "::",
            stringify!(Privilege)
        )
    );
}
pub type PRIVILEGE_SET = _PRIVILEGE_SET;
pub type PPRIVILEGE_SET = *mut _PRIVILEGE_SET;
pub const _ACCESS_REASON_TYPE_AccessReasonNone: _ACCESS_REASON_TYPE = 0;
pub const _ACCESS_REASON_TYPE_AccessReasonAllowedAce: _ACCESS_REASON_TYPE = 65536;
pub const _ACCESS_REASON_TYPE_AccessReasonDeniedAce: _ACCESS_REASON_TYPE = 131072;
pub const _ACCESS_REASON_TYPE_AccessReasonAllowedParentAce: _ACCESS_REASON_TYPE = 196608;
pub const _ACCESS_REASON_TYPE_AccessReasonDeniedParentAce: _ACCESS_REASON_TYPE = 262144;
pub const _ACCESS_REASON_TYPE_AccessReasonNotGrantedByCape: _ACCESS_REASON_TYPE = 327680;
pub const _ACCESS_REASON_TYPE_AccessReasonNotGrantedByParentCape: _ACCESS_REASON_TYPE = 393216;
pub const _ACCESS_REASON_TYPE_AccessReasonNotGrantedToAppContainer: _ACCESS_REASON_TYPE = 458752;
pub const _ACCESS_REASON_TYPE_AccessReasonMissingPrivilege: _ACCESS_REASON_TYPE = 1048576;
pub const _ACCESS_REASON_TYPE_AccessReasonFromPrivilege: _ACCESS_REASON_TYPE = 2097152;
pub const _ACCESS_REASON_TYPE_AccessReasonIntegrityLevel: _ACCESS_REASON_TYPE = 3145728;
pub const _ACCESS_REASON_TYPE_AccessReasonOwnership: _ACCESS_REASON_TYPE = 4194304;
pub const _ACCESS_REASON_TYPE_AccessReasonNullDacl: _ACCESS_REASON_TYPE = 5242880;
pub const _ACCESS_REASON_TYPE_AccessReasonEmptyDacl: _ACCESS_REASON_TYPE = 6291456;
pub const _ACCESS_REASON_TYPE_AccessReasonNoSD: _ACCESS_REASON_TYPE = 7340032;
pub const _ACCESS_REASON_TYPE_AccessReasonNoGrant: _ACCESS_REASON_TYPE = 8388608;
pub const _ACCESS_REASON_TYPE_AccessReasonTrustLabel: _ACCESS_REASON_TYPE = 9437184;
pub const _ACCESS_REASON_TYPE_AccessReasonFilterAce: _ACCESS_REASON_TYPE = 10485760;
pub type _ACCESS_REASON_TYPE = ::std::os::raw::c_uint;
pub use self::_ACCESS_REASON_TYPE as ACCESS_REASON_TYPE;
pub type ACCESS_REASON = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_REASONS {
    pub Data: [ACCESS_REASON; 32usize],
}
#[test]
fn bindgen_test_layout__ACCESS_REASONS() {
    const UNINIT: ::std::mem::MaybeUninit<_ACCESS_REASONS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ACCESS_REASONS>(),
        128usize,
        concat!("Size of: ", stringify!(_ACCESS_REASONS))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACCESS_REASONS>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACCESS_REASONS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_REASONS),
            "::",
            stringify!(Data)
        )
    );
}
pub type ACCESS_REASONS = _ACCESS_REASONS;
pub type PACCESS_REASONS = *mut _ACCESS_REASONS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_SECURITY_DESCRIPTOR {
    pub Size: DWORD,
    pub Flags: DWORD,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
}
#[test]
fn bindgen_test_layout__SE_SECURITY_DESCRIPTOR() {
    const UNINIT: ::std::mem::MaybeUninit<_SE_SECURITY_DESCRIPTOR> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SE_SECURITY_DESCRIPTOR>(),
        16usize,
        concat!("Size of: ", stringify!(_SE_SECURITY_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_SE_SECURITY_DESCRIPTOR>(),
        8usize,
        concat!("Alignment of ", stringify!(_SE_SECURITY_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_SECURITY_DESCRIPTOR),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_SECURITY_DESCRIPTOR),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SecurityDescriptor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_SECURITY_DESCRIPTOR),
            "::",
            stringify!(SecurityDescriptor)
        )
    );
}
pub type SE_SECURITY_DESCRIPTOR = _SE_SECURITY_DESCRIPTOR;
pub type PSE_SECURITY_DESCRIPTOR = *mut _SE_SECURITY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ACCESS_REQUEST {
    pub Size: DWORD,
    pub SeSecurityDescriptor: PSE_SECURITY_DESCRIPTOR,
    pub DesiredAccess: ACCESS_MASK,
    pub PreviouslyGrantedAccess: ACCESS_MASK,
    pub PrincipalSelfSid: PSID,
    pub GenericMapping: PGENERIC_MAPPING,
    pub ObjectTypeListCount: DWORD,
    pub ObjectTypeList: POBJECT_TYPE_LIST,
}
#[test]
fn bindgen_test_layout__SE_ACCESS_REQUEST() {
    const UNINIT: ::std::mem::MaybeUninit<_SE_ACCESS_REQUEST> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SE_ACCESS_REQUEST>(),
        56usize,
        concat!("Size of: ", stringify!(_SE_ACCESS_REQUEST))
    );
    assert_eq!(
        ::std::mem::align_of::<_SE_ACCESS_REQUEST>(),
        8usize,
        concat!("Alignment of ", stringify!(_SE_ACCESS_REQUEST))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REQUEST),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SeSecurityDescriptor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REQUEST),
            "::",
            stringify!(SeSecurityDescriptor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DesiredAccess) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REQUEST),
            "::",
            stringify!(DesiredAccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PreviouslyGrantedAccess) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REQUEST),
            "::",
            stringify!(PreviouslyGrantedAccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrincipalSelfSid) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REQUEST),
            "::",
            stringify!(PrincipalSelfSid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GenericMapping) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REQUEST),
            "::",
            stringify!(GenericMapping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectTypeListCount) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REQUEST),
            "::",
            stringify!(ObjectTypeListCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectTypeList) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REQUEST),
            "::",
            stringify!(ObjectTypeList)
        )
    );
}
pub type SE_ACCESS_REQUEST = _SE_ACCESS_REQUEST;
pub type PSE_ACCESS_REQUEST = *mut _SE_ACCESS_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ACCESS_REPLY {
    pub Size: DWORD,
    pub ResultListCount: DWORD,
    pub GrantedAccess: PACCESS_MASK,
    pub AccessStatus: PDWORD,
    pub AccessReason: PACCESS_REASONS,
    pub Privileges: *mut PPRIVILEGE_SET,
}
#[test]
fn bindgen_test_layout__SE_ACCESS_REPLY() {
    const UNINIT: ::std::mem::MaybeUninit<_SE_ACCESS_REPLY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SE_ACCESS_REPLY>(),
        40usize,
        concat!("Size of: ", stringify!(_SE_ACCESS_REPLY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SE_ACCESS_REPLY>(),
        8usize,
        concat!("Alignment of ", stringify!(_SE_ACCESS_REPLY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REPLY),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultListCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REPLY),
            "::",
            stringify!(ResultListCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GrantedAccess) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REPLY),
            "::",
            stringify!(GrantedAccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccessStatus) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REPLY),
            "::",
            stringify!(AccessStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccessReason) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REPLY),
            "::",
            stringify!(AccessReason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Privileges) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REPLY),
            "::",
            stringify!(Privileges)
        )
    );
}
pub type SE_ACCESS_REPLY = _SE_ACCESS_REPLY;
pub type PSE_ACCESS_REPLY = *mut _SE_ACCESS_REPLY;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityAnonymous: _SECURITY_IMPERSONATION_LEVEL = 0;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityIdentification: _SECURITY_IMPERSONATION_LEVEL = 1;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityImpersonation: _SECURITY_IMPERSONATION_LEVEL = 2;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityDelegation: _SECURITY_IMPERSONATION_LEVEL = 3;
pub type _SECURITY_IMPERSONATION_LEVEL = ::std::os::raw::c_uint;
pub use self::_SECURITY_IMPERSONATION_LEVEL as SECURITY_IMPERSONATION_LEVEL;
pub type PSECURITY_IMPERSONATION_LEVEL = *mut _SECURITY_IMPERSONATION_LEVEL;
pub const _TOKEN_TYPE_TokenPrimary: _TOKEN_TYPE = 1;
pub const _TOKEN_TYPE_TokenImpersonation: _TOKEN_TYPE = 2;
pub type _TOKEN_TYPE = ::std::os::raw::c_uint;
pub use self::_TOKEN_TYPE as TOKEN_TYPE;
pub type PTOKEN_TYPE = *mut TOKEN_TYPE;
pub const _TOKEN_ELEVATION_TYPE_TokenElevationTypeDefault: _TOKEN_ELEVATION_TYPE = 1;
pub const _TOKEN_ELEVATION_TYPE_TokenElevationTypeFull: _TOKEN_ELEVATION_TYPE = 2;
pub const _TOKEN_ELEVATION_TYPE_TokenElevationTypeLimited: _TOKEN_ELEVATION_TYPE = 3;
pub type _TOKEN_ELEVATION_TYPE = ::std::os::raw::c_uint;
pub use self::_TOKEN_ELEVATION_TYPE as TOKEN_ELEVATION_TYPE;
pub type PTOKEN_ELEVATION_TYPE = *mut _TOKEN_ELEVATION_TYPE;
pub const _TOKEN_INFORMATION_CLASS_TokenUser: _TOKEN_INFORMATION_CLASS = 1;
pub const _TOKEN_INFORMATION_CLASS_TokenGroups: _TOKEN_INFORMATION_CLASS = 2;
pub const _TOKEN_INFORMATION_CLASS_TokenPrivileges: _TOKEN_INFORMATION_CLASS = 3;
pub const _TOKEN_INFORMATION_CLASS_TokenOwner: _TOKEN_INFORMATION_CLASS = 4;
pub const _TOKEN_INFORMATION_CLASS_TokenPrimaryGroup: _TOKEN_INFORMATION_CLASS = 5;
pub const _TOKEN_INFORMATION_CLASS_TokenDefaultDacl: _TOKEN_INFORMATION_CLASS = 6;
pub const _TOKEN_INFORMATION_CLASS_TokenSource: _TOKEN_INFORMATION_CLASS = 7;
pub const _TOKEN_INFORMATION_CLASS_TokenType: _TOKEN_INFORMATION_CLASS = 8;
pub const _TOKEN_INFORMATION_CLASS_TokenImpersonationLevel: _TOKEN_INFORMATION_CLASS = 9;
pub const _TOKEN_INFORMATION_CLASS_TokenStatistics: _TOKEN_INFORMATION_CLASS = 10;
pub const _TOKEN_INFORMATION_CLASS_TokenRestrictedSids: _TOKEN_INFORMATION_CLASS = 11;
pub const _TOKEN_INFORMATION_CLASS_TokenSessionId: _TOKEN_INFORMATION_CLASS = 12;
pub const _TOKEN_INFORMATION_CLASS_TokenGroupsAndPrivileges: _TOKEN_INFORMATION_CLASS = 13;
pub const _TOKEN_INFORMATION_CLASS_TokenSessionReference: _TOKEN_INFORMATION_CLASS = 14;
pub const _TOKEN_INFORMATION_CLASS_TokenSandBoxInert: _TOKEN_INFORMATION_CLASS = 15;
pub const _TOKEN_INFORMATION_CLASS_TokenAuditPolicy: _TOKEN_INFORMATION_CLASS = 16;
pub const _TOKEN_INFORMATION_CLASS_TokenOrigin: _TOKEN_INFORMATION_CLASS = 17;
pub const _TOKEN_INFORMATION_CLASS_TokenElevationType: _TOKEN_INFORMATION_CLASS = 18;
pub const _TOKEN_INFORMATION_CLASS_TokenLinkedToken: _TOKEN_INFORMATION_CLASS = 19;
pub const _TOKEN_INFORMATION_CLASS_TokenElevation: _TOKEN_INFORMATION_CLASS = 20;
pub const _TOKEN_INFORMATION_CLASS_TokenHasRestrictions: _TOKEN_INFORMATION_CLASS = 21;
pub const _TOKEN_INFORMATION_CLASS_TokenAccessInformation: _TOKEN_INFORMATION_CLASS = 22;
pub const _TOKEN_INFORMATION_CLASS_TokenVirtualizationAllowed: _TOKEN_INFORMATION_CLASS = 23;
pub const _TOKEN_INFORMATION_CLASS_TokenVirtualizationEnabled: _TOKEN_INFORMATION_CLASS = 24;
pub const _TOKEN_INFORMATION_CLASS_TokenIntegrityLevel: _TOKEN_INFORMATION_CLASS = 25;
pub const _TOKEN_INFORMATION_CLASS_TokenUIAccess: _TOKEN_INFORMATION_CLASS = 26;
pub const _TOKEN_INFORMATION_CLASS_TokenMandatoryPolicy: _TOKEN_INFORMATION_CLASS = 27;
pub const _TOKEN_INFORMATION_CLASS_TokenLogonSid: _TOKEN_INFORMATION_CLASS = 28;
pub const _TOKEN_INFORMATION_CLASS_TokenIsAppContainer: _TOKEN_INFORMATION_CLASS = 29;
pub const _TOKEN_INFORMATION_CLASS_TokenCapabilities: _TOKEN_INFORMATION_CLASS = 30;
pub const _TOKEN_INFORMATION_CLASS_TokenAppContainerSid: _TOKEN_INFORMATION_CLASS = 31;
pub const _TOKEN_INFORMATION_CLASS_TokenAppContainerNumber: _TOKEN_INFORMATION_CLASS = 32;
pub const _TOKEN_INFORMATION_CLASS_TokenUserClaimAttributes: _TOKEN_INFORMATION_CLASS = 33;
pub const _TOKEN_INFORMATION_CLASS_TokenDeviceClaimAttributes: _TOKEN_INFORMATION_CLASS = 34;
pub const _TOKEN_INFORMATION_CLASS_TokenRestrictedUserClaimAttributes: _TOKEN_INFORMATION_CLASS =
    35;
pub const _TOKEN_INFORMATION_CLASS_TokenRestrictedDeviceClaimAttributes: _TOKEN_INFORMATION_CLASS =
    36;
pub const _TOKEN_INFORMATION_CLASS_TokenDeviceGroups: _TOKEN_INFORMATION_CLASS = 37;
pub const _TOKEN_INFORMATION_CLASS_TokenRestrictedDeviceGroups: _TOKEN_INFORMATION_CLASS = 38;
pub const _TOKEN_INFORMATION_CLASS_TokenSecurityAttributes: _TOKEN_INFORMATION_CLASS = 39;
pub const _TOKEN_INFORMATION_CLASS_TokenIsRestricted: _TOKEN_INFORMATION_CLASS = 40;
pub const _TOKEN_INFORMATION_CLASS_TokenProcessTrustLevel: _TOKEN_INFORMATION_CLASS = 41;
pub const _TOKEN_INFORMATION_CLASS_TokenPrivateNameSpace: _TOKEN_INFORMATION_CLASS = 42;
pub const _TOKEN_INFORMATION_CLASS_TokenSingletonAttributes: _TOKEN_INFORMATION_CLASS = 43;
pub const _TOKEN_INFORMATION_CLASS_TokenBnoIsolation: _TOKEN_INFORMATION_CLASS = 44;
pub const _TOKEN_INFORMATION_CLASS_TokenChildProcessFlags: _TOKEN_INFORMATION_CLASS = 45;
pub const _TOKEN_INFORMATION_CLASS_TokenIsLessPrivilegedAppContainer: _TOKEN_INFORMATION_CLASS = 46;
pub const _TOKEN_INFORMATION_CLASS_TokenIsSandboxed: _TOKEN_INFORMATION_CLASS = 47;
pub const _TOKEN_INFORMATION_CLASS_TokenIsAppSilo: _TOKEN_INFORMATION_CLASS = 48;
pub const _TOKEN_INFORMATION_CLASS_MaxTokenInfoClass: _TOKEN_INFORMATION_CLASS = 49;
pub type _TOKEN_INFORMATION_CLASS = ::std::os::raw::c_uint;
pub use self::_TOKEN_INFORMATION_CLASS as TOKEN_INFORMATION_CLASS;
pub type PTOKEN_INFORMATION_CLASS = *mut _TOKEN_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_USER {
    pub User: SID_AND_ATTRIBUTES,
}
#[test]
fn bindgen_test_layout__TOKEN_USER() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_USER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_USER>(),
        16usize,
        concat!("Size of: ", stringify!(_TOKEN_USER))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_USER>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_USER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).User) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_USER),
            "::",
            stringify!(User)
        )
    );
}
pub type TOKEN_USER = _TOKEN_USER;
pub type PTOKEN_USER = *mut _TOKEN_USER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SE_TOKEN_USER {
    pub __bindgen_anon_1: _SE_TOKEN_USER__bindgen_ty_1,
    pub __bindgen_anon_2: _SE_TOKEN_USER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SE_TOKEN_USER__bindgen_ty_1 {
    pub TokenUser: TOKEN_USER,
    pub User: SID_AND_ATTRIBUTES,
}
#[test]
fn bindgen_test_layout__SE_TOKEN_USER__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SE_TOKEN_USER__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SE_TOKEN_USER__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_SE_TOKEN_USER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SE_TOKEN_USER__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_SE_TOKEN_USER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TokenUser) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_TOKEN_USER__bindgen_ty_1),
            "::",
            stringify!(TokenUser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).User) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_TOKEN_USER__bindgen_ty_1),
            "::",
            stringify!(User)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SE_TOKEN_USER__bindgen_ty_2 {
    pub Sid: SID,
    pub Buffer: [BYTE; 68usize],
}
#[test]
fn bindgen_test_layout__SE_TOKEN_USER__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_SE_TOKEN_USER__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SE_TOKEN_USER__bindgen_ty_2>(),
        68usize,
        concat!("Size of: ", stringify!(_SE_TOKEN_USER__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_SE_TOKEN_USER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_SE_TOKEN_USER__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_TOKEN_USER__bindgen_ty_2),
            "::",
            stringify!(Sid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_TOKEN_USER__bindgen_ty_2),
            "::",
            stringify!(Buffer)
        )
    );
}
#[test]
fn bindgen_test_layout__SE_TOKEN_USER() {
    assert_eq!(
        ::std::mem::size_of::<_SE_TOKEN_USER>(),
        88usize,
        concat!("Size of: ", stringify!(_SE_TOKEN_USER))
    );
    assert_eq!(
        ::std::mem::align_of::<_SE_TOKEN_USER>(),
        8usize,
        concat!("Alignment of ", stringify!(_SE_TOKEN_USER))
    );
}
pub type SE_TOKEN_USER = _SE_TOKEN_USER;
pub type PSE_TOKEN_USER = *mut _SE_TOKEN_USER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_GROUPS {
    pub GroupCount: DWORD,
    pub Groups: [SID_AND_ATTRIBUTES; 1usize],
}
#[test]
fn bindgen_test_layout__TOKEN_GROUPS() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_GROUPS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_GROUPS>(),
        24usize,
        concat!("Size of: ", stringify!(_TOKEN_GROUPS))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_GROUPS>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_GROUPS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GroupCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS),
            "::",
            stringify!(GroupCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Groups) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS),
            "::",
            stringify!(Groups)
        )
    );
}
pub type TOKEN_GROUPS = _TOKEN_GROUPS;
pub type PTOKEN_GROUPS = *mut _TOKEN_GROUPS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_PRIVILEGES {
    pub PrivilegeCount: DWORD,
    pub Privileges: [LUID_AND_ATTRIBUTES; 1usize],
}
#[test]
fn bindgen_test_layout__TOKEN_PRIVILEGES() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_PRIVILEGES> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_PRIVILEGES>(),
        16usize,
        concat!("Size of: ", stringify!(_TOKEN_PRIVILEGES))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_PRIVILEGES>(),
        4usize,
        concat!("Alignment of ", stringify!(_TOKEN_PRIVILEGES))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrivilegeCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_PRIVILEGES),
            "::",
            stringify!(PrivilegeCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Privileges) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_PRIVILEGES),
            "::",
            stringify!(Privileges)
        )
    );
}
pub type TOKEN_PRIVILEGES = _TOKEN_PRIVILEGES;
pub type PTOKEN_PRIVILEGES = *mut _TOKEN_PRIVILEGES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_OWNER {
    pub Owner: PSID,
}
#[test]
fn bindgen_test_layout__TOKEN_OWNER() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_OWNER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_OWNER>(),
        8usize,
        concat!("Size of: ", stringify!(_TOKEN_OWNER))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_OWNER>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_OWNER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Owner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_OWNER),
            "::",
            stringify!(Owner)
        )
    );
}
pub type TOKEN_OWNER = _TOKEN_OWNER;
pub type PTOKEN_OWNER = *mut _TOKEN_OWNER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_PRIMARY_GROUP {
    pub PrimaryGroup: PSID,
}
#[test]
fn bindgen_test_layout__TOKEN_PRIMARY_GROUP() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_PRIMARY_GROUP> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_PRIMARY_GROUP>(),
        8usize,
        concat!("Size of: ", stringify!(_TOKEN_PRIMARY_GROUP))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_PRIMARY_GROUP>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_PRIMARY_GROUP))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrimaryGroup) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_PRIMARY_GROUP),
            "::",
            stringify!(PrimaryGroup)
        )
    );
}
pub type TOKEN_PRIMARY_GROUP = _TOKEN_PRIMARY_GROUP;
pub type PTOKEN_PRIMARY_GROUP = *mut _TOKEN_PRIMARY_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_DEFAULT_DACL {
    pub DefaultDacl: PACL,
}
#[test]
fn bindgen_test_layout__TOKEN_DEFAULT_DACL() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_DEFAULT_DACL> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_DEFAULT_DACL>(),
        8usize,
        concat!("Size of: ", stringify!(_TOKEN_DEFAULT_DACL))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_DEFAULT_DACL>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_DEFAULT_DACL))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DefaultDacl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_DEFAULT_DACL),
            "::",
            stringify!(DefaultDacl)
        )
    );
}
pub type TOKEN_DEFAULT_DACL = _TOKEN_DEFAULT_DACL;
pub type PTOKEN_DEFAULT_DACL = *mut _TOKEN_DEFAULT_DACL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_USER_CLAIMS {
    pub UserClaims: PCLAIMS_BLOB,
}
#[test]
fn bindgen_test_layout__TOKEN_USER_CLAIMS() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_USER_CLAIMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_USER_CLAIMS>(),
        8usize,
        concat!("Size of: ", stringify!(_TOKEN_USER_CLAIMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_USER_CLAIMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_USER_CLAIMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserClaims) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_USER_CLAIMS),
            "::",
            stringify!(UserClaims)
        )
    );
}
pub type TOKEN_USER_CLAIMS = _TOKEN_USER_CLAIMS;
pub type PTOKEN_USER_CLAIMS = *mut _TOKEN_USER_CLAIMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_DEVICE_CLAIMS {
    pub DeviceClaims: PCLAIMS_BLOB,
}
#[test]
fn bindgen_test_layout__TOKEN_DEVICE_CLAIMS() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_DEVICE_CLAIMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_DEVICE_CLAIMS>(),
        8usize,
        concat!("Size of: ", stringify!(_TOKEN_DEVICE_CLAIMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_DEVICE_CLAIMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_DEVICE_CLAIMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeviceClaims) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_DEVICE_CLAIMS),
            "::",
            stringify!(DeviceClaims)
        )
    );
}
pub type TOKEN_DEVICE_CLAIMS = _TOKEN_DEVICE_CLAIMS;
pub type PTOKEN_DEVICE_CLAIMS = *mut _TOKEN_DEVICE_CLAIMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_GROUPS_AND_PRIVILEGES {
    pub SidCount: DWORD,
    pub SidLength: DWORD,
    pub Sids: PSID_AND_ATTRIBUTES,
    pub RestrictedSidCount: DWORD,
    pub RestrictedSidLength: DWORD,
    pub RestrictedSids: PSID_AND_ATTRIBUTES,
    pub PrivilegeCount: DWORD,
    pub PrivilegeLength: DWORD,
    pub Privileges: PLUID_AND_ATTRIBUTES,
    pub AuthenticationId: LUID,
}
#[test]
fn bindgen_test_layout__TOKEN_GROUPS_AND_PRIVILEGES() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_GROUPS_AND_PRIVILEGES> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_GROUPS_AND_PRIVILEGES>(),
        56usize,
        concat!("Size of: ", stringify!(_TOKEN_GROUPS_AND_PRIVILEGES))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_GROUPS_AND_PRIVILEGES>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_GROUPS_AND_PRIVILEGES))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
            "::",
            stringify!(SidCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
            "::",
            stringify!(SidLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sids) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
            "::",
            stringify!(Sids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RestrictedSidCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
            "::",
            stringify!(RestrictedSidCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RestrictedSidLength) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
            "::",
            stringify!(RestrictedSidLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RestrictedSids) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
            "::",
            stringify!(RestrictedSids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrivilegeCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
            "::",
            stringify!(PrivilegeCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrivilegeLength) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
            "::",
            stringify!(PrivilegeLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Privileges) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
            "::",
            stringify!(Privileges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AuthenticationId) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
            "::",
            stringify!(AuthenticationId)
        )
    );
}
pub type TOKEN_GROUPS_AND_PRIVILEGES = _TOKEN_GROUPS_AND_PRIVILEGES;
pub type PTOKEN_GROUPS_AND_PRIVILEGES = *mut _TOKEN_GROUPS_AND_PRIVILEGES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_LINKED_TOKEN {
    pub LinkedToken: HANDLE,
}
#[test]
fn bindgen_test_layout__TOKEN_LINKED_TOKEN() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_LINKED_TOKEN> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_LINKED_TOKEN>(),
        8usize,
        concat!("Size of: ", stringify!(_TOKEN_LINKED_TOKEN))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_LINKED_TOKEN>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_LINKED_TOKEN))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LinkedToken) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_LINKED_TOKEN),
            "::",
            stringify!(LinkedToken)
        )
    );
}
pub type TOKEN_LINKED_TOKEN = _TOKEN_LINKED_TOKEN;
pub type PTOKEN_LINKED_TOKEN = *mut _TOKEN_LINKED_TOKEN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_ELEVATION {
    pub TokenIsElevated: DWORD,
}
#[test]
fn bindgen_test_layout__TOKEN_ELEVATION() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_ELEVATION> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_ELEVATION>(),
        4usize,
        concat!("Size of: ", stringify!(_TOKEN_ELEVATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_ELEVATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_TOKEN_ELEVATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TokenIsElevated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ELEVATION),
            "::",
            stringify!(TokenIsElevated)
        )
    );
}
pub type TOKEN_ELEVATION = _TOKEN_ELEVATION;
pub type PTOKEN_ELEVATION = *mut _TOKEN_ELEVATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_MANDATORY_LABEL {
    pub Label: SID_AND_ATTRIBUTES,
}
#[test]
fn bindgen_test_layout__TOKEN_MANDATORY_LABEL() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_MANDATORY_LABEL> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_MANDATORY_LABEL>(),
        16usize,
        concat!("Size of: ", stringify!(_TOKEN_MANDATORY_LABEL))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_MANDATORY_LABEL>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_MANDATORY_LABEL))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Label) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_MANDATORY_LABEL),
            "::",
            stringify!(Label)
        )
    );
}
pub type TOKEN_MANDATORY_LABEL = _TOKEN_MANDATORY_LABEL;
pub type PTOKEN_MANDATORY_LABEL = *mut _TOKEN_MANDATORY_LABEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_MANDATORY_POLICY {
    pub Policy: DWORD,
}
#[test]
fn bindgen_test_layout__TOKEN_MANDATORY_POLICY() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_MANDATORY_POLICY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_MANDATORY_POLICY>(),
        4usize,
        concat!("Size of: ", stringify!(_TOKEN_MANDATORY_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_MANDATORY_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(_TOKEN_MANDATORY_POLICY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Policy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_MANDATORY_POLICY),
            "::",
            stringify!(Policy)
        )
    );
}
pub type TOKEN_MANDATORY_POLICY = _TOKEN_MANDATORY_POLICY;
pub type PTOKEN_MANDATORY_POLICY = *mut _TOKEN_MANDATORY_POLICY;
pub type PSECURITY_ATTRIBUTES_OPAQUE = PVOID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_ACCESS_INFORMATION {
    pub SidHash: PSID_AND_ATTRIBUTES_HASH,
    pub RestrictedSidHash: PSID_AND_ATTRIBUTES_HASH,
    pub Privileges: PTOKEN_PRIVILEGES,
    pub AuthenticationId: LUID,
    pub TokenType: TOKEN_TYPE,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub MandatoryPolicy: TOKEN_MANDATORY_POLICY,
    pub Flags: DWORD,
    pub AppContainerNumber: DWORD,
    pub PackageSid: PSID,
    pub CapabilitiesHash: PSID_AND_ATTRIBUTES_HASH,
}
#[test]
fn bindgen_test_layout__TOKEN_ACCESS_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_ACCESS_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_ACCESS_INFORMATION>(),
        72usize,
        concat!("Size of: ", stringify!(_TOKEN_ACCESS_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_ACCESS_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_ACCESS_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidHash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(SidHash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RestrictedSidHash) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(RestrictedSidHash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Privileges) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(Privileges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AuthenticationId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(AuthenticationId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TokenType) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(TokenType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ImpersonationLevel) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(ImpersonationLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MandatoryPolicy) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(MandatoryPolicy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AppContainerNumber) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(AppContainerNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PackageSid) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(PackageSid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CapabilitiesHash) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(CapabilitiesHash)
        )
    );
}
pub type TOKEN_ACCESS_INFORMATION = _TOKEN_ACCESS_INFORMATION;
pub type PTOKEN_ACCESS_INFORMATION = *mut _TOKEN_ACCESS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_AUDIT_POLICY {
    pub PerUserPolicy: [UCHAR; 29usize],
}
#[test]
fn bindgen_test_layout__TOKEN_AUDIT_POLICY() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_AUDIT_POLICY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_AUDIT_POLICY>(),
        29usize,
        concat!("Size of: ", stringify!(_TOKEN_AUDIT_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_AUDIT_POLICY>(),
        1usize,
        concat!("Alignment of ", stringify!(_TOKEN_AUDIT_POLICY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PerUserPolicy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_AUDIT_POLICY),
            "::",
            stringify!(PerUserPolicy)
        )
    );
}
pub type TOKEN_AUDIT_POLICY = _TOKEN_AUDIT_POLICY;
pub type PTOKEN_AUDIT_POLICY = *mut _TOKEN_AUDIT_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_SOURCE {
    pub SourceName: [CHAR; 8usize],
    pub SourceIdentifier: LUID,
}
#[test]
fn bindgen_test_layout__TOKEN_SOURCE() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_SOURCE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_SOURCE>(),
        16usize,
        concat!("Size of: ", stringify!(_TOKEN_SOURCE))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_SOURCE>(),
        4usize,
        concat!("Alignment of ", stringify!(_TOKEN_SOURCE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SourceName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_SOURCE),
            "::",
            stringify!(SourceName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SourceIdentifier) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_SOURCE),
            "::",
            stringify!(SourceIdentifier)
        )
    );
}
pub type TOKEN_SOURCE = _TOKEN_SOURCE;
pub type PTOKEN_SOURCE = *mut _TOKEN_SOURCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TOKEN_STATISTICS {
    pub TokenId: LUID,
    pub AuthenticationId: LUID,
    pub ExpirationTime: LARGE_INTEGER,
    pub TokenType: TOKEN_TYPE,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub DynamicCharged: DWORD,
    pub DynamicAvailable: DWORD,
    pub GroupCount: DWORD,
    pub PrivilegeCount: DWORD,
    pub ModifiedId: LUID,
}
#[test]
fn bindgen_test_layout__TOKEN_STATISTICS() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_STATISTICS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_STATISTICS>(),
        56usize,
        concat!("Size of: ", stringify!(_TOKEN_STATISTICS))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_STATISTICS>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_STATISTICS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TokenId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_STATISTICS),
            "::",
            stringify!(TokenId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AuthenticationId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_STATISTICS),
            "::",
            stringify!(AuthenticationId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExpirationTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_STATISTICS),
            "::",
            stringify!(ExpirationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TokenType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_STATISTICS),
            "::",
            stringify!(TokenType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ImpersonationLevel) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_STATISTICS),
            "::",
            stringify!(ImpersonationLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DynamicCharged) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_STATISTICS),
            "::",
            stringify!(DynamicCharged)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DynamicAvailable) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_STATISTICS),
            "::",
            stringify!(DynamicAvailable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GroupCount) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_STATISTICS),
            "::",
            stringify!(GroupCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrivilegeCount) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_STATISTICS),
            "::",
            stringify!(PrivilegeCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ModifiedId) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_STATISTICS),
            "::",
            stringify!(ModifiedId)
        )
    );
}
pub type TOKEN_STATISTICS = _TOKEN_STATISTICS;
pub type PTOKEN_STATISTICS = *mut _TOKEN_STATISTICS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_CONTROL {
    pub TokenId: LUID,
    pub AuthenticationId: LUID,
    pub ModifiedId: LUID,
    pub TokenSource: TOKEN_SOURCE,
}
#[test]
fn bindgen_test_layout__TOKEN_CONTROL() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_CONTROL> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_CONTROL>(),
        40usize,
        concat!("Size of: ", stringify!(_TOKEN_CONTROL))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_CONTROL>(),
        4usize,
        concat!("Alignment of ", stringify!(_TOKEN_CONTROL))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TokenId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_CONTROL),
            "::",
            stringify!(TokenId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AuthenticationId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_CONTROL),
            "::",
            stringify!(AuthenticationId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ModifiedId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_CONTROL),
            "::",
            stringify!(ModifiedId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TokenSource) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_CONTROL),
            "::",
            stringify!(TokenSource)
        )
    );
}
pub type TOKEN_CONTROL = _TOKEN_CONTROL;
pub type PTOKEN_CONTROL = *mut _TOKEN_CONTROL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_ORIGIN {
    pub OriginatingLogonSession: LUID,
}
#[test]
fn bindgen_test_layout__TOKEN_ORIGIN() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_ORIGIN> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_ORIGIN>(),
        8usize,
        concat!("Size of: ", stringify!(_TOKEN_ORIGIN))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_ORIGIN>(),
        4usize,
        concat!("Alignment of ", stringify!(_TOKEN_ORIGIN))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OriginatingLogonSession) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ORIGIN),
            "::",
            stringify!(OriginatingLogonSession)
        )
    );
}
pub type TOKEN_ORIGIN = _TOKEN_ORIGIN;
pub type PTOKEN_ORIGIN = *mut _TOKEN_ORIGIN;
pub const _MANDATORY_LEVEL_MandatoryLevelUntrusted: _MANDATORY_LEVEL = 0;
pub const _MANDATORY_LEVEL_MandatoryLevelLow: _MANDATORY_LEVEL = 1;
pub const _MANDATORY_LEVEL_MandatoryLevelMedium: _MANDATORY_LEVEL = 2;
pub const _MANDATORY_LEVEL_MandatoryLevelHigh: _MANDATORY_LEVEL = 3;
pub const _MANDATORY_LEVEL_MandatoryLevelSystem: _MANDATORY_LEVEL = 4;
pub const _MANDATORY_LEVEL_MandatoryLevelSecureProcess: _MANDATORY_LEVEL = 5;
pub const _MANDATORY_LEVEL_MandatoryLevelCount: _MANDATORY_LEVEL = 6;
pub type _MANDATORY_LEVEL = ::std::os::raw::c_uint;
pub use self::_MANDATORY_LEVEL as MANDATORY_LEVEL;
pub type PMANDATORY_LEVEL = *mut _MANDATORY_LEVEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_APPCONTAINER_INFORMATION {
    pub TokenAppContainer: PSID,
}
#[test]
fn bindgen_test_layout__TOKEN_APPCONTAINER_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_APPCONTAINER_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_APPCONTAINER_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_TOKEN_APPCONTAINER_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_APPCONTAINER_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_APPCONTAINER_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TokenAppContainer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_APPCONTAINER_INFORMATION),
            "::",
            stringify!(TokenAppContainer)
        )
    );
}
pub type TOKEN_APPCONTAINER_INFORMATION = _TOKEN_APPCONTAINER_INFORMATION;
pub type PTOKEN_APPCONTAINER_INFORMATION = *mut _TOKEN_APPCONTAINER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_SID_INFORMATION {
    pub Sid: PSID,
}
#[test]
fn bindgen_test_layout__TOKEN_SID_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_SID_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_SID_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_TOKEN_SID_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_SID_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_SID_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_SID_INFORMATION),
            "::",
            stringify!(Sid)
        )
    );
}
pub type TOKEN_SID_INFORMATION = _TOKEN_SID_INFORMATION;
pub type PTOKEN_SID_INFORMATION = *mut _TOKEN_SID_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_BNO_ISOLATION_INFORMATION {
    pub IsolationPrefix: PWSTR,
    pub IsolationEnabled: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TOKEN_BNO_ISOLATION_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_TOKEN_BNO_ISOLATION_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_BNO_ISOLATION_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_TOKEN_BNO_ISOLATION_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_BNO_ISOLATION_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_TOKEN_BNO_ISOLATION_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsolationPrefix) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_BNO_ISOLATION_INFORMATION),
            "::",
            stringify!(IsolationPrefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsolationEnabled) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_BNO_ISOLATION_INFORMATION),
            "::",
            stringify!(IsolationEnabled)
        )
    );
}
pub type TOKEN_BNO_ISOLATION_INFORMATION = _TOKEN_BNO_ISOLATION_INFORMATION;
pub type PTOKEN_BNO_ISOLATION_INFORMATION = *mut _TOKEN_BNO_ISOLATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
    pub Version: DWORD64,
    pub Name: PWSTR,
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE() {
    const UNINIT: ::std::mem::MaybeUninit<_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE),
            "::",
            stringify!(Name)
        )
    );
}
pub type CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;
pub type PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = *mut _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
    pub pValue: PVOID,
    pub ValueLength: DWORD,
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE() {
    const UNINIT: ::std::mem::MaybeUninit<_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE),
            "::",
            stringify!(pValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ValueLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE),
            "::",
            stringify!(ValueLength)
        )
    );
}
pub type CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE = _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
pub type PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE =
    *mut _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_V1 {
    pub Name: PWSTR,
    pub ValueType: WORD,
    pub Reserved: WORD,
    pub Flags: DWORD,
    pub ValueCount: DWORD,
    pub Values: _CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1 {
    pub pInt64: PLONG64,
    pub pUint64: PDWORD64,
    pub ppString: *mut PWSTR,
    pub pFqbn: PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE,
    pub pOctetString: PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE,
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pInt64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1),
            "::",
            stringify!(pInt64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pUint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1),
            "::",
            stringify!(pUint64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ppString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1),
            "::",
            stringify!(ppString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pFqbn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1),
            "::",
            stringify!(pFqbn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pOctetString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1),
            "::",
            stringify!(pOctetString)
        )
    );
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTE_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_CLAIM_SECURITY_ATTRIBUTE_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTE_V1>(),
        32usize,
        concat!("Size of: ", stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTE_V1>(),
        8usize,
        concat!("Alignment of ", stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ValueType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1),
            "::",
            stringify!(ValueType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ValueCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1),
            "::",
            stringify!(ValueCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Values) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1),
            "::",
            stringify!(Values)
        )
    );
}
pub type CLAIM_SECURITY_ATTRIBUTE_V1 = _CLAIM_SECURITY_ATTRIBUTE_V1;
pub type PCLAIM_SECURITY_ATTRIBUTE_V1 = *mut _CLAIM_SECURITY_ATTRIBUTE_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {
    pub Name: DWORD,
    pub ValueType: WORD,
    pub Reserved: WORD,
    pub Flags: DWORD,
    pub ValueCount: DWORD,
    pub Values: _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1 {
    pub pInt64: [DWORD; 1usize],
    pub pUint64: [DWORD; 1usize],
    pub ppString: [DWORD; 1usize],
    pub pFqbn: [DWORD; 1usize],
    pub pOctetString: [DWORD; 1usize],
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pInt64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1),
            "::",
            stringify!(pInt64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pUint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1),
            "::",
            stringify!(pUint64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ppString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1),
            "::",
            stringify!(ppString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pFqbn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1),
            "::",
            stringify!(pFqbn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pOctetString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1),
            "::",
            stringify!(pOctetString)
        )
    );
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1() {
    const UNINIT: ::std::mem::MaybeUninit<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ValueType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1),
            "::",
            stringify!(ValueType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ValueCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1),
            "::",
            stringify!(ValueCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Values) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1),
            "::",
            stringify!(Values)
        )
    );
}
pub type CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;
pub type PCLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = *mut _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTES_INFORMATION {
    pub Version: WORD,
    pub Reserved: WORD,
    pub AttributeCount: DWORD,
    pub Attribute: _CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1 {
    pub pAttributeV1: PCLAIM_SECURITY_ATTRIBUTE_V1,
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pAttributeV1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(pAttributeV1)
        )
    );
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTES_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AttributeCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION),
            "::",
            stringify!(AttributeCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Attribute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION),
            "::",
            stringify!(Attribute)
        )
    );
}
pub type CLAIM_SECURITY_ATTRIBUTES_INFORMATION = _CLAIM_SECURITY_ATTRIBUTES_INFORMATION;
pub type PCLAIM_SECURITY_ATTRIBUTES_INFORMATION = *mut _CLAIM_SECURITY_ATTRIBUTES_INFORMATION;
pub type SECURITY_CONTEXT_TRACKING_MODE = BOOLEAN;
pub type PSECURITY_CONTEXT_TRACKING_MODE = *mut BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_QUALITY_OF_SERVICE {
    pub Length: DWORD,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub ContextTrackingMode: SECURITY_CONTEXT_TRACKING_MODE,
    pub EffectiveOnly: BOOLEAN,
}
#[test]
fn bindgen_test_layout__SECURITY_QUALITY_OF_SERVICE() {
    const UNINIT: ::std::mem::MaybeUninit<_SECURITY_QUALITY_OF_SERVICE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SECURITY_QUALITY_OF_SERVICE>(),
        12usize,
        concat!("Size of: ", stringify!(_SECURITY_QUALITY_OF_SERVICE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SECURITY_QUALITY_OF_SERVICE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SECURITY_QUALITY_OF_SERVICE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_QUALITY_OF_SERVICE),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ImpersonationLevel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_QUALITY_OF_SERVICE),
            "::",
            stringify!(ImpersonationLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ContextTrackingMode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_QUALITY_OF_SERVICE),
            "::",
            stringify!(ContextTrackingMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EffectiveOnly) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_QUALITY_OF_SERVICE),
            "::",
            stringify!(EffectiveOnly)
        )
    );
}
pub type SECURITY_QUALITY_OF_SERVICE = _SECURITY_QUALITY_OF_SERVICE;
pub type PSECURITY_QUALITY_OF_SERVICE = *mut _SECURITY_QUALITY_OF_SERVICE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_IMPERSONATION_STATE {
    pub Token: PACCESS_TOKEN,
    pub CopyOnOpen: BOOLEAN,
    pub EffectiveOnly: BOOLEAN,
    pub Level: SECURITY_IMPERSONATION_LEVEL,
}
#[test]
fn bindgen_test_layout__SE_IMPERSONATION_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SE_IMPERSONATION_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SE_IMPERSONATION_STATE>(),
        16usize,
        concat!("Size of: ", stringify!(_SE_IMPERSONATION_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SE_IMPERSONATION_STATE>(),
        8usize,
        concat!("Alignment of ", stringify!(_SE_IMPERSONATION_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Token) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_IMPERSONATION_STATE),
            "::",
            stringify!(Token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CopyOnOpen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_IMPERSONATION_STATE),
            "::",
            stringify!(CopyOnOpen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EffectiveOnly) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_IMPERSONATION_STATE),
            "::",
            stringify!(EffectiveOnly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Level) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_IMPERSONATION_STATE),
            "::",
            stringify!(Level)
        )
    );
}
pub type SE_IMPERSONATION_STATE = _SE_IMPERSONATION_STATE;
pub type PSE_IMPERSONATION_STATE = *mut _SE_IMPERSONATION_STATE;
pub type SECURITY_INFORMATION = DWORD;
pub type PSECURITY_INFORMATION = *mut DWORD;
pub type SE_SIGNING_LEVEL = BYTE;
pub type PSE_SIGNING_LEVEL = *mut BYTE;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureNone: _SE_IMAGE_SIGNATURE_TYPE = 0;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureEmbedded: _SE_IMAGE_SIGNATURE_TYPE = 1;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCache: _SE_IMAGE_SIGNATURE_TYPE = 2;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCatalogCached: _SE_IMAGE_SIGNATURE_TYPE = 3;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCatalogNotCached: _SE_IMAGE_SIGNATURE_TYPE = 4;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCatalogHint: _SE_IMAGE_SIGNATURE_TYPE = 5;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignaturePackageCatalog: _SE_IMAGE_SIGNATURE_TYPE = 6;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignaturePplMitigated: _SE_IMAGE_SIGNATURE_TYPE = 7;
pub type _SE_IMAGE_SIGNATURE_TYPE = ::std::os::raw::c_uint;
pub use self::_SE_IMAGE_SIGNATURE_TYPE as SE_IMAGE_SIGNATURE_TYPE;
pub type PSE_IMAGE_SIGNATURE_TYPE = *mut _SE_IMAGE_SIGNATURE_TYPE;
pub const _SE_LEARNING_MODE_DATA_TYPE_SeLearningModeInvalidType: _SE_LEARNING_MODE_DATA_TYPE = 0;
pub const _SE_LEARNING_MODE_DATA_TYPE_SeLearningModeSettings: _SE_LEARNING_MODE_DATA_TYPE = 1;
pub const _SE_LEARNING_MODE_DATA_TYPE_SeLearningModeMax: _SE_LEARNING_MODE_DATA_TYPE = 2;
pub type _SE_LEARNING_MODE_DATA_TYPE = ::std::os::raw::c_uint;
pub use self::_SE_LEARNING_MODE_DATA_TYPE as SE_LEARNING_MODE_DATA_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_CAPABILITIES {
    pub AppContainerSid: PSID,
    pub Capabilities: PSID_AND_ATTRIBUTES,
    pub CapabilityCount: DWORD,
    pub Reserved: DWORD,
}
#[test]
fn bindgen_test_layout__SECURITY_CAPABILITIES() {
    const UNINIT: ::std::mem::MaybeUninit<_SECURITY_CAPABILITIES> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SECURITY_CAPABILITIES>(),
        24usize,
        concat!("Size of: ", stringify!(_SECURITY_CAPABILITIES))
    );
    assert_eq!(
        ::std::mem::align_of::<_SECURITY_CAPABILITIES>(),
        8usize,
        concat!("Alignment of ", stringify!(_SECURITY_CAPABILITIES))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AppContainerSid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_CAPABILITIES),
            "::",
            stringify!(AppContainerSid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Capabilities) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_CAPABILITIES),
            "::",
            stringify!(Capabilities)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CapabilityCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_CAPABILITIES),
            "::",
            stringify!(CapabilityCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_CAPABILITIES),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type SECURITY_CAPABILITIES = _SECURITY_CAPABILITIES;
pub type PSECURITY_CAPABILITIES = *mut _SECURITY_CAPABILITIES;
pub type LPSECURITY_CAPABILITIES = *mut _SECURITY_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOB_SET_ARRAY {
    pub JobHandle: HANDLE,
    pub MemberLevel: DWORD,
    pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__JOB_SET_ARRAY() {
    const UNINIT: ::std::mem::MaybeUninit<_JOB_SET_ARRAY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_JOB_SET_ARRAY>(),
        16usize,
        concat!("Size of: ", stringify!(_JOB_SET_ARRAY))
    );
    assert_eq!(
        ::std::mem::align_of::<_JOB_SET_ARRAY>(),
        8usize,
        concat!("Alignment of ", stringify!(_JOB_SET_ARRAY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JobHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOB_SET_ARRAY),
            "::",
            stringify!(JobHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MemberLevel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOB_SET_ARRAY),
            "::",
            stringify!(MemberLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOB_SET_ARRAY),
            "::",
            stringify!(Flags)
        )
    );
}
pub type JOB_SET_ARRAY = _JOB_SET_ARRAY;
pub type PJOB_SET_ARRAY = *mut _JOB_SET_ARRAY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _EXCEPTION_REGISTRATION_RECORD {
    pub __bindgen_anon_1: _EXCEPTION_REGISTRATION_RECORD__bindgen_ty_1,
    pub __bindgen_anon_2: _EXCEPTION_REGISTRATION_RECORD__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EXCEPTION_REGISTRATION_RECORD__bindgen_ty_1 {
    pub Next: *mut _EXCEPTION_REGISTRATION_RECORD,
    pub prev: *mut _EXCEPTION_REGISTRATION_RECORD,
}
#[test]
fn bindgen_test_layout__EXCEPTION_REGISTRATION_RECORD__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_EXCEPTION_REGISTRATION_RECORD__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_EXCEPTION_REGISTRATION_RECORD__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_EXCEPTION_REGISTRATION_RECORD__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_EXCEPTION_REGISTRATION_RECORD__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_EXCEPTION_REGISTRATION_RECORD__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_REGISTRATION_RECORD__bindgen_ty_1),
            "::",
            stringify!(Next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_REGISTRATION_RECORD__bindgen_ty_1),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _EXCEPTION_REGISTRATION_RECORD__bindgen_ty_2 {
    pub Handler: PEXCEPTION_ROUTINE,
    pub handler: PEXCEPTION_ROUTINE,
}
#[test]
fn bindgen_test_layout__EXCEPTION_REGISTRATION_RECORD__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_EXCEPTION_REGISTRATION_RECORD__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_EXCEPTION_REGISTRATION_RECORD__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_EXCEPTION_REGISTRATION_RECORD__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_EXCEPTION_REGISTRATION_RECORD__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_EXCEPTION_REGISTRATION_RECORD__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_REGISTRATION_RECORD__bindgen_ty_2),
            "::",
            stringify!(Handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_REGISTRATION_RECORD__bindgen_ty_2),
            "::",
            stringify!(handler)
        )
    );
}
#[test]
fn bindgen_test_layout__EXCEPTION_REGISTRATION_RECORD() {
    assert_eq!(
        ::std::mem::size_of::<_EXCEPTION_REGISTRATION_RECORD>(),
        16usize,
        concat!("Size of: ", stringify!(_EXCEPTION_REGISTRATION_RECORD))
    );
    assert_eq!(
        ::std::mem::align_of::<_EXCEPTION_REGISTRATION_RECORD>(),
        8usize,
        concat!("Alignment of ", stringify!(_EXCEPTION_REGISTRATION_RECORD))
    );
}
pub type EXCEPTION_REGISTRATION_RECORD = _EXCEPTION_REGISTRATION_RECORD;
pub type PEXCEPTION_REGISTRATION_RECORD = *mut EXCEPTION_REGISTRATION_RECORD;
pub type EXCEPTION_REGISTRATION = EXCEPTION_REGISTRATION_RECORD;
pub type PEXCEPTION_REGISTRATION = PEXCEPTION_REGISTRATION_RECORD;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB {
    pub ExceptionList: *mut _EXCEPTION_REGISTRATION_RECORD,
    pub StackBase: PVOID,
    pub StackLimit: PVOID,
    pub SubSystemTib: PVOID,
    pub __bindgen_anon_1: _NT_TIB__bindgen_ty_1,
    pub ArbitraryUserPointer: PVOID,
    pub Self_: *mut _NT_TIB,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB__bindgen_ty_1 {
    pub FiberData: PVOID,
    pub Version: DWORD,
}
#[test]
fn bindgen_test_layout__NT_TIB__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NT_TIB__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NT_TIB__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_NT_TIB__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NT_TIB__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_NT_TIB__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FiberData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB__bindgen_ty_1),
            "::",
            stringify!(FiberData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB__bindgen_ty_1),
            "::",
            stringify!(Version)
        )
    );
}
#[test]
fn bindgen_test_layout__NT_TIB() {
    const UNINIT: ::std::mem::MaybeUninit<_NT_TIB> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NT_TIB>(),
        56usize,
        concat!("Size of: ", stringify!(_NT_TIB))
    );
    assert_eq!(
        ::std::mem::align_of::<_NT_TIB>(),
        8usize,
        concat!("Alignment of ", stringify!(_NT_TIB))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionList) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB),
            "::",
            stringify!(ExceptionList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StackBase) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB),
            "::",
            stringify!(StackBase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StackLimit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB),
            "::",
            stringify!(StackLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SubSystemTib) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB),
            "::",
            stringify!(SubSystemTib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ArbitraryUserPointer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB),
            "::",
            stringify!(ArbitraryUserPointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Self_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB),
            "::",
            stringify!(Self_)
        )
    );
}
pub type NT_TIB = _NT_TIB;
pub type PNT_TIB = *mut NT_TIB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB32 {
    pub ExceptionList: DWORD,
    pub StackBase: DWORD,
    pub StackLimit: DWORD,
    pub SubSystemTib: DWORD,
    pub __bindgen_anon_1: _NT_TIB32__bindgen_ty_1,
    pub ArbitraryUserPointer: DWORD,
    pub Self_: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB32__bindgen_ty_1 {
    pub FiberData: DWORD,
    pub Version: DWORD,
}
#[test]
fn bindgen_test_layout__NT_TIB32__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NT_TIB32__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NT_TIB32__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_NT_TIB32__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NT_TIB32__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NT_TIB32__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FiberData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB32__bindgen_ty_1),
            "::",
            stringify!(FiberData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB32__bindgen_ty_1),
            "::",
            stringify!(Version)
        )
    );
}
#[test]
fn bindgen_test_layout__NT_TIB32() {
    const UNINIT: ::std::mem::MaybeUninit<_NT_TIB32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NT_TIB32>(),
        28usize,
        concat!("Size of: ", stringify!(_NT_TIB32))
    );
    assert_eq!(
        ::std::mem::align_of::<_NT_TIB32>(),
        4usize,
        concat!("Alignment of ", stringify!(_NT_TIB32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionList) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB32),
            "::",
            stringify!(ExceptionList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StackBase) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB32),
            "::",
            stringify!(StackBase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StackLimit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB32),
            "::",
            stringify!(StackLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SubSystemTib) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB32),
            "::",
            stringify!(SubSystemTib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ArbitraryUserPointer) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB32),
            "::",
            stringify!(ArbitraryUserPointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Self_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB32),
            "::",
            stringify!(Self_)
        )
    );
}
pub type NT_TIB32 = _NT_TIB32;
pub type PNT_TIB32 = *mut _NT_TIB32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB64 {
    pub ExceptionList: DWORD64,
    pub StackBase: DWORD64,
    pub StackLimit: DWORD64,
    pub SubSystemTib: DWORD64,
    pub __bindgen_anon_1: _NT_TIB64__bindgen_ty_1,
    pub ArbitraryUserPointer: DWORD64,
    pub Self_: DWORD64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB64__bindgen_ty_1 {
    pub FiberData: DWORD64,
    pub Version: DWORD,
}
#[test]
fn bindgen_test_layout__NT_TIB64__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_NT_TIB64__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NT_TIB64__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_NT_TIB64__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NT_TIB64__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_NT_TIB64__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FiberData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB64__bindgen_ty_1),
            "::",
            stringify!(FiberData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB64__bindgen_ty_1),
            "::",
            stringify!(Version)
        )
    );
}
#[test]
fn bindgen_test_layout__NT_TIB64() {
    const UNINIT: ::std::mem::MaybeUninit<_NT_TIB64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NT_TIB64>(),
        56usize,
        concat!("Size of: ", stringify!(_NT_TIB64))
    );
    assert_eq!(
        ::std::mem::align_of::<_NT_TIB64>(),
        8usize,
        concat!("Alignment of ", stringify!(_NT_TIB64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionList) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB64),
            "::",
            stringify!(ExceptionList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StackBase) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB64),
            "::",
            stringify!(StackBase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StackLimit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB64),
            "::",
            stringify!(StackLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SubSystemTib) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB64),
            "::",
            stringify!(SubSystemTib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ArbitraryUserPointer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB64),
            "::",
            stringify!(ArbitraryUserPointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Self_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB64),
            "::",
            stringify!(Self_)
        )
    );
}
pub type NT_TIB64 = _NT_TIB64;
pub type PNT_TIB64 = *mut _NT_TIB64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UMS_CREATE_THREAD_ATTRIBUTES {
    pub UmsVersion: DWORD,
    pub UmsContext: PVOID,
    pub UmsCompletionList: PVOID,
}
#[test]
fn bindgen_test_layout__UMS_CREATE_THREAD_ATTRIBUTES() {
    const UNINIT: ::std::mem::MaybeUninit<_UMS_CREATE_THREAD_ATTRIBUTES> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_UMS_CREATE_THREAD_ATTRIBUTES>(),
        24usize,
        concat!("Size of: ", stringify!(_UMS_CREATE_THREAD_ATTRIBUTES))
    );
    assert_eq!(
        ::std::mem::align_of::<_UMS_CREATE_THREAD_ATTRIBUTES>(),
        8usize,
        concat!("Alignment of ", stringify!(_UMS_CREATE_THREAD_ATTRIBUTES))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UmsVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_UMS_CREATE_THREAD_ATTRIBUTES),
            "::",
            stringify!(UmsVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UmsContext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_UMS_CREATE_THREAD_ATTRIBUTES),
            "::",
            stringify!(UmsContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UmsCompletionList) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_UMS_CREATE_THREAD_ATTRIBUTES),
            "::",
            stringify!(UmsCompletionList)
        )
    );
}
pub type UMS_CREATE_THREAD_ATTRIBUTES = _UMS_CREATE_THREAD_ATTRIBUTES;
pub type PUMS_CREATE_THREAD_ATTRIBUTES = *mut _UMS_CREATE_THREAD_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COMPONENT_FILTER {
    pub ComponentFlags: DWORD,
}
#[test]
fn bindgen_test_layout__COMPONENT_FILTER() {
    const UNINIT: ::std::mem::MaybeUninit<_COMPONENT_FILTER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_COMPONENT_FILTER>(),
        4usize,
        concat!("Size of: ", stringify!(_COMPONENT_FILTER))
    );
    assert_eq!(
        ::std::mem::align_of::<_COMPONENT_FILTER>(),
        4usize,
        concat!("Alignment of ", stringify!(_COMPONENT_FILTER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ComponentFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_COMPONENT_FILTER),
            "::",
            stringify!(ComponentFlags)
        )
    );
}
pub type COMPONENT_FILTER = _COMPONENT_FILTER;
pub type PCOMPONENT_FILTER = *mut _COMPONENT_FILTER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_DYNAMIC_EH_CONTINUATION_TARGET {
    pub TargetAddress: ULONG_PTR,
    pub Flags: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__PROCESS_DYNAMIC_EH_CONTINUATION_TARGET() {
    const UNINIT: ::std::mem::MaybeUninit<_PROCESS_DYNAMIC_EH_CONTINUATION_TARGET> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_DYNAMIC_EH_CONTINUATION_TARGET>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_DYNAMIC_EH_CONTINUATION_TARGET)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_DYNAMIC_EH_CONTINUATION_TARGET>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_DYNAMIC_EH_CONTINUATION_TARGET)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_DYNAMIC_EH_CONTINUATION_TARGET),
            "::",
            stringify!(TargetAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_DYNAMIC_EH_CONTINUATION_TARGET),
            "::",
            stringify!(Flags)
        )
    );
}
pub type PROCESS_DYNAMIC_EH_CONTINUATION_TARGET = _PROCESS_DYNAMIC_EH_CONTINUATION_TARGET;
pub type PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET = *mut _PROCESS_DYNAMIC_EH_CONTINUATION_TARGET;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION {
    pub NumberOfTargets: WORD,
    pub Reserved: WORD,
    pub Reserved2: DWORD,
    pub Targets: PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET,
}
#[test]
fn bindgen_test_layout__PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfTargets) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION),
            "::",
            stringify!(NumberOfTargets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Targets) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION),
            "::",
            stringify!(Targets)
        )
    );
}
pub type PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION =
    _PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION;
pub type PPROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION =
    *mut _PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE {
    pub BaseAddress: ULONG_PTR,
    pub Size: SIZE_T,
    pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE() {
    const UNINIT: ::std::mem::MaybeUninit<_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BaseAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE),
            "::",
            stringify!(BaseAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE),
            "::",
            stringify!(Flags)
        )
    );
}
pub type PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE = _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE;
pub type PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE = *mut _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION {
    pub NumberOfRanges: WORD,
    pub Reserved: WORD,
    pub Reserved2: DWORD,
    pub Ranges: PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE,
}
#[test]
fn bindgen_test_layout__PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfRanges) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION),
            "::",
            stringify!(NumberOfRanges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ranges) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION),
            "::",
            stringify!(Ranges)
        )
    );
}
pub type PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION =
    _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION;
pub type PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION =
    *mut _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGES_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUOTA_LIMITS {
    pub PagedPoolLimit: SIZE_T,
    pub NonPagedPoolLimit: SIZE_T,
    pub MinimumWorkingSetSize: SIZE_T,
    pub MaximumWorkingSetSize: SIZE_T,
    pub PagefileLimit: SIZE_T,
    pub TimeLimit: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__QUOTA_LIMITS() {
    const UNINIT: ::std::mem::MaybeUninit<_QUOTA_LIMITS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_QUOTA_LIMITS>(),
        48usize,
        concat!("Size of: ", stringify!(_QUOTA_LIMITS))
    );
    assert_eq!(
        ::std::mem::align_of::<_QUOTA_LIMITS>(),
        8usize,
        concat!("Alignment of ", stringify!(_QUOTA_LIMITS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PagedPoolLimit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS),
            "::",
            stringify!(PagedPoolLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NonPagedPoolLimit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS),
            "::",
            stringify!(NonPagedPoolLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinimumWorkingSetSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS),
            "::",
            stringify!(MinimumWorkingSetSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumWorkingSetSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS),
            "::",
            stringify!(MaximumWorkingSetSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PagefileLimit) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS),
            "::",
            stringify!(PagefileLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeLimit) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS),
            "::",
            stringify!(TimeLimit)
        )
    );
}
pub type QUOTA_LIMITS = _QUOTA_LIMITS;
pub type PQUOTA_LIMITS = *mut _QUOTA_LIMITS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RATE_QUOTA_LIMIT {
    pub RateData: DWORD,
    pub __bindgen_anon_1: _RATE_QUOTA_LIMIT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RATE_QUOTA_LIMIT__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__RATE_QUOTA_LIMIT__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_RATE_QUOTA_LIMIT__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_RATE_QUOTA_LIMIT__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_RATE_QUOTA_LIMIT__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_RATE_QUOTA_LIMIT__bindgen_ty_1))
    );
}
impl _RATE_QUOTA_LIMIT__bindgen_ty_1 {
    #[inline]
    pub fn RatePercent(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_RatePercent(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RatePercent: DWORD,
        Reserved0: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let RatePercent: u32 = unsafe { ::std::mem::transmute(RatePercent) };
            RatePercent as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let Reserved0: u32 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__RATE_QUOTA_LIMIT() {
    const UNINIT: ::std::mem::MaybeUninit<_RATE_QUOTA_LIMIT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RATE_QUOTA_LIMIT>(),
        4usize,
        concat!("Size of: ", stringify!(_RATE_QUOTA_LIMIT))
    );
    assert_eq!(
        ::std::mem::align_of::<_RATE_QUOTA_LIMIT>(),
        4usize,
        concat!("Alignment of ", stringify!(_RATE_QUOTA_LIMIT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RateData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RATE_QUOTA_LIMIT),
            "::",
            stringify!(RateData)
        )
    );
}
pub type RATE_QUOTA_LIMIT = _RATE_QUOTA_LIMIT;
pub type PRATE_QUOTA_LIMIT = *mut _RATE_QUOTA_LIMIT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUOTA_LIMITS_EX {
    pub PagedPoolLimit: SIZE_T,
    pub NonPagedPoolLimit: SIZE_T,
    pub MinimumWorkingSetSize: SIZE_T,
    pub MaximumWorkingSetSize: SIZE_T,
    pub PagefileLimit: SIZE_T,
    pub TimeLimit: LARGE_INTEGER,
    pub WorkingSetLimit: SIZE_T,
    pub Reserved2: SIZE_T,
    pub Reserved3: SIZE_T,
    pub Reserved4: SIZE_T,
    pub Flags: DWORD,
    pub CpuRateLimit: RATE_QUOTA_LIMIT,
}
#[test]
fn bindgen_test_layout__QUOTA_LIMITS_EX() {
    const UNINIT: ::std::mem::MaybeUninit<_QUOTA_LIMITS_EX> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_QUOTA_LIMITS_EX>(),
        88usize,
        concat!("Size of: ", stringify!(_QUOTA_LIMITS_EX))
    );
    assert_eq!(
        ::std::mem::align_of::<_QUOTA_LIMITS_EX>(),
        8usize,
        concat!("Alignment of ", stringify!(_QUOTA_LIMITS_EX))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PagedPoolLimit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(PagedPoolLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NonPagedPoolLimit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(NonPagedPoolLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinimumWorkingSetSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(MinimumWorkingSetSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumWorkingSetSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(MaximumWorkingSetSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PagefileLimit) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(PagefileLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeLimit) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(TimeLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WorkingSetLimit) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(WorkingSetLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CpuRateLimit) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(CpuRateLimit)
        )
    );
}
pub type QUOTA_LIMITS_EX = _QUOTA_LIMITS_EX;
pub type PQUOTA_LIMITS_EX = *mut _QUOTA_LIMITS_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_COUNTERS {
    pub ReadOperationCount: ULONGLONG,
    pub WriteOperationCount: ULONGLONG,
    pub OtherOperationCount: ULONGLONG,
    pub ReadTransferCount: ULONGLONG,
    pub WriteTransferCount: ULONGLONG,
    pub OtherTransferCount: ULONGLONG,
}
#[test]
fn bindgen_test_layout__IO_COUNTERS() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_COUNTERS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_COUNTERS>(),
        48usize,
        concat!("Size of: ", stringify!(_IO_COUNTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_COUNTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_COUNTERS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadOperationCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COUNTERS),
            "::",
            stringify!(ReadOperationCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteOperationCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COUNTERS),
            "::",
            stringify!(WriteOperationCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OtherOperationCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COUNTERS),
            "::",
            stringify!(OtherOperationCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadTransferCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COUNTERS),
            "::",
            stringify!(ReadTransferCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteTransferCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COUNTERS),
            "::",
            stringify!(WriteTransferCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OtherTransferCount) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COUNTERS),
            "::",
            stringify!(OtherTransferCount)
        )
    );
}
pub type IO_COUNTERS = _IO_COUNTERS;
pub type PIO_COUNTERS = *mut IO_COUNTERS;
pub const _HARDWARE_COUNTER_TYPE_PMCCounter: _HARDWARE_COUNTER_TYPE = 0;
pub const _HARDWARE_COUNTER_TYPE_MaxHardwareCounterType: _HARDWARE_COUNTER_TYPE = 1;
pub type _HARDWARE_COUNTER_TYPE = ::std::os::raw::c_uint;
pub use self::_HARDWARE_COUNTER_TYPE as HARDWARE_COUNTER_TYPE;
pub type PHARDWARE_COUNTER_TYPE = *mut _HARDWARE_COUNTER_TYPE;
pub const _PROCESS_MITIGATION_POLICY_ProcessDEPPolicy: _PROCESS_MITIGATION_POLICY = 0;
pub const _PROCESS_MITIGATION_POLICY_ProcessASLRPolicy: _PROCESS_MITIGATION_POLICY = 1;
pub const _PROCESS_MITIGATION_POLICY_ProcessDynamicCodePolicy: _PROCESS_MITIGATION_POLICY = 2;
pub const _PROCESS_MITIGATION_POLICY_ProcessStrictHandleCheckPolicy: _PROCESS_MITIGATION_POLICY = 3;
pub const _PROCESS_MITIGATION_POLICY_ProcessSystemCallDisablePolicy: _PROCESS_MITIGATION_POLICY = 4;
pub const _PROCESS_MITIGATION_POLICY_ProcessMitigationOptionsMask: _PROCESS_MITIGATION_POLICY = 5;
pub const _PROCESS_MITIGATION_POLICY_ProcessExtensionPointDisablePolicy:
    _PROCESS_MITIGATION_POLICY = 6;
pub const _PROCESS_MITIGATION_POLICY_ProcessControlFlowGuardPolicy: _PROCESS_MITIGATION_POLICY = 7;
pub const _PROCESS_MITIGATION_POLICY_ProcessSignaturePolicy: _PROCESS_MITIGATION_POLICY = 8;
pub const _PROCESS_MITIGATION_POLICY_ProcessFontDisablePolicy: _PROCESS_MITIGATION_POLICY = 9;
pub const _PROCESS_MITIGATION_POLICY_ProcessImageLoadPolicy: _PROCESS_MITIGATION_POLICY = 10;
pub const _PROCESS_MITIGATION_POLICY_ProcessSystemCallFilterPolicy: _PROCESS_MITIGATION_POLICY = 11;
pub const _PROCESS_MITIGATION_POLICY_ProcessPayloadRestrictionPolicy: _PROCESS_MITIGATION_POLICY =
    12;
pub const _PROCESS_MITIGATION_POLICY_ProcessChildProcessPolicy: _PROCESS_MITIGATION_POLICY = 13;
pub const _PROCESS_MITIGATION_POLICY_ProcessSideChannelIsolationPolicy: _PROCESS_MITIGATION_POLICY =
    14;
pub const _PROCESS_MITIGATION_POLICY_ProcessUserShadowStackPolicy: _PROCESS_MITIGATION_POLICY = 15;
pub const _PROCESS_MITIGATION_POLICY_ProcessRedirectionTrustPolicy: _PROCESS_MITIGATION_POLICY = 16;
pub const _PROCESS_MITIGATION_POLICY_ProcessUserPointerAuthPolicy: _PROCESS_MITIGATION_POLICY = 17;
pub const _PROCESS_MITIGATION_POLICY_ProcessSEHOPPolicy: _PROCESS_MITIGATION_POLICY = 18;
pub const _PROCESS_MITIGATION_POLICY_MaxProcessMitigationPolicy: _PROCESS_MITIGATION_POLICY = 19;
pub type _PROCESS_MITIGATION_POLICY = ::std::os::raw::c_uint;
pub use self::_PROCESS_MITIGATION_POLICY as PROCESS_MITIGATION_POLICY;
pub type PPROCESS_MITIGATION_POLICY = *mut _PROCESS_MITIGATION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_ASLR_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnableBottomUpRandomization(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableBottomUpRandomization(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableForceRelocateImages(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableForceRelocateImages(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableHighEntropy(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableHighEntropy(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisallowStrippedImages(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisallowStrippedImages(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnableBottomUpRandomization: DWORD,
        EnableForceRelocateImages: DWORD,
        EnableHighEntropy: DWORD,
        DisallowStrippedImages: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnableBottomUpRandomization: u32 =
                unsafe { ::std::mem::transmute(EnableBottomUpRandomization) };
            EnableBottomUpRandomization as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EnableForceRelocateImages: u32 =
                unsafe { ::std::mem::transmute(EnableForceRelocateImages) };
            EnableForceRelocateImages as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EnableHighEntropy: u32 = unsafe { ::std::mem::transmute(EnableHighEntropy) };
            EnableHighEntropy as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DisallowStrippedImages: u32 =
                unsafe { ::std::mem::transmute(DisallowStrippedImages) };
            DisallowStrippedImages as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_ASLR_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_ASLR_POLICY>(),
        4usize,
        concat!("Size of: ", stringify!(_PROCESS_MITIGATION_ASLR_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_ASLR_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(_PROCESS_MITIGATION_ASLR_POLICY))
    );
}
pub type PROCESS_MITIGATION_ASLR_POLICY = _PROCESS_MITIGATION_ASLR_POLICY;
pub type PPROCESS_MITIGATION_ASLR_POLICY = *mut _PROCESS_MITIGATION_ASLR_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_DEP_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1,
    pub Permanent: BOOLEAN,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Enable(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Enable(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableAtlThunkEmulation(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableAtlThunkEmulation(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Enable: DWORD,
        DisableAtlThunkEmulation: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Enable: u32 = unsafe { ::std::mem::transmute(Enable) };
            Enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DisableAtlThunkEmulation: u32 =
                unsafe { ::std::mem::transmute(DisableAtlThunkEmulation) };
            DisableAtlThunkEmulation as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DEP_POLICY() {
    const UNINIT: ::std::mem::MaybeUninit<_PROCESS_MITIGATION_DEP_POLICY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_DEP_POLICY>(),
        8usize,
        concat!("Size of: ", stringify!(_PROCESS_MITIGATION_DEP_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_DEP_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(_PROCESS_MITIGATION_DEP_POLICY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Permanent) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_DEP_POLICY),
            "::",
            stringify!(Permanent)
        )
    );
}
pub type PROCESS_MITIGATION_DEP_POLICY = _PROCESS_MITIGATION_DEP_POLICY;
pub type PPROCESS_MITIGATION_DEP_POLICY = *mut _PROCESS_MITIGATION_DEP_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SEHOP_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnableSehop(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableSehop(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnableSehop: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnableSehop: u32 = unsafe { ::std::mem::transmute(EnableSehop) };
            EnableSehop as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_SEHOP_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SEHOP_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_SEHOP_POLICY>(),
        4usize,
        concat!("Size of: ", stringify!(_PROCESS_MITIGATION_SEHOP_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_SEHOP_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_SEHOP_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_SEHOP_POLICY = _PROCESS_MITIGATION_SEHOP_POLICY;
pub type PPROCESS_MITIGATION_SEHOP_POLICY = *mut _PROCESS_MITIGATION_SEHOP_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1()
{
    assert_eq!(
        ::std::mem::size_of::<
            _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn RaiseExceptionOnInvalidHandleReference(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RaiseExceptionOnInvalidHandleReference(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HandleExceptionsPermanentlyEnabled(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HandleExceptionsPermanentlyEnabled(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RaiseExceptionOnInvalidHandleReference: DWORD,
        HandleExceptionsPermanentlyEnabled: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RaiseExceptionOnInvalidHandleReference: u32 =
                unsafe { ::std::mem::transmute(RaiseExceptionOnInvalidHandleReference) };
            RaiseExceptionOnInvalidHandleReference as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let HandleExceptionsPermanentlyEnabled: u32 =
                unsafe { ::std::mem::transmute(HandleExceptionsPermanentlyEnabled) };
            HandleExceptionsPermanentlyEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY =
    _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
pub type PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY =
    *mut _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1()
{
    assert_eq!(
        ::std::mem::size_of::<
            _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DisallowWin32kSystemCalls(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisallowWin32kSystemCalls(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DisallowWin32kSystemCalls: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DisallowWin32kSystemCalls: u32 =
                unsafe { ::std::mem::transmute(DisallowWin32kSystemCalls) };
            DisallowWin32kSystemCalls as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY =
    _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
pub type PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY =
    *mut _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(
                _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(
                _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
}
impl _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DisableExtensionPoints(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableExtensionPoints(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DisableExtensionPoints: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DisableExtensionPoints: u32 =
                unsafe { ::std::mem::transmute(DisableExtensionPoints) };
            DisableExtensionPoints as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY =
    _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
pub type PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY =
    *mut _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<
            _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnableControlFlowGuard(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableControlFlowGuard(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableExportSuppression(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableExportSuppression(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StrictMode(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StrictMode(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnableControlFlowGuard: DWORD,
        EnableExportSuppression: DWORD,
        StrictMode: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnableControlFlowGuard: u32 =
                unsafe { ::std::mem::transmute(EnableControlFlowGuard) };
            EnableControlFlowGuard as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EnableExportSuppression: u32 =
                unsafe { ::std::mem::transmute(EnableExportSuppression) };
            EnableExportSuppression as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let StrictMode: u32 = unsafe { ::std::mem::transmute(StrictMode) };
            StrictMode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY =
    _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
pub type PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY =
    *mut _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<
            _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn MicrosoftSignedOnly(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MicrosoftSignedOnly(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StoreSignedOnly(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StoreSignedOnly(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MitigationOptIn(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MitigationOptIn(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MicrosoftSignedOnly: DWORD,
        StoreSignedOnly: DWORD,
        MitigationOptIn: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MicrosoftSignedOnly: u32 = unsafe { ::std::mem::transmute(MicrosoftSignedOnly) };
            MicrosoftSignedOnly as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let StoreSignedOnly: u32 = unsafe { ::std::mem::transmute(StoreSignedOnly) };
            StoreSignedOnly as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MitigationOptIn: u32 = unsafe { ::std::mem::transmute(MitigationOptIn) };
            MitigationOptIn as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;
pub type PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY =
    *mut _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1>(
        ),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ProhibitDynamicCode(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProhibitDynamicCode(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AllowThreadOptOut(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowThreadOptOut(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AllowRemoteDowngrade(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowRemoteDowngrade(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ProhibitDynamicCode: DWORD,
        AllowThreadOptOut: DWORD,
        AllowRemoteDowngrade: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ProhibitDynamicCode: u32 = unsafe { ::std::mem::transmute(ProhibitDynamicCode) };
            ProhibitDynamicCode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AllowThreadOptOut: u32 = unsafe { ::std::mem::transmute(AllowThreadOptOut) };
            AllowThreadOptOut as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AllowRemoteDowngrade: u32 = unsafe { ::std::mem::transmute(AllowRemoteDowngrade) };
            AllowRemoteDowngrade as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DYNAMIC_CODE_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_DYNAMIC_CODE_POLICY = _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY;
pub type PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY = *mut _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1>(
        ),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DisableNonSystemFonts(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableNonSystemFonts(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditNonSystemFontLoading(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditNonSystemFontLoading(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DisableNonSystemFonts: DWORD,
        AuditNonSystemFontLoading: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DisableNonSystemFonts: u32 =
                unsafe { ::std::mem::transmute(DisableNonSystemFonts) };
            DisableNonSystemFonts as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditNonSystemFontLoading: u32 =
                unsafe { ::std::mem::transmute(AuditNonSystemFontLoading) };
            AuditNonSystemFontLoading as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_FONT_DISABLE_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_FONT_DISABLE_POLICY = _PROCESS_MITIGATION_FONT_DISABLE_POLICY;
pub type PPROCESS_MITIGATION_FONT_DISABLE_POLICY = *mut _PROCESS_MITIGATION_FONT_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NoRemoteImages(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoRemoteImages(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoLowMandatoryLabelImages(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoLowMandatoryLabelImages(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PreferSystem32Images(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PreferSystem32Images(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NoRemoteImages: DWORD,
        NoLowMandatoryLabelImages: DWORD,
        PreferSystem32Images: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NoRemoteImages: u32 = unsafe { ::std::mem::transmute(NoRemoteImages) };
            NoRemoteImages as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NoLowMandatoryLabelImages: u32 =
                unsafe { ::std::mem::transmute(NoLowMandatoryLabelImages) };
            NoLowMandatoryLabelImages as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PreferSystem32Images: u32 = unsafe { ::std::mem::transmute(PreferSystem32Images) };
            PreferSystem32Images as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_IMAGE_LOAD_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_IMAGE_LOAD_POLICY = _PROCESS_MITIGATION_IMAGE_LOAD_POLICY;
pub type PPROCESS_MITIGATION_IMAGE_LOAD_POLICY = *mut _PROCESS_MITIGATION_IMAGE_LOAD_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<
            _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn FilterId(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_FilterId(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FilterId: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let FilterId: u32 = unsafe { ::std::mem::transmute(FilterId) };
            FilterId as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY =
    _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY;
pub type PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY =
    *mut _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1()
{
    assert_eq!(
        ::std::mem::size_of::<
            _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnableExportAddressFilter(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableExportAddressFilter(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditExportAddressFilter(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditExportAddressFilter(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableExportAddressFilterPlus(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableExportAddressFilterPlus(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditExportAddressFilterPlus(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditExportAddressFilterPlus(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableImportAddressFilter(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableImportAddressFilter(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditImportAddressFilter(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditImportAddressFilter(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableRopStackPivot(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableRopStackPivot(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditRopStackPivot(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditRopStackPivot(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableRopCallerCheck(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableRopCallerCheck(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditRopCallerCheck(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditRopCallerCheck(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableRopSimExec(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableRopSimExec(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditRopSimExec(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditRopSimExec(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnableExportAddressFilter: DWORD,
        AuditExportAddressFilter: DWORD,
        EnableExportAddressFilterPlus: DWORD,
        AuditExportAddressFilterPlus: DWORD,
        EnableImportAddressFilter: DWORD,
        AuditImportAddressFilter: DWORD,
        EnableRopStackPivot: DWORD,
        AuditRopStackPivot: DWORD,
        EnableRopCallerCheck: DWORD,
        AuditRopCallerCheck: DWORD,
        EnableRopSimExec: DWORD,
        AuditRopSimExec: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnableExportAddressFilter: u32 =
                unsafe { ::std::mem::transmute(EnableExportAddressFilter) };
            EnableExportAddressFilter as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditExportAddressFilter: u32 =
                unsafe { ::std::mem::transmute(AuditExportAddressFilter) };
            AuditExportAddressFilter as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EnableExportAddressFilterPlus: u32 =
                unsafe { ::std::mem::transmute(EnableExportAddressFilterPlus) };
            EnableExportAddressFilterPlus as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AuditExportAddressFilterPlus: u32 =
                unsafe { ::std::mem::transmute(AuditExportAddressFilterPlus) };
            AuditExportAddressFilterPlus as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EnableImportAddressFilter: u32 =
                unsafe { ::std::mem::transmute(EnableImportAddressFilter) };
            EnableImportAddressFilter as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let AuditImportAddressFilter: u32 =
                unsafe { ::std::mem::transmute(AuditImportAddressFilter) };
            AuditImportAddressFilter as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let EnableRopStackPivot: u32 = unsafe { ::std::mem::transmute(EnableRopStackPivot) };
            EnableRopStackPivot as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let AuditRopStackPivot: u32 = unsafe { ::std::mem::transmute(AuditRopStackPivot) };
            AuditRopStackPivot as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let EnableRopCallerCheck: u32 = unsafe { ::std::mem::transmute(EnableRopCallerCheck) };
            EnableRopCallerCheck as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let AuditRopCallerCheck: u32 = unsafe { ::std::mem::transmute(AuditRopCallerCheck) };
            AuditRopCallerCheck as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let EnableRopSimExec: u32 = unsafe { ::std::mem::transmute(EnableRopSimExec) };
            EnableRopSimExec as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let AuditRopSimExec: u32 = unsafe { ::std::mem::transmute(AuditRopSimExec) };
            AuditRopSimExec as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY =
    _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY;
pub type PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY =
    *mut _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1>(
        ),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NoChildProcessCreation(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoChildProcessCreation(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditNoChildProcessCreation(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditNoChildProcessCreation(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AllowSecureProcessCreation(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowSecureProcessCreation(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NoChildProcessCreation: DWORD,
        AuditNoChildProcessCreation: DWORD,
        AllowSecureProcessCreation: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NoChildProcessCreation: u32 =
                unsafe { ::std::mem::transmute(NoChildProcessCreation) };
            NoChildProcessCreation as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditNoChildProcessCreation: u32 =
                unsafe { ::std::mem::transmute(AuditNoChildProcessCreation) };
            AuditNoChildProcessCreation as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AllowSecureProcessCreation: u32 =
                unsafe { ::std::mem::transmute(AllowSecureProcessCreation) };
            AllowSecureProcessCreation as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CHILD_PROCESS_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_CHILD_PROCESS_POLICY = _PROCESS_MITIGATION_CHILD_PROCESS_POLICY;
pub type PPROCESS_MITIGATION_CHILD_PROCESS_POLICY = *mut _PROCESS_MITIGATION_CHILD_PROCESS_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(
                _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(
                _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
}
impl _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SmtBranchTargetIsolation(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SmtBranchTargetIsolation(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsolateSecurityDomain(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsolateSecurityDomain(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisablePageCombine(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisablePageCombine(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpeculativeStoreBypassDisable(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SpeculativeStoreBypassDisable(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RestrictCoreSharing(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RestrictCoreSharing(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SmtBranchTargetIsolation: DWORD,
        IsolateSecurityDomain: DWORD,
        DisablePageCombine: DWORD,
        SpeculativeStoreBypassDisable: DWORD,
        RestrictCoreSharing: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SmtBranchTargetIsolation: u32 =
                unsafe { ::std::mem::transmute(SmtBranchTargetIsolation) };
            SmtBranchTargetIsolation as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IsolateSecurityDomain: u32 =
                unsafe { ::std::mem::transmute(IsolateSecurityDomain) };
            IsolateSecurityDomain as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DisablePageCombine: u32 = unsafe { ::std::mem::transmute(DisablePageCombine) };
            DisablePageCombine as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SpeculativeStoreBypassDisable: u32 =
                unsafe { ::std::mem::transmute(SpeculativeStoreBypassDisable) };
            SpeculativeStoreBypassDisable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RestrictCoreSharing: u32 = unsafe { ::std::mem::transmute(RestrictCoreSharing) };
            RestrictCoreSharing as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY =
    _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY;
pub type PPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY =
    *mut _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<
            _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnableUserShadowStack(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableUserShadowStack(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditUserShadowStack(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditUserShadowStack(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SetContextIpValidation(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetContextIpValidation(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditSetContextIpValidation(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditSetContextIpValidation(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableUserShadowStackStrictMode(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableUserShadowStackStrictMode(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BlockNonCetBinaries(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BlockNonCetBinaries(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BlockNonCetBinariesNonEhcont(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BlockNonCetBinariesNonEhcont(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditBlockNonCetBinaries(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditBlockNonCetBinaries(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CetDynamicApisOutOfProcOnly(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CetDynamicApisOutOfProcOnly(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SetContextIpValidationRelaxedMode(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetContextIpValidationRelaxedMode(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnableUserShadowStack: DWORD,
        AuditUserShadowStack: DWORD,
        SetContextIpValidation: DWORD,
        AuditSetContextIpValidation: DWORD,
        EnableUserShadowStackStrictMode: DWORD,
        BlockNonCetBinaries: DWORD,
        BlockNonCetBinariesNonEhcont: DWORD,
        AuditBlockNonCetBinaries: DWORD,
        CetDynamicApisOutOfProcOnly: DWORD,
        SetContextIpValidationRelaxedMode: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnableUserShadowStack: u32 =
                unsafe { ::std::mem::transmute(EnableUserShadowStack) };
            EnableUserShadowStack as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditUserShadowStack: u32 = unsafe { ::std::mem::transmute(AuditUserShadowStack) };
            AuditUserShadowStack as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SetContextIpValidation: u32 =
                unsafe { ::std::mem::transmute(SetContextIpValidation) };
            SetContextIpValidation as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AuditSetContextIpValidation: u32 =
                unsafe { ::std::mem::transmute(AuditSetContextIpValidation) };
            AuditSetContextIpValidation as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EnableUserShadowStackStrictMode: u32 =
                unsafe { ::std::mem::transmute(EnableUserShadowStackStrictMode) };
            EnableUserShadowStackStrictMode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let BlockNonCetBinaries: u32 = unsafe { ::std::mem::transmute(BlockNonCetBinaries) };
            BlockNonCetBinaries as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let BlockNonCetBinariesNonEhcont: u32 =
                unsafe { ::std::mem::transmute(BlockNonCetBinariesNonEhcont) };
            BlockNonCetBinariesNonEhcont as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let AuditBlockNonCetBinaries: u32 =
                unsafe { ::std::mem::transmute(AuditBlockNonCetBinaries) };
            AuditBlockNonCetBinaries as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CetDynamicApisOutOfProcOnly: u32 =
                unsafe { ::std::mem::transmute(CetDynamicApisOutOfProcOnly) };
            CetDynamicApisOutOfProcOnly as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SetContextIpValidationRelaxedMode: u32 =
                unsafe { ::std::mem::transmute(SetContextIpValidationRelaxedMode) };
            SetContextIpValidationRelaxedMode as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY = _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY;
pub type PPROCESS_MITIGATION_USER_SHADOW_STACK_POLICY =
    *mut _PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<
            _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnablePointerAuthUserIp(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnablePointerAuthUserIp(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnablePointerAuthUserIp: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnablePointerAuthUserIp: u32 =
                unsafe { ::std::mem::transmute(EnablePointerAuthUserIp) };
            EnablePointerAuthUserIp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY = _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY;
pub type PPROCESS_MITIGATION_USER_POINTER_AUTH_POLICY =
    *mut _PROCESS_MITIGATION_USER_POINTER_AUTH_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<
            _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnforceRedirectionTrust(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnforceRedirectionTrust(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditRedirectionTrust(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditRedirectionTrust(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnforceRedirectionTrust: DWORD,
        AuditRedirectionTrust: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnforceRedirectionTrust: u32 =
                unsafe { ::std::mem::transmute(EnforceRedirectionTrust) };
            EnforceRedirectionTrust as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditRedirectionTrust: u32 =
                unsafe { ::std::mem::transmute(AuditRedirectionTrust) };
            AuditRedirectionTrust as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY = _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY;
pub type PPROCESS_MITIGATION_REDIRECTION_TRUST_POLICY =
    *mut _PROCESS_MITIGATION_REDIRECTION_TRUST_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
    pub TotalUserTime: LARGE_INTEGER,
    pub TotalKernelTime: LARGE_INTEGER,
    pub ThisPeriodTotalUserTime: LARGE_INTEGER,
    pub ThisPeriodTotalKernelTime: LARGE_INTEGER,
    pub TotalPageFaultCount: DWORD,
    pub TotalProcesses: DWORD,
    pub ActiveProcesses: DWORD,
    pub TotalTerminatedProcesses: DWORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_BASIC_ACCOUNTING_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalUserTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
            "::",
            stringify!(TotalUserTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalKernelTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
            "::",
            stringify!(TotalKernelTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ThisPeriodTotalUserTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
            "::",
            stringify!(ThisPeriodTotalUserTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ThisPeriodTotalKernelTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
            "::",
            stringify!(ThisPeriodTotalKernelTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalPageFaultCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
            "::",
            stringify!(TotalPageFaultCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalProcesses) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
            "::",
            stringify!(TotalProcesses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ActiveProcesses) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
            "::",
            stringify!(ActiveProcesses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalTerminatedProcesses) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
            "::",
            stringify!(TotalTerminatedProcesses)
        )
    );
}
pub type JOBOBJECT_BASIC_ACCOUNTING_INFORMATION = _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
pub type PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION = *mut _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
    pub PerProcessUserTimeLimit: LARGE_INTEGER,
    pub PerJobUserTimeLimit: LARGE_INTEGER,
    pub LimitFlags: DWORD,
    pub MinimumWorkingSetSize: SIZE_T,
    pub MaximumWorkingSetSize: SIZE_T,
    pub ActiveProcessLimit: DWORD,
    pub Affinity: ULONG_PTR,
    pub PriorityClass: DWORD,
    pub SchedulingClass: DWORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_BASIC_LIMIT_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_JOBOBJECT_BASIC_LIMIT_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>(),
        64usize,
        concat!("Size of: ", stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PerProcessUserTimeLimit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
            "::",
            stringify!(PerProcessUserTimeLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PerJobUserTimeLimit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
            "::",
            stringify!(PerJobUserTimeLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LimitFlags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
            "::",
            stringify!(LimitFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinimumWorkingSetSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
            "::",
            stringify!(MinimumWorkingSetSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumWorkingSetSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
            "::",
            stringify!(MaximumWorkingSetSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ActiveProcessLimit) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
            "::",
            stringify!(ActiveProcessLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Affinity) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
            "::",
            stringify!(Affinity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PriorityClass) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
            "::",
            stringify!(PriorityClass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SchedulingClass) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
            "::",
            stringify!(SchedulingClass)
        )
    );
}
pub type JOBOBJECT_BASIC_LIMIT_INFORMATION = _JOBOBJECT_BASIC_LIMIT_INFORMATION;
pub type PJOBOBJECT_BASIC_LIMIT_INFORMATION = *mut _JOBOBJECT_BASIC_LIMIT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
    pub BasicLimitInformation: JOBOBJECT_BASIC_LIMIT_INFORMATION,
    pub IoInfo: IO_COUNTERS,
    pub ProcessMemoryLimit: SIZE_T,
    pub JobMemoryLimit: SIZE_T,
    pub PeakProcessMemoryUsed: SIZE_T,
    pub PeakJobMemoryUsed: SIZE_T,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_EXTENDED_LIMIT_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_JOBOBJECT_EXTENDED_LIMIT_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_EXTENDED_LIMIT_INFORMATION>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_EXTENDED_LIMIT_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BasicLimitInformation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
            "::",
            stringify!(BasicLimitInformation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoInfo) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
            "::",
            stringify!(IoInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProcessMemoryLimit) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
            "::",
            stringify!(ProcessMemoryLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JobMemoryLimit) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
            "::",
            stringify!(JobMemoryLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PeakProcessMemoryUsed) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
            "::",
            stringify!(PeakProcessMemoryUsed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PeakJobMemoryUsed) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
            "::",
            stringify!(PeakJobMemoryUsed)
        )
    );
}
pub type JOBOBJECT_EXTENDED_LIMIT_INFORMATION = _JOBOBJECT_EXTENDED_LIMIT_INFORMATION;
pub type PJOBOBJECT_EXTENDED_LIMIT_INFORMATION = *mut _JOBOBJECT_EXTENDED_LIMIT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
    pub NumberOfAssignedProcesses: DWORD,
    pub NumberOfProcessIdsInList: DWORD,
    pub ProcessIdList: [ULONG_PTR; 1usize],
}
#[test]
fn bindgen_test_layout__JOBOBJECT_BASIC_PROCESS_ID_LIST() {
    const UNINIT: ::std::mem::MaybeUninit<_JOBOBJECT_BASIC_PROCESS_ID_LIST> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_BASIC_PROCESS_ID_LIST>(),
        16usize,
        concat!("Size of: ", stringify!(_JOBOBJECT_BASIC_PROCESS_ID_LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_BASIC_PROCESS_ID_LIST>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_BASIC_PROCESS_ID_LIST)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfAssignedProcesses) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_PROCESS_ID_LIST),
            "::",
            stringify!(NumberOfAssignedProcesses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfProcessIdsInList) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_PROCESS_ID_LIST),
            "::",
            stringify!(NumberOfProcessIdsInList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProcessIdList) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_PROCESS_ID_LIST),
            "::",
            stringify!(ProcessIdList)
        )
    );
}
pub type JOBOBJECT_BASIC_PROCESS_ID_LIST = _JOBOBJECT_BASIC_PROCESS_ID_LIST;
pub type PJOBOBJECT_BASIC_PROCESS_ID_LIST = *mut _JOBOBJECT_BASIC_PROCESS_ID_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {
    pub UIRestrictionsClass: DWORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_BASIC_UI_RESTRICTIONS() {
    const UNINIT: ::std::mem::MaybeUninit<_JOBOBJECT_BASIC_UI_RESTRICTIONS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_BASIC_UI_RESTRICTIONS>(),
        4usize,
        concat!("Size of: ", stringify!(_JOBOBJECT_BASIC_UI_RESTRICTIONS))
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_BASIC_UI_RESTRICTIONS>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_BASIC_UI_RESTRICTIONS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UIRestrictionsClass) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_UI_RESTRICTIONS),
            "::",
            stringify!(UIRestrictionsClass)
        )
    );
}
pub type JOBOBJECT_BASIC_UI_RESTRICTIONS = _JOBOBJECT_BASIC_UI_RESTRICTIONS;
pub type PJOBOBJECT_BASIC_UI_RESTRICTIONS = *mut _JOBOBJECT_BASIC_UI_RESTRICTIONS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION {
    pub SecurityLimitFlags: DWORD,
    pub JobToken: HANDLE,
    pub SidsToDisable: PTOKEN_GROUPS,
    pub PrivilegesToDelete: PTOKEN_PRIVILEGES,
    pub RestrictedSids: PTOKEN_GROUPS,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_SECURITY_LIMIT_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_JOBOBJECT_SECURITY_LIMIT_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_SECURITY_LIMIT_INFORMATION>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_SECURITY_LIMIT_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SecurityLimitFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION),
            "::",
            stringify!(SecurityLimitFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JobToken) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION),
            "::",
            stringify!(JobToken)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SidsToDisable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION),
            "::",
            stringify!(SidsToDisable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrivilegesToDelete) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION),
            "::",
            stringify!(PrivilegesToDelete)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RestrictedSids) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION),
            "::",
            stringify!(RestrictedSids)
        )
    );
}
pub type JOBOBJECT_SECURITY_LIMIT_INFORMATION = _JOBOBJECT_SECURITY_LIMIT_INFORMATION;
pub type PJOBOBJECT_SECURITY_LIMIT_INFORMATION = *mut _JOBOBJECT_SECURITY_LIMIT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
    pub EndOfJobTimeAction: DWORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_END_OF_JOB_TIME_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_JOBOBJECT_END_OF_JOB_TIME_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_END_OF_JOB_TIME_INFORMATION>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_END_OF_JOB_TIME_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_END_OF_JOB_TIME_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_END_OF_JOB_TIME_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndOfJobTimeAction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_END_OF_JOB_TIME_INFORMATION),
            "::",
            stringify!(EndOfJobTimeAction)
        )
    );
}
pub type JOBOBJECT_END_OF_JOB_TIME_INFORMATION = _JOBOBJECT_END_OF_JOB_TIME_INFORMATION;
pub type PJOBOBJECT_END_OF_JOB_TIME_INFORMATION = *mut _JOBOBJECT_END_OF_JOB_TIME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
    pub CompletionKey: PVOID,
    pub CompletionPort: HANDLE,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_ASSOCIATE_COMPLETION_PORT() {
    const UNINIT: ::std::mem::MaybeUninit<_JOBOBJECT_ASSOCIATE_COMPLETION_PORT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_ASSOCIATE_COMPLETION_PORT>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_ASSOCIATE_COMPLETION_PORT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_ASSOCIATE_COMPLETION_PORT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_ASSOCIATE_COMPLETION_PORT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CompletionKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_ASSOCIATE_COMPLETION_PORT),
            "::",
            stringify!(CompletionKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CompletionPort) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_ASSOCIATE_COMPLETION_PORT),
            "::",
            stringify!(CompletionPort)
        )
    );
}
pub type JOBOBJECT_ASSOCIATE_COMPLETION_PORT = _JOBOBJECT_ASSOCIATE_COMPLETION_PORT;
pub type PJOBOBJECT_ASSOCIATE_COMPLETION_PORT = *mut _JOBOBJECT_ASSOCIATE_COMPLETION_PORT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
    pub BasicInfo: JOBOBJECT_BASIC_ACCOUNTING_INFORMATION,
    pub IoInfo: IO_COUNTERS,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BasicInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION),
            "::",
            stringify!(BasicInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoInfo) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION),
            "::",
            stringify!(IoInfo)
        )
    );
}
pub type JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION =
    _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;
pub type PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION =
    *mut _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_JOBSET_INFORMATION {
    pub MemberLevel: DWORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_JOBSET_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_JOBOBJECT_JOBSET_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_JOBSET_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_JOBOBJECT_JOBSET_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_JOBSET_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_JOBOBJECT_JOBSET_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MemberLevel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_JOBSET_INFORMATION),
            "::",
            stringify!(MemberLevel)
        )
    );
}
pub type JOBOBJECT_JOBSET_INFORMATION = _JOBOBJECT_JOBSET_INFORMATION;
pub type PJOBOBJECT_JOBSET_INFORMATION = *mut _JOBOBJECT_JOBSET_INFORMATION;
pub const _JOBOBJECT_RATE_CONTROL_TOLERANCE_ToleranceLow: _JOBOBJECT_RATE_CONTROL_TOLERANCE = 1;
pub const _JOBOBJECT_RATE_CONTROL_TOLERANCE_ToleranceMedium: _JOBOBJECT_RATE_CONTROL_TOLERANCE = 2;
pub const _JOBOBJECT_RATE_CONTROL_TOLERANCE_ToleranceHigh: _JOBOBJECT_RATE_CONTROL_TOLERANCE = 3;
pub type _JOBOBJECT_RATE_CONTROL_TOLERANCE = ::std::os::raw::c_uint;
pub use self::_JOBOBJECT_RATE_CONTROL_TOLERANCE as JOBOBJECT_RATE_CONTROL_TOLERANCE;
pub const _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL_ToleranceIntervalShort:
    _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL = 1;
pub const _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL_ToleranceIntervalMedium:
    _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL = 2;
pub const _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL_ToleranceIntervalLong:
    _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL = 3;
pub type _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL = ::std::os::raw::c_uint;
pub use self::_JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL as JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {
    pub IoReadBytesLimit: DWORD64,
    pub IoWriteBytesLimit: DWORD64,
    pub PerJobUserTimeLimit: LARGE_INTEGER,
    pub JobMemoryLimit: DWORD64,
    pub RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub RateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    pub LimitFlags: DWORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoReadBytesLimit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
            "::",
            stringify!(IoReadBytesLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoWriteBytesLimit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
            "::",
            stringify!(IoWriteBytesLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PerJobUserTimeLimit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
            "::",
            stringify!(PerJobUserTimeLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JobMemoryLimit) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
            "::",
            stringify!(JobMemoryLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RateControlTolerance) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
            "::",
            stringify!(RateControlTolerance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).RateControlToleranceInterval) as usize - ptr as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
            "::",
            stringify!(RateControlToleranceInterval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LimitFlags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
            "::",
            stringify!(LimitFlags)
        )
    );
}
pub type JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION;
pub type PJOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = *mut _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 {
    pub IoReadBytesLimit: DWORD64,
    pub IoWriteBytesLimit: DWORD64,
    pub PerJobUserTimeLimit: LARGE_INTEGER,
    pub __bindgen_anon_1: JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1,
    pub __bindgen_anon_2: JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2,
    pub __bindgen_anon_3: JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3,
    pub LimitFlags: DWORD,
    pub IoRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub JobLowMemoryLimit: DWORD64,
    pub IoRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    pub NetRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub NetRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1 {
    pub JobHighMemoryLimit: DWORD64,
    pub JobMemoryLimit: DWORD64,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JobHighMemoryLimit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1),
            "::",
            stringify!(JobHighMemoryLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JobMemoryLimit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1),
            "::",
            stringify!(JobMemoryLimit)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2 {
    pub RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub CpuRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<
        JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RateControlTolerance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2),
            "::",
            stringify!(RateControlTolerance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CpuRateControlTolerance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2),
            "::",
            stringify!(CpuRateControlTolerance)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3 {
    pub RateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    pub CpuRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<
        JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).RateControlToleranceInterval) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3),
            "::",
            stringify!(RateControlToleranceInterval)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CpuRateControlToleranceInterval) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3),
            "::",
            stringify!(CpuRateControlToleranceInterval)
        )
    );
}
#[test]
fn bindgen_test_layout_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2() {
    const UNINIT: ::std::mem::MaybeUninit<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoReadBytesLimit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
            "::",
            stringify!(IoReadBytesLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoWriteBytesLimit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
            "::",
            stringify!(IoWriteBytesLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PerJobUserTimeLimit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
            "::",
            stringify!(PerJobUserTimeLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LimitFlags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
            "::",
            stringify!(LimitFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoRateControlTolerance) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
            "::",
            stringify!(IoRateControlTolerance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JobLowMemoryLimit) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
            "::",
            stringify!(JobLowMemoryLimit)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).IoRateControlToleranceInterval) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
            "::",
            stringify!(IoRateControlToleranceInterval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NetRateControlTolerance) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
            "::",
            stringify!(NetRateControlTolerance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).NetRateControlToleranceInterval) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
            "::",
            stringify!(NetRateControlToleranceInterval)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_LIMIT_VIOLATION_INFORMATION {
    pub LimitFlags: DWORD,
    pub ViolationLimitFlags: DWORD,
    pub IoReadBytes: DWORD64,
    pub IoReadBytesLimit: DWORD64,
    pub IoWriteBytes: DWORD64,
    pub IoWriteBytesLimit: DWORD64,
    pub PerJobUserTime: LARGE_INTEGER,
    pub PerJobUserTimeLimit: LARGE_INTEGER,
    pub JobMemory: DWORD64,
    pub JobMemoryLimit: DWORD64,
    pub RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub RateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_LIMIT_VIOLATION_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LimitFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(LimitFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ViolationLimitFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(ViolationLimitFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoReadBytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(IoReadBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoReadBytesLimit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(IoReadBytesLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoWriteBytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(IoWriteBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoWriteBytesLimit) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(IoWriteBytesLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PerJobUserTime) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(PerJobUserTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PerJobUserTimeLimit) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(PerJobUserTimeLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JobMemory) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(JobMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JobMemoryLimit) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(JobMemoryLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RateControlTolerance) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(RateControlTolerance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RateControlToleranceLimit) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(RateControlToleranceLimit)
        )
    );
}
pub type JOBOBJECT_LIMIT_VIOLATION_INFORMATION = _JOBOBJECT_LIMIT_VIOLATION_INFORMATION;
pub type PJOBOBJECT_LIMIT_VIOLATION_INFORMATION = *mut _JOBOBJECT_LIMIT_VIOLATION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 {
    pub LimitFlags: DWORD,
    pub ViolationLimitFlags: DWORD,
    pub IoReadBytes: DWORD64,
    pub IoReadBytesLimit: DWORD64,
    pub IoWriteBytes: DWORD64,
    pub IoWriteBytesLimit: DWORD64,
    pub PerJobUserTime: LARGE_INTEGER,
    pub PerJobUserTimeLimit: LARGE_INTEGER,
    pub JobMemory: DWORD64,
    pub __bindgen_anon_1: JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1,
    pub __bindgen_anon_2: JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2,
    pub __bindgen_anon_3: JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3,
    pub JobLowMemoryLimit: DWORD64,
    pub IoRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub IoRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub NetRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub NetRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1 {
    pub JobHighMemoryLimit: DWORD64,
    pub JobMemoryLimit: DWORD64,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JobHighMemoryLimit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1),
            "::",
            stringify!(JobHighMemoryLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JobMemoryLimit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1),
            "::",
            stringify!(JobMemoryLimit)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2 {
    pub RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub CpuRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RateControlTolerance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2),
            "::",
            stringify!(RateControlTolerance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CpuRateControlTolerance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2),
            "::",
            stringify!(CpuRateControlTolerance)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3 {
    pub RateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub CpuRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RateControlToleranceLimit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3),
            "::",
            stringify!(RateControlToleranceLimit)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CpuRateControlToleranceLimit) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3),
            "::",
            stringify!(CpuRateControlToleranceLimit)
        )
    );
}
#[test]
fn bindgen_test_layout_JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2() {
    const UNINIT: ::std::mem::MaybeUninit<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LimitFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(LimitFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ViolationLimitFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(ViolationLimitFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoReadBytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(IoReadBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoReadBytesLimit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(IoReadBytesLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoWriteBytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(IoWriteBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoWriteBytesLimit) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(IoWriteBytesLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PerJobUserTime) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(PerJobUserTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PerJobUserTimeLimit) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(PerJobUserTimeLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JobMemory) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(JobMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JobLowMemoryLimit) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(JobLowMemoryLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoRateControlTolerance) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(IoRateControlTolerance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoRateControlToleranceLimit) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(IoRateControlToleranceLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NetRateControlTolerance) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(NetRateControlTolerance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).NetRateControlToleranceLimit) as usize - ptr as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(NetRateControlToleranceLimit)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {
    pub ControlFlags: DWORD,
    pub __bindgen_anon_1: _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1 {
    pub CpuRate: DWORD,
    pub Weight: DWORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CpuRate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(CpuRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Weight) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(Weight)
        )
    );
}
#[test]
fn bindgen_test_layout__JOBOBJECT_CPU_RATE_CONTROL_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ControlFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION),
            "::",
            stringify!(ControlFlags)
        )
    );
}
pub type JOBOBJECT_CPU_RATE_CONTROL_INFORMATION = _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION;
pub type PJOBOBJECT_CPU_RATE_CONTROL_INFORMATION = *mut _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION;
pub const JOB_OBJECT_NET_RATE_CONTROL_FLAGS_JOB_OBJECT_NET_RATE_CONTROL_ENABLE:
    JOB_OBJECT_NET_RATE_CONTROL_FLAGS = 1;
pub const JOB_OBJECT_NET_RATE_CONTROL_FLAGS_JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH:
    JOB_OBJECT_NET_RATE_CONTROL_FLAGS = 2;
pub const JOB_OBJECT_NET_RATE_CONTROL_FLAGS_JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG:
    JOB_OBJECT_NET_RATE_CONTROL_FLAGS = 4;
pub const JOB_OBJECT_NET_RATE_CONTROL_FLAGS_JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS:
    JOB_OBJECT_NET_RATE_CONTROL_FLAGS = 7;
pub type JOB_OBJECT_NET_RATE_CONTROL_FLAGS = ::std::os::raw::c_uint;
extern "C" {
    pub fn __C_ASSERT__(arg1: *mut ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JOBOBJECT_NET_RATE_CONTROL_INFORMATION {
    pub MaxBandwidth: DWORD64,
    pub ControlFlags: JOB_OBJECT_NET_RATE_CONTROL_FLAGS,
    pub DscpTag: BYTE,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_NET_RATE_CONTROL_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<JOBOBJECT_NET_RATE_CONTROL_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_NET_RATE_CONTROL_INFORMATION>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_NET_RATE_CONTROL_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_NET_RATE_CONTROL_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_NET_RATE_CONTROL_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxBandwidth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NET_RATE_CONTROL_INFORMATION),
            "::",
            stringify!(MaxBandwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ControlFlags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NET_RATE_CONTROL_INFORMATION),
            "::",
            stringify!(ControlFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DscpTag) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NET_RATE_CONTROL_INFORMATION),
            "::",
            stringify!(DscpTag)
        )
    );
}
pub const JOB_OBJECT_IO_RATE_CONTROL_FLAGS_JOB_OBJECT_IO_RATE_CONTROL_ENABLE:
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS = 1;
pub const JOB_OBJECT_IO_RATE_CONTROL_FLAGS_JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME:
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS = 2;
pub const JOB_OBJECT_IO_RATE_CONTROL_FLAGS_JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL:
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS = 4;
pub const JOB_OBJECT_IO_RATE_CONTROL_FLAGS_JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP : JOB_OBJECT_IO_RATE_CONTROL_FLAGS = 8 ;
pub const JOB_OBJECT_IO_RATE_CONTROL_FLAGS_JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS:
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS = 15;
pub type JOB_OBJECT_IO_RATE_CONTROL_FLAGS = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE {
    pub MaxIops: LONG64,
    pub MaxBandwidth: LONG64,
    pub ReservationIops: LONG64,
    pub VolumeName: PWSTR,
    pub BaseIoSize: DWORD,
    pub ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    pub VolumeNameLength: WORD,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE() {
    const UNINIT: ::std::mem::MaybeUninit<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxIops) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
            "::",
            stringify!(MaxIops)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxBandwidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
            "::",
            stringify!(MaxBandwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservationIops) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
            "::",
            stringify!(ReservationIops)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
            "::",
            stringify!(VolumeName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BaseIoSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
            "::",
            stringify!(BaseIoSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ControlFlags) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
            "::",
            stringify!(ControlFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeNameLength) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
            "::",
            stringify!(VolumeNameLength)
        )
    );
}
pub type JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V1 =
    JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 {
    pub MaxIops: LONG64,
    pub MaxBandwidth: LONG64,
    pub ReservationIops: LONG64,
    pub VolumeName: PWSTR,
    pub BaseIoSize: DWORD,
    pub ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    pub VolumeNameLength: WORD,
    pub CriticalReservationIops: LONG64,
    pub ReservationBandwidth: LONG64,
    pub CriticalReservationBandwidth: LONG64,
    pub MaxTimePercent: LONG64,
    pub ReservationTimePercent: LONG64,
    pub CriticalReservationTimePercent: LONG64,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2() {
    const UNINIT: ::std::mem::MaybeUninit<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxIops) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(MaxIops)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxBandwidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(MaxBandwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservationIops) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(ReservationIops)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(VolumeName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BaseIoSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(BaseIoSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ControlFlags) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(ControlFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeNameLength) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(VolumeNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CriticalReservationIops) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(CriticalReservationIops)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservationBandwidth) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(ReservationBandwidth)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CriticalReservationBandwidth) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(CriticalReservationBandwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxTimePercent) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(MaxTimePercent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservationTimePercent) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(ReservationTimePercent)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CriticalReservationTimePercent) as usize - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(CriticalReservationTimePercent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 {
    pub MaxIops: LONG64,
    pub MaxBandwidth: LONG64,
    pub ReservationIops: LONG64,
    pub VolumeName: PWSTR,
    pub BaseIoSize: DWORD,
    pub ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    pub VolumeNameLength: WORD,
    pub CriticalReservationIops: LONG64,
    pub ReservationBandwidth: LONG64,
    pub CriticalReservationBandwidth: LONG64,
    pub MaxTimePercent: LONG64,
    pub ReservationTimePercent: LONG64,
    pub CriticalReservationTimePercent: LONG64,
    pub SoftMaxIops: LONG64,
    pub SoftMaxBandwidth: LONG64,
    pub SoftMaxTimePercent: LONG64,
    pub LimitExcessNotifyIops: LONG64,
    pub LimitExcessNotifyBandwidth: LONG64,
    pub LimitExcessNotifyTimePercent: LONG64,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3() {
    const UNINIT: ::std::mem::MaybeUninit<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxIops) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(MaxIops)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxBandwidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(MaxBandwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservationIops) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(ReservationIops)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(VolumeName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BaseIoSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(BaseIoSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ControlFlags) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(ControlFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeNameLength) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(VolumeNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CriticalReservationIops) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(CriticalReservationIops)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservationBandwidth) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(ReservationBandwidth)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CriticalReservationBandwidth) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(CriticalReservationBandwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxTimePercent) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(MaxTimePercent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservationTimePercent) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(ReservationTimePercent)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CriticalReservationTimePercent) as usize - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(CriticalReservationTimePercent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SoftMaxIops) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(SoftMaxIops)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SoftMaxBandwidth) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(SoftMaxBandwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SoftMaxTimePercent) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(SoftMaxTimePercent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LimitExcessNotifyIops) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(LimitExcessNotifyIops)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LimitExcessNotifyBandwidth) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(LimitExcessNotifyBandwidth)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).LimitExcessNotifyTimePercent) as usize - ptr as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(LimitExcessNotifyTimePercent)
        )
    );
}
pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS_JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE:
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS = 1;
pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS_JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE:
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS = 2;
pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS_JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS:
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS = 3;
pub type JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_IO_ATTRIBUTION_STATS {
    pub IoCount: ULONG_PTR,
    pub TotalNonOverlappedQueueTime: ULONGLONG,
    pub TotalNonOverlappedServiceTime: ULONGLONG,
    pub TotalSize: ULONGLONG,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_IO_ATTRIBUTION_STATS() {
    const UNINIT: ::std::mem::MaybeUninit<_JOBOBJECT_IO_ATTRIBUTION_STATS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_IO_ATTRIBUTION_STATS>(),
        32usize,
        concat!("Size of: ", stringify!(_JOBOBJECT_IO_ATTRIBUTION_STATS))
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_IO_ATTRIBUTION_STATS>(),
        8usize,
        concat!("Alignment of ", stringify!(_JOBOBJECT_IO_ATTRIBUTION_STATS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_IO_ATTRIBUTION_STATS),
            "::",
            stringify!(IoCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalNonOverlappedQueueTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_IO_ATTRIBUTION_STATS),
            "::",
            stringify!(TotalNonOverlappedQueueTime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).TotalNonOverlappedServiceTime) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_IO_ATTRIBUTION_STATS),
            "::",
            stringify!(TotalNonOverlappedServiceTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_IO_ATTRIBUTION_STATS),
            "::",
            stringify!(TotalSize)
        )
    );
}
pub type JOBOBJECT_IO_ATTRIBUTION_STATS = _JOBOBJECT_IO_ATTRIBUTION_STATS;
pub type PJOBOBJECT_IO_ATTRIBUTION_STATS = *mut _JOBOBJECT_IO_ATTRIBUTION_STATS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_IO_ATTRIBUTION_INFORMATION {
    pub ControlFlags: DWORD,
    pub ReadStats: JOBOBJECT_IO_ATTRIBUTION_STATS,
    pub WriteStats: JOBOBJECT_IO_ATTRIBUTION_STATS,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_IO_ATTRIBUTION_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_JOBOBJECT_IO_ATTRIBUTION_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_IO_ATTRIBUTION_INFORMATION>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_IO_ATTRIBUTION_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_IO_ATTRIBUTION_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_IO_ATTRIBUTION_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ControlFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_IO_ATTRIBUTION_INFORMATION),
            "::",
            stringify!(ControlFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadStats) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_IO_ATTRIBUTION_INFORMATION),
            "::",
            stringify!(ReadStats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteStats) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_IO_ATTRIBUTION_INFORMATION),
            "::",
            stringify!(WriteStats)
        )
    );
}
pub type JOBOBJECT_IO_ATTRIBUTION_INFORMATION = _JOBOBJECT_IO_ATTRIBUTION_INFORMATION;
pub type PJOBOBJECT_IO_ATTRIBUTION_INFORMATION = *mut _JOBOBJECT_IO_ATTRIBUTION_INFORMATION;
pub const _JOBOBJECTINFOCLASS_JobObjectBasicAccountingInformation: _JOBOBJECTINFOCLASS = 1;
pub const _JOBOBJECTINFOCLASS_JobObjectBasicLimitInformation: _JOBOBJECTINFOCLASS = 2;
pub const _JOBOBJECTINFOCLASS_JobObjectBasicProcessIdList: _JOBOBJECTINFOCLASS = 3;
pub const _JOBOBJECTINFOCLASS_JobObjectBasicUIRestrictions: _JOBOBJECTINFOCLASS = 4;
pub const _JOBOBJECTINFOCLASS_JobObjectSecurityLimitInformation: _JOBOBJECTINFOCLASS = 5;
pub const _JOBOBJECTINFOCLASS_JobObjectEndOfJobTimeInformation: _JOBOBJECTINFOCLASS = 6;
pub const _JOBOBJECTINFOCLASS_JobObjectAssociateCompletionPortInformation: _JOBOBJECTINFOCLASS = 7;
pub const _JOBOBJECTINFOCLASS_JobObjectBasicAndIoAccountingInformation: _JOBOBJECTINFOCLASS = 8;
pub const _JOBOBJECTINFOCLASS_JobObjectExtendedLimitInformation: _JOBOBJECTINFOCLASS = 9;
pub const _JOBOBJECTINFOCLASS_JobObjectJobSetInformation: _JOBOBJECTINFOCLASS = 10;
pub const _JOBOBJECTINFOCLASS_JobObjectGroupInformation: _JOBOBJECTINFOCLASS = 11;
pub const _JOBOBJECTINFOCLASS_JobObjectNotificationLimitInformation: _JOBOBJECTINFOCLASS = 12;
pub const _JOBOBJECTINFOCLASS_JobObjectLimitViolationInformation: _JOBOBJECTINFOCLASS = 13;
pub const _JOBOBJECTINFOCLASS_JobObjectGroupInformationEx: _JOBOBJECTINFOCLASS = 14;
pub const _JOBOBJECTINFOCLASS_JobObjectCpuRateControlInformation: _JOBOBJECTINFOCLASS = 15;
pub const _JOBOBJECTINFOCLASS_JobObjectCompletionFilter: _JOBOBJECTINFOCLASS = 16;
pub const _JOBOBJECTINFOCLASS_JobObjectCompletionCounter: _JOBOBJECTINFOCLASS = 17;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved1Information: _JOBOBJECTINFOCLASS = 18;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved2Information: _JOBOBJECTINFOCLASS = 19;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved3Information: _JOBOBJECTINFOCLASS = 20;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved4Information: _JOBOBJECTINFOCLASS = 21;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved5Information: _JOBOBJECTINFOCLASS = 22;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved6Information: _JOBOBJECTINFOCLASS = 23;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved7Information: _JOBOBJECTINFOCLASS = 24;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved8Information: _JOBOBJECTINFOCLASS = 25;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved9Information: _JOBOBJECTINFOCLASS = 26;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved10Information: _JOBOBJECTINFOCLASS = 27;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved11Information: _JOBOBJECTINFOCLASS = 28;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved12Information: _JOBOBJECTINFOCLASS = 29;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved13Information: _JOBOBJECTINFOCLASS = 30;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved14Information: _JOBOBJECTINFOCLASS = 31;
pub const _JOBOBJECTINFOCLASS_JobObjectNetRateControlInformation: _JOBOBJECTINFOCLASS = 32;
pub const _JOBOBJECTINFOCLASS_JobObjectNotificationLimitInformation2: _JOBOBJECTINFOCLASS = 33;
pub const _JOBOBJECTINFOCLASS_JobObjectLimitViolationInformation2: _JOBOBJECTINFOCLASS = 34;
pub const _JOBOBJECTINFOCLASS_JobObjectCreateSilo: _JOBOBJECTINFOCLASS = 35;
pub const _JOBOBJECTINFOCLASS_JobObjectSiloBasicInformation: _JOBOBJECTINFOCLASS = 36;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved15Information: _JOBOBJECTINFOCLASS = 37;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved16Information: _JOBOBJECTINFOCLASS = 38;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved17Information: _JOBOBJECTINFOCLASS = 39;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved18Information: _JOBOBJECTINFOCLASS = 40;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved19Information: _JOBOBJECTINFOCLASS = 41;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved20Information: _JOBOBJECTINFOCLASS = 42;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved21Information: _JOBOBJECTINFOCLASS = 43;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved22Information: _JOBOBJECTINFOCLASS = 44;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved23Information: _JOBOBJECTINFOCLASS = 45;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved24Information: _JOBOBJECTINFOCLASS = 46;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved25Information: _JOBOBJECTINFOCLASS = 47;
pub const _JOBOBJECTINFOCLASS_MaxJobObjectInfoClass: _JOBOBJECTINFOCLASS = 48;
pub type _JOBOBJECTINFOCLASS = ::std::os::raw::c_uint;
pub use self::_JOBOBJECTINFOCLASS as JOBOBJECTINFOCLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SILOOBJECT_BASIC_INFORMATION {
    pub SiloId: DWORD,
    pub SiloParentId: DWORD,
    pub NumberOfProcesses: DWORD,
    pub IsInServerSilo: BOOLEAN,
    pub Reserved: [BYTE; 3usize],
}
#[test]
fn bindgen_test_layout__SILOOBJECT_BASIC_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SILOOBJECT_BASIC_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SILOOBJECT_BASIC_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_SILOOBJECT_BASIC_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SILOOBJECT_BASIC_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_SILOOBJECT_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SiloId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SILOOBJECT_BASIC_INFORMATION),
            "::",
            stringify!(SiloId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SiloParentId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SILOOBJECT_BASIC_INFORMATION),
            "::",
            stringify!(SiloParentId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfProcesses) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SILOOBJECT_BASIC_INFORMATION),
            "::",
            stringify!(NumberOfProcesses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsInServerSilo) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SILOOBJECT_BASIC_INFORMATION),
            "::",
            stringify!(IsInServerSilo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(_SILOOBJECT_BASIC_INFORMATION),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type SILOOBJECT_BASIC_INFORMATION = _SILOOBJECT_BASIC_INFORMATION;
pub type PSILOOBJECT_BASIC_INFORMATION = *mut _SILOOBJECT_BASIC_INFORMATION;
pub const _SERVERSILO_STATE_SERVERSILO_INITING: _SERVERSILO_STATE = 0;
pub const _SERVERSILO_STATE_SERVERSILO_STARTED: _SERVERSILO_STATE = 1;
pub const _SERVERSILO_STATE_SERVERSILO_SHUTTING_DOWN: _SERVERSILO_STATE = 2;
pub const _SERVERSILO_STATE_SERVERSILO_TERMINATING: _SERVERSILO_STATE = 3;
pub const _SERVERSILO_STATE_SERVERSILO_TERMINATED: _SERVERSILO_STATE = 4;
pub type _SERVERSILO_STATE = ::std::os::raw::c_uint;
pub use self::_SERVERSILO_STATE as SERVERSILO_STATE;
pub type PSERVERSILO_STATE = *mut _SERVERSILO_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVERSILO_BASIC_INFORMATION {
    pub ServiceSessionId: DWORD,
    pub State: SERVERSILO_STATE,
    pub ExitStatus: DWORD,
    pub IsDownlevelContainer: BOOLEAN,
    pub ApiSetSchema: PVOID,
    pub HostApiSetSchema: PVOID,
}
#[test]
fn bindgen_test_layout__SERVERSILO_BASIC_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SERVERSILO_BASIC_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SERVERSILO_BASIC_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_SERVERSILO_BASIC_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SERVERSILO_BASIC_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_SERVERSILO_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ServiceSessionId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SERVERSILO_BASIC_INFORMATION),
            "::",
            stringify!(ServiceSessionId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SERVERSILO_BASIC_INFORMATION),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExitStatus) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SERVERSILO_BASIC_INFORMATION),
            "::",
            stringify!(ExitStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsDownlevelContainer) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SERVERSILO_BASIC_INFORMATION),
            "::",
            stringify!(IsDownlevelContainer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApiSetSchema) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SERVERSILO_BASIC_INFORMATION),
            "::",
            stringify!(ApiSetSchema)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HostApiSetSchema) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SERVERSILO_BASIC_INFORMATION),
            "::",
            stringify!(HostApiSetSchema)
        )
    );
}
pub type SERVERSILO_BASIC_INFORMATION = _SERVERSILO_BASIC_INFORMATION;
pub type PSERVERSILO_BASIC_INFORMATION = *mut _SERVERSILO_BASIC_INFORMATION;
pub const _FIRMWARE_TYPE_FirmwareTypeUnknown: _FIRMWARE_TYPE = 0;
pub const _FIRMWARE_TYPE_FirmwareTypeBios: _FIRMWARE_TYPE = 1;
pub const _FIRMWARE_TYPE_FirmwareTypeUefi: _FIRMWARE_TYPE = 2;
pub const _FIRMWARE_TYPE_FirmwareTypeMax: _FIRMWARE_TYPE = 3;
pub type _FIRMWARE_TYPE = ::std::os::raw::c_uint;
pub use self::_FIRMWARE_TYPE as FIRMWARE_TYPE;
pub type PFIRMWARE_TYPE = *mut _FIRMWARE_TYPE;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationProcessorCore: _LOGICAL_PROCESSOR_RELATIONSHIP =
    0;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationNumaNode: _LOGICAL_PROCESSOR_RELATIONSHIP = 1;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationCache: _LOGICAL_PROCESSOR_RELATIONSHIP = 2;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationProcessorPackage:
    _LOGICAL_PROCESSOR_RELATIONSHIP = 3;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationGroup: _LOGICAL_PROCESSOR_RELATIONSHIP = 4;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationProcessorDie: _LOGICAL_PROCESSOR_RELATIONSHIP = 5;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationNumaNodeEx: _LOGICAL_PROCESSOR_RELATIONSHIP = 6;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationProcessorModule: _LOGICAL_PROCESSOR_RELATIONSHIP =
    7;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationAll: _LOGICAL_PROCESSOR_RELATIONSHIP = 65535;
pub type _LOGICAL_PROCESSOR_RELATIONSHIP = ::std::os::raw::c_uint;
pub use self::_LOGICAL_PROCESSOR_RELATIONSHIP as LOGICAL_PROCESSOR_RELATIONSHIP;
pub const _PROCESSOR_CACHE_TYPE_CacheUnified: _PROCESSOR_CACHE_TYPE = 0;
pub const _PROCESSOR_CACHE_TYPE_CacheInstruction: _PROCESSOR_CACHE_TYPE = 1;
pub const _PROCESSOR_CACHE_TYPE_CacheData: _PROCESSOR_CACHE_TYPE = 2;
pub const _PROCESSOR_CACHE_TYPE_CacheTrace: _PROCESSOR_CACHE_TYPE = 3;
pub type _PROCESSOR_CACHE_TYPE = ::std::os::raw::c_uint;
pub use self::_PROCESSOR_CACHE_TYPE as PROCESSOR_CACHE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CACHE_DESCRIPTOR {
    pub Level: BYTE,
    pub Associativity: BYTE,
    pub LineSize: WORD,
    pub Size: DWORD,
    pub Type: PROCESSOR_CACHE_TYPE,
}
#[test]
fn bindgen_test_layout__CACHE_DESCRIPTOR() {
    const UNINIT: ::std::mem::MaybeUninit<_CACHE_DESCRIPTOR> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CACHE_DESCRIPTOR>(),
        12usize,
        concat!("Size of: ", stringify!(_CACHE_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_CACHE_DESCRIPTOR>(),
        4usize,
        concat!("Alignment of ", stringify!(_CACHE_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_DESCRIPTOR),
            "::",
            stringify!(Level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Associativity) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_DESCRIPTOR),
            "::",
            stringify!(Associativity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LineSize) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_DESCRIPTOR),
            "::",
            stringify!(LineSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_DESCRIPTOR),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_DESCRIPTOR),
            "::",
            stringify!(Type)
        )
    );
}
pub type CACHE_DESCRIPTOR = _CACHE_DESCRIPTOR;
pub type PCACHE_DESCRIPTOR = *mut _CACHE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
    pub ProcessorMask: ULONG_PTR,
    pub Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
    pub __bindgen_anon_1: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1 {
    pub ProcessorCore: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    pub NumaNode: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2,
    pub Cache: CACHE_DESCRIPTOR,
    pub Reserved: [ULONGLONG; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub Flags: BYTE,
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2 {
    pub NodeNumber: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<
        _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NodeNumber) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(NodeNumber)
        )
    );
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProcessorCore) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(ProcessorCore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumaNode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(NumaNode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Cache) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(Cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(Reserved)
        )
    );
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProcessorMask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION),
            "::",
            stringify!(ProcessorMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Relationship) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION),
            "::",
            stringify!(Relationship)
        )
    );
}
pub type SYSTEM_LOGICAL_PROCESSOR_INFORMATION = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
pub type PSYSTEM_LOGICAL_PROCESSOR_INFORMATION = *mut _SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_RELATIONSHIP {
    pub Flags: BYTE,
    pub Reserved: [BYTE; 21usize],
    pub GroupCount: WORD,
    pub GroupMask: [GROUP_AFFINITY; 1usize],
}
#[test]
fn bindgen_test_layout__PROCESSOR_RELATIONSHIP() {
    const UNINIT: ::std::mem::MaybeUninit<_PROCESSOR_RELATIONSHIP> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESSOR_RELATIONSHIP>(),
        40usize,
        concat!("Size of: ", stringify!(_PROCESSOR_RELATIONSHIP))
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESSOR_RELATIONSHIP>(),
        8usize,
        concat!("Alignment of ", stringify!(_PROCESSOR_RELATIONSHIP))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_RELATIONSHIP),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_RELATIONSHIP),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GroupCount) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_RELATIONSHIP),
            "::",
            stringify!(GroupCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GroupMask) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_RELATIONSHIP),
            "::",
            stringify!(GroupMask)
        )
    );
}
pub type PROCESSOR_RELATIONSHIP = _PROCESSOR_RELATIONSHIP;
pub type PPROCESSOR_RELATIONSHIP = *mut _PROCESSOR_RELATIONSHIP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NUMA_NODE_RELATIONSHIP {
    pub NodeNumber: DWORD,
    pub Reserved: [BYTE; 20usize],
    pub GroupMask: GROUP_AFFINITY,
}
#[test]
fn bindgen_test_layout__NUMA_NODE_RELATIONSHIP() {
    const UNINIT: ::std::mem::MaybeUninit<_NUMA_NODE_RELATIONSHIP> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NUMA_NODE_RELATIONSHIP>(),
        40usize,
        concat!("Size of: ", stringify!(_NUMA_NODE_RELATIONSHIP))
    );
    assert_eq!(
        ::std::mem::align_of::<_NUMA_NODE_RELATIONSHIP>(),
        8usize,
        concat!("Alignment of ", stringify!(_NUMA_NODE_RELATIONSHIP))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NodeNumber) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NUMA_NODE_RELATIONSHIP),
            "::",
            stringify!(NodeNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NUMA_NODE_RELATIONSHIP),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GroupMask) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NUMA_NODE_RELATIONSHIP),
            "::",
            stringify!(GroupMask)
        )
    );
}
pub type NUMA_NODE_RELATIONSHIP = _NUMA_NODE_RELATIONSHIP;
pub type PNUMA_NODE_RELATIONSHIP = *mut _NUMA_NODE_RELATIONSHIP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CACHE_RELATIONSHIP {
    pub Level: BYTE,
    pub Associativity: BYTE,
    pub LineSize: WORD,
    pub CacheSize: DWORD,
    pub Type: PROCESSOR_CACHE_TYPE,
    pub Reserved: [BYTE; 20usize],
    pub GroupMask: GROUP_AFFINITY,
}
#[test]
fn bindgen_test_layout__CACHE_RELATIONSHIP() {
    const UNINIT: ::std::mem::MaybeUninit<_CACHE_RELATIONSHIP> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CACHE_RELATIONSHIP>(),
        48usize,
        concat!("Size of: ", stringify!(_CACHE_RELATIONSHIP))
    );
    assert_eq!(
        ::std::mem::align_of::<_CACHE_RELATIONSHIP>(),
        8usize,
        concat!("Alignment of ", stringify!(_CACHE_RELATIONSHIP))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_RELATIONSHIP),
            "::",
            stringify!(Level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Associativity) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_RELATIONSHIP),
            "::",
            stringify!(Associativity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LineSize) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_RELATIONSHIP),
            "::",
            stringify!(LineSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CacheSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_RELATIONSHIP),
            "::",
            stringify!(CacheSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_RELATIONSHIP),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_RELATIONSHIP),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GroupMask) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_RELATIONSHIP),
            "::",
            stringify!(GroupMask)
        )
    );
}
pub type CACHE_RELATIONSHIP = _CACHE_RELATIONSHIP;
pub type PCACHE_RELATIONSHIP = *mut _CACHE_RELATIONSHIP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_GROUP_INFO {
    pub MaximumProcessorCount: BYTE,
    pub ActiveProcessorCount: BYTE,
    pub Reserved: [BYTE; 38usize],
    pub ActiveProcessorMask: KAFFINITY,
}
#[test]
fn bindgen_test_layout__PROCESSOR_GROUP_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<_PROCESSOR_GROUP_INFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESSOR_GROUP_INFO>(),
        48usize,
        concat!("Size of: ", stringify!(_PROCESSOR_GROUP_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESSOR_GROUP_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(_PROCESSOR_GROUP_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumProcessorCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_GROUP_INFO),
            "::",
            stringify!(MaximumProcessorCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ActiveProcessorCount) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_GROUP_INFO),
            "::",
            stringify!(ActiveProcessorCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_GROUP_INFO),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ActiveProcessorMask) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_GROUP_INFO),
            "::",
            stringify!(ActiveProcessorMask)
        )
    );
}
pub type PROCESSOR_GROUP_INFO = _PROCESSOR_GROUP_INFO;
pub type PPROCESSOR_GROUP_INFO = *mut _PROCESSOR_GROUP_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GROUP_RELATIONSHIP {
    pub MaximumGroupCount: WORD,
    pub ActiveGroupCount: WORD,
    pub Reserved: [BYTE; 20usize],
    pub GroupInfo: [PROCESSOR_GROUP_INFO; 1usize],
}
#[test]
fn bindgen_test_layout__GROUP_RELATIONSHIP() {
    const UNINIT: ::std::mem::MaybeUninit<_GROUP_RELATIONSHIP> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GROUP_RELATIONSHIP>(),
        72usize,
        concat!("Size of: ", stringify!(_GROUP_RELATIONSHIP))
    );
    assert_eq!(
        ::std::mem::align_of::<_GROUP_RELATIONSHIP>(),
        8usize,
        concat!("Alignment of ", stringify!(_GROUP_RELATIONSHIP))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumGroupCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GROUP_RELATIONSHIP),
            "::",
            stringify!(MaximumGroupCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ActiveGroupCount) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_GROUP_RELATIONSHIP),
            "::",
            stringify!(ActiveGroupCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GROUP_RELATIONSHIP),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GroupInfo) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GROUP_RELATIONSHIP),
            "::",
            stringify!(GroupInfo)
        )
    );
}
pub type GROUP_RELATIONSHIP = _GROUP_RELATIONSHIP;
pub type PGROUP_RELATIONSHIP = *mut _GROUP_RELATIONSHIP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    pub Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
    pub Size: DWORD,
    pub __bindgen_anon_1: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1 {
    pub Processor: PROCESSOR_RELATIONSHIP,
    pub NumaNode: NUMA_NODE_RELATIONSHIP,
    pub Cache: CACHE_RELATIONSHIP,
    pub Group: GROUP_RELATIONSHIP,
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Processor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1),
            "::",
            stringify!(Processor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumaNode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1),
            "::",
            stringify!(NumaNode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Cache) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1),
            "::",
            stringify!(Cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Group) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1),
            "::",
            stringify!(Group)
        )
    );
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Relationship) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX),
            "::",
            stringify!(Relationship)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX),
            "::",
            stringify!(Size)
        )
    );
}
pub type SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
pub type PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = *mut _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
pub const _CPU_SET_INFORMATION_TYPE_CpuSetInformation: _CPU_SET_INFORMATION_TYPE = 0;
pub type _CPU_SET_INFORMATION_TYPE = ::std::os::raw::c_uint;
pub use self::_CPU_SET_INFORMATION_TYPE as CPU_SET_INFORMATION_TYPE;
pub type PCPU_SET_INFORMATION_TYPE = *mut _CPU_SET_INFORMATION_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION {
    pub Size: DWORD,
    pub Type: CPU_SET_INFORMATION_TYPE,
    pub __bindgen_anon_1: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1 {
    pub CpuSet: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub Id: DWORD,
    pub Group: WORD,
    pub LogicalProcessorIndex: BYTE,
    pub CoreIndex: BYTE,
    pub LastLevelCacheIndex: BYTE,
    pub NumaNodeIndex: BYTE,
    pub EfficiencyClass: BYTE,
    pub __bindgen_anon_1: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub AllocationTag: DWORD64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub AllFlags: BYTE,
    pub __bindgen_anon_1:
        _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(
                _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(
                _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
}
impl _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Parked(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Parked(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Allocated(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Allocated(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AllocatedToTargetProcess(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AllocatedToTargetProcess(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RealTime(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RealTime(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Parked: BYTE,
        Allocated: BYTE,
        AllocatedToTargetProcess: BYTE,
        RealTime: BYTE,
        ReservedFlags: BYTE,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Parked: u8 = unsafe { ::std::mem::transmute(Parked) };
            Parked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Allocated: u8 = unsafe { ::std::mem::transmute(Allocated) };
            Allocated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AllocatedToTargetProcess: u8 =
                unsafe { ::std::mem::transmute(AllocatedToTargetProcess) };
            AllocatedToTargetProcess as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RealTime: u8 = unsafe { ::std::mem::transmute(RealTime) };
            RealTime as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ReservedFlags: u8 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
        ),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
        ),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(AllFlags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub Reserved: DWORD,
    pub SchedulingClass: BYTE,
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<
        _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(
        ),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SchedulingClass) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(SchedulingClass)
        )
    );
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Group) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LogicalProcessorIndex) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(LogicalProcessorIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CoreIndex) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(CoreIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastLevelCacheIndex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(LastLevelCacheIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumaNodeIndex) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(NumaNodeIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EfficiencyClass) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(EfficiencyClass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocationTag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(AllocationTag)
        )
    );
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CpuSet) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(CpuSet)
        )
    );
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_CPU_SET_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_SYSTEM_CPU_SET_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYSTEM_CPU_SET_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION),
            "::",
            stringify!(Type)
        )
    );
}
pub type SYSTEM_CPU_SET_INFORMATION = _SYSTEM_CPU_SET_INFORMATION;
pub type PSYSTEM_CPU_SET_INFORMATION = *mut _SYSTEM_CPU_SET_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_POOL_ZEROING_INFORMATION {
    pub PoolZeroingSupportPresent: BOOLEAN,
}
#[test]
fn bindgen_test_layout__SYSTEM_POOL_ZEROING_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_POOL_ZEROING_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_POOL_ZEROING_INFORMATION>(),
        1usize,
        concat!("Size of: ", stringify!(_SYSTEM_POOL_ZEROING_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_POOL_ZEROING_INFORMATION>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_POOL_ZEROING_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PoolZeroingSupportPresent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POOL_ZEROING_INFORMATION),
            "::",
            stringify!(PoolZeroingSupportPresent)
        )
    );
}
pub type SYSTEM_POOL_ZEROING_INFORMATION = _SYSTEM_POOL_ZEROING_INFORMATION;
pub type PSYSTEM_POOL_ZEROING_INFORMATION = *mut _SYSTEM_POOL_ZEROING_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION {
    pub CycleTime: DWORD64,
}
#[test]
fn bindgen_test_layout__SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CycleTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION),
            "::",
            stringify!(CycleTime)
        )
    );
}
pub type SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
pub type PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = *mut _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION)
        )
    );
}
impl _SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION {
    #[inline]
    pub fn Machine(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Machine(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn KernelMode(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KernelMode(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UserMode(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UserMode(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Native(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Native(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Process(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Process(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WoW64Container(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WoW64Container(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedZero0(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedZero0(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Machine: DWORD,
        KernelMode: DWORD,
        UserMode: DWORD,
        Native: DWORD,
        Process: DWORD,
        WoW64Container: DWORD,
        ReservedZero0: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let Machine: u32 = unsafe { ::std::mem::transmute(Machine) };
            Machine as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let KernelMode: u32 = unsafe { ::std::mem::transmute(KernelMode) };
            KernelMode as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let UserMode: u32 = unsafe { ::std::mem::transmute(UserMode) };
            UserMode as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let Native: u32 = unsafe { ::std::mem::transmute(Native) };
            Native as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let Process: u32 = unsafe { ::std::mem::transmute(Process) };
            Process as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let WoW64Container: u32 = unsafe { ::std::mem::transmute(WoW64Container) };
            WoW64Container as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let ReservedZero0: u32 = unsafe { ::std::mem::transmute(ReservedZero0) };
            ReservedZero0 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION =
    _SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION;
pub type PSYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION =
    *mut _SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSTATE_FEATURE {
    pub Offset: DWORD,
    pub Size: DWORD,
}
#[test]
fn bindgen_test_layout__XSTATE_FEATURE() {
    const UNINIT: ::std::mem::MaybeUninit<_XSTATE_FEATURE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_XSTATE_FEATURE>(),
        8usize,
        concat!("Size of: ", stringify!(_XSTATE_FEATURE))
    );
    assert_eq!(
        ::std::mem::align_of::<_XSTATE_FEATURE>(),
        4usize,
        concat!("Alignment of ", stringify!(_XSTATE_FEATURE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_FEATURE),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_FEATURE),
            "::",
            stringify!(Size)
        )
    );
}
pub type XSTATE_FEATURE = _XSTATE_FEATURE;
pub type PXSTATE_FEATURE = *mut _XSTATE_FEATURE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XSTATE_CONFIGURATION {
    pub EnabledFeatures: DWORD64,
    pub EnabledVolatileFeatures: DWORD64,
    pub Size: DWORD,
    pub __bindgen_anon_1: _XSTATE_CONFIGURATION__bindgen_ty_1,
    pub Features: [XSTATE_FEATURE; 64usize],
    pub EnabledSupervisorFeatures: DWORD64,
    pub AlignedFeatures: DWORD64,
    pub AllFeatureSize: DWORD,
    pub AllFeatures: [DWORD; 64usize],
    pub EnabledUserVisibleSupervisorFeatures: DWORD64,
    pub ExtendedFeatureDisableFeatures: DWORD64,
    pub AllNonLargeFeatureSize: DWORD,
    pub Spare: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XSTATE_CONFIGURATION__bindgen_ty_1 {
    pub ControlFlags: DWORD,
    pub __bindgen_anon_1: _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout__XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn OptimizedSave(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OptimizedSave(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CompactionEnabled(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompactionEnabled(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExtendedFeatureDisable(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendedFeatureDisable(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OptimizedSave: DWORD,
        CompactionEnabled: DWORD,
        ExtendedFeatureDisable: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OptimizedSave: u32 = unsafe { ::std::mem::transmute(OptimizedSave) };
            OptimizedSave as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CompactionEnabled: u32 = unsafe { ::std::mem::transmute(CompactionEnabled) };
            CompactionEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ExtendedFeatureDisable: u32 =
                unsafe { ::std::mem::transmute(ExtendedFeatureDisable) };
            ExtendedFeatureDisable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__XSTATE_CONFIGURATION__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_XSTATE_CONFIGURATION__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_XSTATE_CONFIGURATION__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_XSTATE_CONFIGURATION__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_XSTATE_CONFIGURATION__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_XSTATE_CONFIGURATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ControlFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION__bindgen_ty_1),
            "::",
            stringify!(ControlFlags)
        )
    );
}
#[test]
fn bindgen_test_layout__XSTATE_CONFIGURATION() {
    const UNINIT: ::std::mem::MaybeUninit<_XSTATE_CONFIGURATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_XSTATE_CONFIGURATION>(),
        840usize,
        concat!("Size of: ", stringify!(_XSTATE_CONFIGURATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_XSTATE_CONFIGURATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_XSTATE_CONFIGURATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnabledFeatures) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(EnabledFeatures)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnabledVolatileFeatures) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(EnabledVolatileFeatures)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Features) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(Features)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnabledSupervisorFeatures) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(EnabledSupervisorFeatures)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AlignedFeatures) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(AlignedFeatures)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllFeatureSize) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(AllFeatureSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllFeatures) as usize - ptr as usize },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(AllFeatures)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).EnabledUserVisibleSupervisorFeatures) as usize
                - ptr as usize
        },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(EnabledUserVisibleSupervisorFeatures)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ExtendedFeatureDisableFeatures) as usize - ptr as usize
        },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(ExtendedFeatureDisableFeatures)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllNonLargeFeatureSize) as usize - ptr as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(AllNonLargeFeatureSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Spare) as usize - ptr as usize },
        836usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(Spare)
        )
    );
}
pub type XSTATE_CONFIGURATION = _XSTATE_CONFIGURATION;
pub type PXSTATE_CONFIGURATION = *mut _XSTATE_CONFIGURATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_BASIC_INFORMATION {
    pub BaseAddress: PVOID,
    pub AllocationBase: PVOID,
    pub AllocationProtect: DWORD,
    pub PartitionId: WORD,
    pub RegionSize: SIZE_T,
    pub State: DWORD,
    pub Protect: DWORD,
    pub Type: DWORD,
}
#[test]
fn bindgen_test_layout__MEMORY_BASIC_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_MEMORY_BASIC_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_MEMORY_BASIC_INFORMATION>(),
        48usize,
        concat!("Size of: ", stringify!(_MEMORY_BASIC_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_MEMORY_BASIC_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_MEMORY_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BaseAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(BaseAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocationBase) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(AllocationBase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocationProtect) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(AllocationProtect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PartitionId) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(PartitionId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RegionSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(RegionSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Protect) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(Protect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(Type)
        )
    );
}
pub type MEMORY_BASIC_INFORMATION = _MEMORY_BASIC_INFORMATION;
pub type PMEMORY_BASIC_INFORMATION = *mut _MEMORY_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_BASIC_INFORMATION32 {
    pub BaseAddress: DWORD,
    pub AllocationBase: DWORD,
    pub AllocationProtect: DWORD,
    pub RegionSize: DWORD,
    pub State: DWORD,
    pub Protect: DWORD,
    pub Type: DWORD,
}
#[test]
fn bindgen_test_layout__MEMORY_BASIC_INFORMATION32() {
    const UNINIT: ::std::mem::MaybeUninit<_MEMORY_BASIC_INFORMATION32> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_MEMORY_BASIC_INFORMATION32>(),
        28usize,
        concat!("Size of: ", stringify!(_MEMORY_BASIC_INFORMATION32))
    );
    assert_eq!(
        ::std::mem::align_of::<_MEMORY_BASIC_INFORMATION32>(),
        4usize,
        concat!("Alignment of ", stringify!(_MEMORY_BASIC_INFORMATION32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BaseAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION32),
            "::",
            stringify!(BaseAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocationBase) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION32),
            "::",
            stringify!(AllocationBase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocationProtect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION32),
            "::",
            stringify!(AllocationProtect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RegionSize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION32),
            "::",
            stringify!(RegionSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION32),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Protect) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION32),
            "::",
            stringify!(Protect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION32),
            "::",
            stringify!(Type)
        )
    );
}
pub type MEMORY_BASIC_INFORMATION32 = _MEMORY_BASIC_INFORMATION32;
pub type PMEMORY_BASIC_INFORMATION32 = *mut _MEMORY_BASIC_INFORMATION32;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_BASIC_INFORMATION64 {
    pub BaseAddress: ULONGLONG,
    pub AllocationBase: ULONGLONG,
    pub AllocationProtect: DWORD,
    pub __alignment1: DWORD,
    pub RegionSize: ULONGLONG,
    pub State: DWORD,
    pub Protect: DWORD,
    pub Type: DWORD,
    pub __alignment2: DWORD,
}
#[test]
fn bindgen_test_layout__MEMORY_BASIC_INFORMATION64() {
    const UNINIT: ::std::mem::MaybeUninit<_MEMORY_BASIC_INFORMATION64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_MEMORY_BASIC_INFORMATION64>(),
        48usize,
        concat!("Size of: ", stringify!(_MEMORY_BASIC_INFORMATION64))
    );
    assert_eq!(
        ::std::mem::align_of::<_MEMORY_BASIC_INFORMATION64>(),
        16usize,
        concat!("Alignment of ", stringify!(_MEMORY_BASIC_INFORMATION64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BaseAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION64),
            "::",
            stringify!(BaseAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocationBase) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION64),
            "::",
            stringify!(AllocationBase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocationProtect) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION64),
            "::",
            stringify!(AllocationProtect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__alignment1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION64),
            "::",
            stringify!(__alignment1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RegionSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION64),
            "::",
            stringify!(RegionSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION64),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Protect) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION64),
            "::",
            stringify!(Protect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION64),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__alignment2) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION64),
            "::",
            stringify!(__alignment2)
        )
    );
}
pub type MEMORY_BASIC_INFORMATION64 = _MEMORY_BASIC_INFORMATION64;
pub type PMEMORY_BASIC_INFORMATION64 = *mut _MEMORY_BASIC_INFORMATION64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CFG_CALL_TARGET_INFO {
    pub Offset: ULONG_PTR,
    pub Flags: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__CFG_CALL_TARGET_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<_CFG_CALL_TARGET_INFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CFG_CALL_TARGET_INFO>(),
        16usize,
        concat!("Size of: ", stringify!(_CFG_CALL_TARGET_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_CFG_CALL_TARGET_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(_CFG_CALL_TARGET_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CFG_CALL_TARGET_INFO),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CFG_CALL_TARGET_INFO),
            "::",
            stringify!(Flags)
        )
    );
}
pub type CFG_CALL_TARGET_INFO = _CFG_CALL_TARGET_INFO;
pub type PCFG_CALL_TARGET_INFO = *mut _CFG_CALL_TARGET_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEM_ADDRESS_REQUIREMENTS {
    pub LowestStartingAddress: PVOID,
    pub HighestEndingAddress: PVOID,
    pub Alignment: SIZE_T,
}
#[test]
fn bindgen_test_layout__MEM_ADDRESS_REQUIREMENTS() {
    const UNINIT: ::std::mem::MaybeUninit<_MEM_ADDRESS_REQUIREMENTS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_MEM_ADDRESS_REQUIREMENTS>(),
        24usize,
        concat!("Size of: ", stringify!(_MEM_ADDRESS_REQUIREMENTS))
    );
    assert_eq!(
        ::std::mem::align_of::<_MEM_ADDRESS_REQUIREMENTS>(),
        8usize,
        concat!("Alignment of ", stringify!(_MEM_ADDRESS_REQUIREMENTS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LowestStartingAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEM_ADDRESS_REQUIREMENTS),
            "::",
            stringify!(LowestStartingAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighestEndingAddress) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEM_ADDRESS_REQUIREMENTS),
            "::",
            stringify!(HighestEndingAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Alignment) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEM_ADDRESS_REQUIREMENTS),
            "::",
            stringify!(Alignment)
        )
    );
}
pub type MEM_ADDRESS_REQUIREMENTS = _MEM_ADDRESS_REQUIREMENTS;
pub type PMEM_ADDRESS_REQUIREMENTS = *mut _MEM_ADDRESS_REQUIREMENTS;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterInvalidType: MEM_EXTENDED_PARAMETER_TYPE =
    0;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterAddressRequirements:
    MEM_EXTENDED_PARAMETER_TYPE = 1;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterNumaNode: MEM_EXTENDED_PARAMETER_TYPE = 2;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterPartitionHandle:
    MEM_EXTENDED_PARAMETER_TYPE = 3;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterUserPhysicalHandle:
    MEM_EXTENDED_PARAMETER_TYPE = 4;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterAttributeFlags:
    MEM_EXTENDED_PARAMETER_TYPE = 5;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterImageMachine:
    MEM_EXTENDED_PARAMETER_TYPE = 6;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterMax: MEM_EXTENDED_PARAMETER_TYPE = 7;
pub type MEM_EXTENDED_PARAMETER_TYPE = ::std::os::raw::c_uint;
pub type PMEM_EXTENDED_PARAMETER_TYPE = *mut MEM_EXTENDED_PARAMETER_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MEM_EXTENDED_PARAMETER {
    pub __bindgen_anon_1: MEM_EXTENDED_PARAMETER__bindgen_ty_1,
    pub __bindgen_anon_2: MEM_EXTENDED_PARAMETER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEM_EXTENDED_PARAMETER__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_MEM_EXTENDED_PARAMETER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MEM_EXTENDED_PARAMETER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(MEM_EXTENDED_PARAMETER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MEM_EXTENDED_PARAMETER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MEM_EXTENDED_PARAMETER__bindgen_ty_1)
        )
    );
}
impl MEM_EXTENDED_PARAMETER__bindgen_ty_1 {
    #[inline]
    pub fn Type(&self) -> DWORD64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: DWORD64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> DWORD64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: DWORD64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Type: DWORD64, Reserved: DWORD64) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Type: u64 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 56u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MEM_EXTENDED_PARAMETER__bindgen_ty_2 {
    pub ULong64: DWORD64,
    pub Pointer: PVOID,
    pub Size: SIZE_T,
    pub Handle: HANDLE,
    pub ULong: DWORD,
}
#[test]
fn bindgen_test_layout_MEM_EXTENDED_PARAMETER__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<MEM_EXTENDED_PARAMETER__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MEM_EXTENDED_PARAMETER__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(MEM_EXTENDED_PARAMETER__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MEM_EXTENDED_PARAMETER__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MEM_EXTENDED_PARAMETER__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ULong64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEM_EXTENDED_PARAMETER__bindgen_ty_2),
            "::",
            stringify!(ULong64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEM_EXTENDED_PARAMETER__bindgen_ty_2),
            "::",
            stringify!(Pointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEM_EXTENDED_PARAMETER__bindgen_ty_2),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEM_EXTENDED_PARAMETER__bindgen_ty_2),
            "::",
            stringify!(Handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ULong) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEM_EXTENDED_PARAMETER__bindgen_ty_2),
            "::",
            stringify!(ULong)
        )
    );
}
#[test]
fn bindgen_test_layout_MEM_EXTENDED_PARAMETER() {
    assert_eq!(
        ::std::mem::size_of::<MEM_EXTENDED_PARAMETER>(),
        16usize,
        concat!("Size of: ", stringify!(MEM_EXTENDED_PARAMETER))
    );
    assert_eq!(
        ::std::mem::align_of::<MEM_EXTENDED_PARAMETER>(),
        8usize,
        concat!("Alignment of ", stringify!(MEM_EXTENDED_PARAMETER))
    );
}
pub type PMEM_EXTENDED_PARAMETER = *mut MEM_EXTENDED_PARAMETER;
pub const _MEM_DEDICATED_ATTRIBUTE_TYPE_MemDedicatedAttributeReadBandwidth:
    _MEM_DEDICATED_ATTRIBUTE_TYPE = 0;
pub const _MEM_DEDICATED_ATTRIBUTE_TYPE_MemDedicatedAttributeReadLatency:
    _MEM_DEDICATED_ATTRIBUTE_TYPE = 1;
pub const _MEM_DEDICATED_ATTRIBUTE_TYPE_MemDedicatedAttributeWriteBandwidth:
    _MEM_DEDICATED_ATTRIBUTE_TYPE = 2;
pub const _MEM_DEDICATED_ATTRIBUTE_TYPE_MemDedicatedAttributeWriteLatency:
    _MEM_DEDICATED_ATTRIBUTE_TYPE = 3;
pub const _MEM_DEDICATED_ATTRIBUTE_TYPE_MemDedicatedAttributeMax: _MEM_DEDICATED_ATTRIBUTE_TYPE = 4;
pub type _MEM_DEDICATED_ATTRIBUTE_TYPE = ::std::os::raw::c_uint;
pub use self::_MEM_DEDICATED_ATTRIBUTE_TYPE as MEM_DEDICATED_ATTRIBUTE_TYPE;
pub type PMEM_DEDICATED_ATTRIBUTE_TYPE = *mut _MEM_DEDICATED_ATTRIBUTE_TYPE;
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE_MemSectionExtendedParameterInvalidType:
    MEM_SECTION_EXTENDED_PARAMETER_TYPE = 0;
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE_MemSectionExtendedParameterUserPhysicalFlags:
    MEM_SECTION_EXTENDED_PARAMETER_TYPE = 1;
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE_MemSectionExtendedParameterNumaNode:
    MEM_SECTION_EXTENDED_PARAMETER_TYPE = 2;
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE_MemSectionExtendedParameterSigningLevel:
    MEM_SECTION_EXTENDED_PARAMETER_TYPE = 3;
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE_MemSectionExtendedParameterMax:
    MEM_SECTION_EXTENDED_PARAMETER_TYPE = 4;
pub type MEM_SECTION_EXTENDED_PARAMETER_TYPE = ::std::os::raw::c_uint;
pub type PMEM_SECTION_EXTENDED_PARAMETER_TYPE = *mut MEM_SECTION_EXTENDED_PARAMETER_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCLAVE_CREATE_INFO_SGX {
    pub Secs: [BYTE; 4096usize],
}
#[test]
fn bindgen_test_layout__ENCLAVE_CREATE_INFO_SGX() {
    const UNINIT: ::std::mem::MaybeUninit<_ENCLAVE_CREATE_INFO_SGX> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ENCLAVE_CREATE_INFO_SGX>(),
        4096usize,
        concat!("Size of: ", stringify!(_ENCLAVE_CREATE_INFO_SGX))
    );
    assert_eq!(
        ::std::mem::align_of::<_ENCLAVE_CREATE_INFO_SGX>(),
        1usize,
        concat!("Alignment of ", stringify!(_ENCLAVE_CREATE_INFO_SGX))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Secs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_CREATE_INFO_SGX),
            "::",
            stringify!(Secs)
        )
    );
}
pub type ENCLAVE_CREATE_INFO_SGX = _ENCLAVE_CREATE_INFO_SGX;
pub type PENCLAVE_CREATE_INFO_SGX = *mut _ENCLAVE_CREATE_INFO_SGX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCLAVE_INIT_INFO_SGX {
    pub SigStruct: [BYTE; 1808usize],
    pub Reserved1: [BYTE; 240usize],
    pub EInitToken: [BYTE; 304usize],
    pub Reserved2: [BYTE; 1744usize],
}
#[test]
fn bindgen_test_layout__ENCLAVE_INIT_INFO_SGX() {
    const UNINIT: ::std::mem::MaybeUninit<_ENCLAVE_INIT_INFO_SGX> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ENCLAVE_INIT_INFO_SGX>(),
        4096usize,
        concat!("Size of: ", stringify!(_ENCLAVE_INIT_INFO_SGX))
    );
    assert_eq!(
        ::std::mem::align_of::<_ENCLAVE_INIT_INFO_SGX>(),
        1usize,
        concat!("Alignment of ", stringify!(_ENCLAVE_INIT_INFO_SGX))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SigStruct) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_INIT_INFO_SGX),
            "::",
            stringify!(SigStruct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        1808usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_INIT_INFO_SGX),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EInitToken) as usize - ptr as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_INIT_INFO_SGX),
            "::",
            stringify!(EInitToken)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        2352usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_INIT_INFO_SGX),
            "::",
            stringify!(Reserved2)
        )
    );
}
pub type ENCLAVE_INIT_INFO_SGX = _ENCLAVE_INIT_INFO_SGX;
pub type PENCLAVE_INIT_INFO_SGX = *mut _ENCLAVE_INIT_INFO_SGX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCLAVE_CREATE_INFO_VBS {
    pub Flags: DWORD,
    pub OwnerID: [BYTE; 32usize],
}
#[test]
fn bindgen_test_layout__ENCLAVE_CREATE_INFO_VBS() {
    const UNINIT: ::std::mem::MaybeUninit<_ENCLAVE_CREATE_INFO_VBS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ENCLAVE_CREATE_INFO_VBS>(),
        36usize,
        concat!("Size of: ", stringify!(_ENCLAVE_CREATE_INFO_VBS))
    );
    assert_eq!(
        ::std::mem::align_of::<_ENCLAVE_CREATE_INFO_VBS>(),
        4usize,
        concat!("Alignment of ", stringify!(_ENCLAVE_CREATE_INFO_VBS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_CREATE_INFO_VBS),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OwnerID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_CREATE_INFO_VBS),
            "::",
            stringify!(OwnerID)
        )
    );
}
pub type ENCLAVE_CREATE_INFO_VBS = _ENCLAVE_CREATE_INFO_VBS;
pub type PENCLAVE_CREATE_INFO_VBS = *mut _ENCLAVE_CREATE_INFO_VBS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCLAVE_CREATE_INFO_VBS_BASIC {
    pub Flags: DWORD,
    pub OwnerID: [BYTE; 32usize],
}
#[test]
fn bindgen_test_layout__ENCLAVE_CREATE_INFO_VBS_BASIC() {
    const UNINIT: ::std::mem::MaybeUninit<_ENCLAVE_CREATE_INFO_VBS_BASIC> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ENCLAVE_CREATE_INFO_VBS_BASIC>(),
        36usize,
        concat!("Size of: ", stringify!(_ENCLAVE_CREATE_INFO_VBS_BASIC))
    );
    assert_eq!(
        ::std::mem::align_of::<_ENCLAVE_CREATE_INFO_VBS_BASIC>(),
        4usize,
        concat!("Alignment of ", stringify!(_ENCLAVE_CREATE_INFO_VBS_BASIC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_CREATE_INFO_VBS_BASIC),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OwnerID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_CREATE_INFO_VBS_BASIC),
            "::",
            stringify!(OwnerID)
        )
    );
}
pub type ENCLAVE_CREATE_INFO_VBS_BASIC = _ENCLAVE_CREATE_INFO_VBS_BASIC;
pub type PENCLAVE_CREATE_INFO_VBS_BASIC = *mut _ENCLAVE_CREATE_INFO_VBS_BASIC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCLAVE_LOAD_DATA_VBS_BASIC {
    pub PageType: DWORD,
}
#[test]
fn bindgen_test_layout__ENCLAVE_LOAD_DATA_VBS_BASIC() {
    const UNINIT: ::std::mem::MaybeUninit<_ENCLAVE_LOAD_DATA_VBS_BASIC> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ENCLAVE_LOAD_DATA_VBS_BASIC>(),
        4usize,
        concat!("Size of: ", stringify!(_ENCLAVE_LOAD_DATA_VBS_BASIC))
    );
    assert_eq!(
        ::std::mem::align_of::<_ENCLAVE_LOAD_DATA_VBS_BASIC>(),
        4usize,
        concat!("Alignment of ", stringify!(_ENCLAVE_LOAD_DATA_VBS_BASIC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PageType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_LOAD_DATA_VBS_BASIC),
            "::",
            stringify!(PageType)
        )
    );
}
pub type ENCLAVE_LOAD_DATA_VBS_BASIC = _ENCLAVE_LOAD_DATA_VBS_BASIC;
pub type PENCLAVE_LOAD_DATA_VBS_BASIC = *mut _ENCLAVE_LOAD_DATA_VBS_BASIC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ENCLAVE_INIT_INFO_VBS_BASIC {
    pub FamilyId: [BYTE; 16usize],
    pub ImageId: [BYTE; 16usize],
    pub EnclaveSize: ULONGLONG,
    pub EnclaveSvn: DWORD,
    pub Reserved: DWORD,
    pub __bindgen_anon_1: _ENCLAVE_INIT_INFO_VBS_BASIC__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ENCLAVE_INIT_INFO_VBS_BASIC__bindgen_ty_1 {
    pub SignatureInfoHandle: HANDLE,
    pub Unused: ULONGLONG,
}
#[test]
fn bindgen_test_layout__ENCLAVE_INIT_INFO_VBS_BASIC__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_ENCLAVE_INIT_INFO_VBS_BASIC__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ENCLAVE_INIT_INFO_VBS_BASIC__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_ENCLAVE_INIT_INFO_VBS_BASIC__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ENCLAVE_INIT_INFO_VBS_BASIC__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ENCLAVE_INIT_INFO_VBS_BASIC__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SignatureInfoHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_INIT_INFO_VBS_BASIC__bindgen_ty_1),
            "::",
            stringify!(SignatureInfoHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_INIT_INFO_VBS_BASIC__bindgen_ty_1),
            "::",
            stringify!(Unused)
        )
    );
}
#[test]
fn bindgen_test_layout__ENCLAVE_INIT_INFO_VBS_BASIC() {
    const UNINIT: ::std::mem::MaybeUninit<_ENCLAVE_INIT_INFO_VBS_BASIC> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ENCLAVE_INIT_INFO_VBS_BASIC>(),
        56usize,
        concat!("Size of: ", stringify!(_ENCLAVE_INIT_INFO_VBS_BASIC))
    );
    assert_eq!(
        ::std::mem::align_of::<_ENCLAVE_INIT_INFO_VBS_BASIC>(),
        8usize,
        concat!("Alignment of ", stringify!(_ENCLAVE_INIT_INFO_VBS_BASIC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FamilyId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_INIT_INFO_VBS_BASIC),
            "::",
            stringify!(FamilyId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ImageId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_INIT_INFO_VBS_BASIC),
            "::",
            stringify!(ImageId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnclaveSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_INIT_INFO_VBS_BASIC),
            "::",
            stringify!(EnclaveSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnclaveSvn) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_INIT_INFO_VBS_BASIC),
            "::",
            stringify!(EnclaveSvn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_INIT_INFO_VBS_BASIC),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type ENCLAVE_INIT_INFO_VBS_BASIC = _ENCLAVE_INIT_INFO_VBS_BASIC;
pub type PENCLAVE_INIT_INFO_VBS_BASIC = *mut _ENCLAVE_INIT_INFO_VBS_BASIC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCLAVE_INIT_INFO_VBS {
    pub Length: DWORD,
    pub ThreadCount: DWORD,
}
#[test]
fn bindgen_test_layout__ENCLAVE_INIT_INFO_VBS() {
    const UNINIT: ::std::mem::MaybeUninit<_ENCLAVE_INIT_INFO_VBS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ENCLAVE_INIT_INFO_VBS>(),
        8usize,
        concat!("Size of: ", stringify!(_ENCLAVE_INIT_INFO_VBS))
    );
    assert_eq!(
        ::std::mem::align_of::<_ENCLAVE_INIT_INFO_VBS>(),
        4usize,
        concat!("Alignment of ", stringify!(_ENCLAVE_INIT_INFO_VBS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_INIT_INFO_VBS),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ThreadCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_INIT_INFO_VBS),
            "::",
            stringify!(ThreadCount)
        )
    );
}
pub type ENCLAVE_INIT_INFO_VBS = _ENCLAVE_INIT_INFO_VBS;
pub type PENCLAVE_INIT_INFO_VBS = *mut _ENCLAVE_INIT_INFO_VBS;
pub type ENCLAVE_TARGET_FUNCTION =
    ::std::option::Option<unsafe extern "C" fn(arg1: PVOID) -> PVOID>;
pub type PENCLAVE_TARGET_FUNCTION = ENCLAVE_TARGET_FUNCTION;
pub type LPENCLAVE_TARGET_FUNCTION = PENCLAVE_TARGET_FUNCTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE {
    pub Type: MEM_DEDICATED_ATTRIBUTE_TYPE,
    pub Reserved: DWORD,
    pub Value: DWORD64,
}
#[test]
fn bindgen_test_layout__MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE() {
    const UNINIT: ::std::mem::MaybeUninit<_MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE),
            "::",
            stringify!(Value)
        )
    );
}
pub type MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE = _MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE;
pub type PMEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE =
    *mut _MEMORY_PARTITION_DEDICATED_MEMORY_ATTRIBUTE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION {
    pub NextEntryOffset: DWORD,
    pub SizeOfInformation: DWORD,
    pub Flags: DWORD,
    pub AttributesOffset: DWORD,
    pub AttributeCount: DWORD,
    pub Reserved: DWORD,
    pub TypeId: DWORD64,
}
#[test]
fn bindgen_test_layout__MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfInformation) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION),
            "::",
            stringify!(SizeOfInformation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AttributesOffset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION),
            "::",
            stringify!(AttributesOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AttributeCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION),
            "::",
            stringify!(AttributeCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TypeId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION),
            "::",
            stringify!(TypeId)
        )
    );
}
pub type MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION =
    _MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION;
pub type PMEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION =
    *mut _MEMORY_PARTITION_DEDICATED_MEMORY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ID_128 {
    pub Identifier: [BYTE; 16usize],
}
#[test]
fn bindgen_test_layout__FILE_ID_128() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_ID_128> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_ID_128>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_ID_128))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_ID_128>(),
        1usize,
        concat!("Alignment of ", stringify!(_FILE_ID_128))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_128),
            "::",
            stringify!(Identifier)
        )
    );
}
pub type FILE_ID_128 = _FILE_ID_128;
pub type PFILE_ID_128 = *mut _FILE_ID_128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_NOTIFY_INFORMATION {
    pub NextEntryOffset: DWORD,
    pub Action: DWORD,
    pub FileNameLength: DWORD,
    pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_NOTIFY_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_NOTIFY_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_NOTIFY_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_NOTIFY_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_NOTIFY_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_NOTIFY_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Action) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_INFORMATION),
            "::",
            stringify!(Action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_NOTIFY_INFORMATION = _FILE_NOTIFY_INFORMATION;
pub type PFILE_NOTIFY_INFORMATION = *mut _FILE_NOTIFY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NOTIFY_EXTENDED_INFORMATION {
    pub NextEntryOffset: DWORD,
    pub Action: DWORD,
    pub CreationTime: LARGE_INTEGER,
    pub LastModificationTime: LARGE_INTEGER,
    pub LastChangeTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub AllocatedLength: LARGE_INTEGER,
    pub FileSize: LARGE_INTEGER,
    pub FileAttributes: DWORD,
    pub __bindgen_anon_1: _FILE_NOTIFY_EXTENDED_INFORMATION__bindgen_ty_1,
    pub FileId: LARGE_INTEGER,
    pub ParentFileId: LARGE_INTEGER,
    pub FileNameLength: DWORD,
    pub FileName: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_NOTIFY_EXTENDED_INFORMATION__bindgen_ty_1 {
    pub ReparsePointTag: DWORD,
    pub EaSize: DWORD,
}
#[test]
fn bindgen_test_layout__FILE_NOTIFY_EXTENDED_INFORMATION__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_NOTIFY_EXTENDED_INFORMATION__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_NOTIFY_EXTENDED_INFORMATION__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_NOTIFY_EXTENDED_INFORMATION__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReparsePointTag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(ReparsePointTag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EaSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(EaSize)
        )
    );
}
#[test]
fn bindgen_test_layout__FILE_NOTIFY_EXTENDED_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_NOTIFY_EXTENDED_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_NOTIFY_EXTENDED_INFORMATION>(),
        88usize,
        concat!("Size of: ", stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_NOTIFY_EXTENDED_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Action) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(Action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastModificationTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(LastModificationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastChangeTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(LastChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocatedLength) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(AllocatedLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(FileSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileId) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(FileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParentFileId) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(ParentFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_NOTIFY_EXTENDED_INFORMATION = _FILE_NOTIFY_EXTENDED_INFORMATION;
pub type PFILE_NOTIFY_EXTENDED_INFORMATION = *mut _FILE_NOTIFY_EXTENDED_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NOTIFY_FULL_INFORMATION {
    pub NextEntryOffset: DWORD,
    pub Action: DWORD,
    pub CreationTime: LARGE_INTEGER,
    pub LastModificationTime: LARGE_INTEGER,
    pub LastChangeTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub AllocatedLength: LARGE_INTEGER,
    pub FileSize: LARGE_INTEGER,
    pub FileAttributes: DWORD,
    pub __bindgen_anon_1: _FILE_NOTIFY_FULL_INFORMATION__bindgen_ty_1,
    pub FileId: LARGE_INTEGER,
    pub ParentFileId: LARGE_INTEGER,
    pub FileNameLength: WORD,
    pub FileNameFlags: BYTE,
    pub Reserved: BYTE,
    pub FileName: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_NOTIFY_FULL_INFORMATION__bindgen_ty_1 {
    pub ReparsePointTag: DWORD,
    pub EaSize: DWORD,
}
#[test]
fn bindgen_test_layout__FILE_NOTIFY_FULL_INFORMATION__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_NOTIFY_FULL_INFORMATION__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_NOTIFY_FULL_INFORMATION__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_FILE_NOTIFY_FULL_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_NOTIFY_FULL_INFORMATION__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_FILE_NOTIFY_FULL_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReparsePointTag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_FULL_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(ReparsePointTag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EaSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_FULL_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(EaSize)
        )
    );
}
#[test]
fn bindgen_test_layout__FILE_NOTIFY_FULL_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_NOTIFY_FULL_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_NOTIFY_FULL_INFORMATION>(),
        88usize,
        concat!("Size of: ", stringify!(_FILE_NOTIFY_FULL_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_NOTIFY_FULL_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_NOTIFY_FULL_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_FULL_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Action) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_FULL_INFORMATION),
            "::",
            stringify!(Action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_FULL_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastModificationTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_FULL_INFORMATION),
            "::",
            stringify!(LastModificationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastChangeTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_FULL_INFORMATION),
            "::",
            stringify!(LastChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_FULL_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocatedLength) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_FULL_INFORMATION),
            "::",
            stringify!(AllocatedLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_FULL_INFORMATION),
            "::",
            stringify!(FileSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_FULL_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileId) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_FULL_INFORMATION),
            "::",
            stringify!(FileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParentFileId) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_FULL_INFORMATION),
            "::",
            stringify!(ParentFileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_FULL_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileNameFlags) as usize - ptr as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_FULL_INFORMATION),
            "::",
            stringify!(FileNameFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        83usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_FULL_INFORMATION),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_FULL_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_NOTIFY_FULL_INFORMATION = _FILE_NOTIFY_FULL_INFORMATION;
pub type PFILE_NOTIFY_FULL_INFORMATION = *mut _FILE_NOTIFY_FULL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_SEGMENT_ELEMENT {
    pub Buffer: PVOID64,
    pub Alignment: ULONGLONG,
}
#[test]
fn bindgen_test_layout__FILE_SEGMENT_ELEMENT() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_SEGMENT_ELEMENT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_SEGMENT_ELEMENT>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_SEGMENT_ELEMENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_SEGMENT_ELEMENT>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_SEGMENT_ELEMENT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_SEGMENT_ELEMENT),
            "::",
            stringify!(Buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Alignment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_SEGMENT_ELEMENT),
            "::",
            stringify!(Alignment)
        )
    );
}
pub type FILE_SEGMENT_ELEMENT = _FILE_SEGMENT_ELEMENT;
pub type PFILE_SEGMENT_ELEMENT = *mut _FILE_SEGMENT_ELEMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REPARSE_GUID_DATA_BUFFER {
    pub ReparseTag: DWORD,
    pub ReparseDataLength: WORD,
    pub Reserved: WORD,
    pub ReparseGuid: GUID,
    pub GenericReparseBuffer: _REPARSE_GUID_DATA_BUFFER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REPARSE_GUID_DATA_BUFFER__bindgen_ty_1 {
    pub DataBuffer: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__REPARSE_GUID_DATA_BUFFER__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_REPARSE_GUID_DATA_BUFFER__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_REPARSE_GUID_DATA_BUFFER__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_REPARSE_GUID_DATA_BUFFER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_REPARSE_GUID_DATA_BUFFER__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_REPARSE_GUID_DATA_BUFFER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_REPARSE_GUID_DATA_BUFFER__bindgen_ty_1),
            "::",
            stringify!(DataBuffer)
        )
    );
}
#[test]
fn bindgen_test_layout__REPARSE_GUID_DATA_BUFFER() {
    const UNINIT: ::std::mem::MaybeUninit<_REPARSE_GUID_DATA_BUFFER> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_REPARSE_GUID_DATA_BUFFER>(),
        28usize,
        concat!("Size of: ", stringify!(_REPARSE_GUID_DATA_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<_REPARSE_GUID_DATA_BUFFER>(),
        4usize,
        concat!("Alignment of ", stringify!(_REPARSE_GUID_DATA_BUFFER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReparseTag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_REPARSE_GUID_DATA_BUFFER),
            "::",
            stringify!(ReparseTag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReparseDataLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_REPARSE_GUID_DATA_BUFFER),
            "::",
            stringify!(ReparseDataLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_REPARSE_GUID_DATA_BUFFER),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReparseGuid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_REPARSE_GUID_DATA_BUFFER),
            "::",
            stringify!(ReparseGuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GenericReparseBuffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_REPARSE_GUID_DATA_BUFFER),
            "::",
            stringify!(GenericReparseBuffer)
        )
    );
}
pub type REPARSE_GUID_DATA_BUFFER = _REPARSE_GUID_DATA_BUFFER;
pub type PREPARSE_GUID_DATA_BUFFER = *mut _REPARSE_GUID_DATA_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCRUB_DATA_INPUT {
    pub Size: DWORD,
    pub Flags: DWORD,
    pub MaximumIos: DWORD,
    pub ObjectId: [DWORD; 4usize],
    pub Reserved: [DWORD; 41usize],
    pub ResumeContext: [BYTE; 1040usize],
}
#[test]
fn bindgen_test_layout__SCRUB_DATA_INPUT() {
    const UNINIT: ::std::mem::MaybeUninit<_SCRUB_DATA_INPUT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SCRUB_DATA_INPUT>(),
        1232usize,
        concat!("Size of: ", stringify!(_SCRUB_DATA_INPUT))
    );
    assert_eq!(
        ::std::mem::align_of::<_SCRUB_DATA_INPUT>(),
        4usize,
        concat!("Alignment of ", stringify!(_SCRUB_DATA_INPUT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_INPUT),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_INPUT),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumIos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_INPUT),
            "::",
            stringify!(MaximumIos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectId) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_INPUT),
            "::",
            stringify!(ObjectId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_INPUT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResumeContext) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_INPUT),
            "::",
            stringify!(ResumeContext)
        )
    );
}
pub type SCRUB_DATA_INPUT = _SCRUB_DATA_INPUT;
pub type PSCRUB_DATA_INPUT = *mut _SCRUB_DATA_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCRUB_PARITY_EXTENT {
    pub Offset: LONGLONG,
    pub Length: ULONGLONG,
}
#[test]
fn bindgen_test_layout__SCRUB_PARITY_EXTENT() {
    const UNINIT: ::std::mem::MaybeUninit<_SCRUB_PARITY_EXTENT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SCRUB_PARITY_EXTENT>(),
        16usize,
        concat!("Size of: ", stringify!(_SCRUB_PARITY_EXTENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_SCRUB_PARITY_EXTENT>(),
        8usize,
        concat!("Alignment of ", stringify!(_SCRUB_PARITY_EXTENT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_PARITY_EXTENT),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_PARITY_EXTENT),
            "::",
            stringify!(Length)
        )
    );
}
pub type SCRUB_PARITY_EXTENT = _SCRUB_PARITY_EXTENT;
pub type PSCRUB_PARITY_EXTENT = *mut _SCRUB_PARITY_EXTENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCRUB_PARITY_EXTENT_DATA {
    pub Size: WORD,
    pub Flags: WORD,
    pub NumberOfParityExtents: WORD,
    pub MaximumNumberOfParityExtents: WORD,
    pub ParityExtents: [SCRUB_PARITY_EXTENT; 1usize],
}
#[test]
fn bindgen_test_layout__SCRUB_PARITY_EXTENT_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<_SCRUB_PARITY_EXTENT_DATA> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SCRUB_PARITY_EXTENT_DATA>(),
        24usize,
        concat!("Size of: ", stringify!(_SCRUB_PARITY_EXTENT_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_SCRUB_PARITY_EXTENT_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(_SCRUB_PARITY_EXTENT_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_PARITY_EXTENT_DATA),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_PARITY_EXTENT_DATA),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfParityExtents) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_PARITY_EXTENT_DATA),
            "::",
            stringify!(NumberOfParityExtents)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).MaximumNumberOfParityExtents) as usize - ptr as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_PARITY_EXTENT_DATA),
            "::",
            stringify!(MaximumNumberOfParityExtents)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParityExtents) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_PARITY_EXTENT_DATA),
            "::",
            stringify!(ParityExtents)
        )
    );
}
pub type SCRUB_PARITY_EXTENT_DATA = _SCRUB_PARITY_EXTENT_DATA;
pub type PSCRUB_PARITY_EXTENT_DATA = *mut _SCRUB_PARITY_EXTENT_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCRUB_DATA_OUTPUT {
    pub Size: DWORD,
    pub Flags: DWORD,
    pub Status: DWORD,
    pub ErrorFileOffset: ULONGLONG,
    pub ErrorLength: ULONGLONG,
    pub NumberOfBytesRepaired: ULONGLONG,
    pub NumberOfBytesFailed: ULONGLONG,
    pub InternalFileReference: ULONGLONG,
    pub ResumeContextLength: WORD,
    pub ParityExtentDataOffset: WORD,
    pub Reserved: [DWORD; 9usize],
    pub NumberOfMetadataBytesProcessed: ULONGLONG,
    pub NumberOfDataBytesProcessed: ULONGLONG,
    pub TotalNumberOfMetadataBytesInUse: ULONGLONG,
    pub TotalNumberOfDataBytesInUse: ULONGLONG,
    pub DataBytesSkippedDueToNoAllocation: ULONGLONG,
    pub DataBytesSkippedDueToInvalidRun: ULONGLONG,
    pub DataBytesSkippedDueToIntegrityStream: ULONGLONG,
    pub DataBytesSkippedDueToRegionBeingClean: ULONGLONG,
    pub DataBytesSkippedDueToLockConflict: ULONGLONG,
    pub DataBytesSkippedDueToNoScrubDataFlag: ULONGLONG,
    pub DataBytesSkippedDueToNoScrubNonIntegrityStreamFlag: ULONGLONG,
    pub DataBytesScrubbed: ULONGLONG,
    pub ResumeContext: [BYTE; 1040usize],
}
#[test]
fn bindgen_test_layout__SCRUB_DATA_OUTPUT() {
    const UNINIT: ::std::mem::MaybeUninit<_SCRUB_DATA_OUTPUT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SCRUB_DATA_OUTPUT>(),
        1232usize,
        concat!("Size of: ", stringify!(_SCRUB_DATA_OUTPUT))
    );
    assert_eq!(
        ::std::mem::align_of::<_SCRUB_DATA_OUTPUT>(),
        8usize,
        concat!("Alignment of ", stringify!(_SCRUB_DATA_OUTPUT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ErrorFileOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(ErrorFileOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ErrorLength) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(ErrorLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfBytesRepaired) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(NumberOfBytesRepaired)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfBytesFailed) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(NumberOfBytesFailed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InternalFileReference) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(InternalFileReference)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResumeContextLength) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(ResumeContextLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ParityExtentDataOffset) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(ParityExtentDataOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).NumberOfMetadataBytesProcessed) as usize - ptr as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(NumberOfMetadataBytesProcessed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfDataBytesProcessed) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(NumberOfDataBytesProcessed)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).TotalNumberOfMetadataBytesInUse) as usize - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(TotalNumberOfMetadataBytesInUse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalNumberOfDataBytesInUse) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(TotalNumberOfDataBytesInUse)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).DataBytesSkippedDueToNoAllocation) as usize - ptr as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(DataBytesSkippedDueToNoAllocation)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).DataBytesSkippedDueToInvalidRun) as usize - ptr as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(DataBytesSkippedDueToInvalidRun)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).DataBytesSkippedDueToIntegrityStream) as usize
                - ptr as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(DataBytesSkippedDueToIntegrityStream)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).DataBytesSkippedDueToRegionBeingClean) as usize
                - ptr as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(DataBytesSkippedDueToRegionBeingClean)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).DataBytesSkippedDueToLockConflict) as usize - ptr as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(DataBytesSkippedDueToLockConflict)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).DataBytesSkippedDueToNoScrubDataFlag) as usize
                - ptr as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(DataBytesSkippedDueToNoScrubDataFlag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).DataBytesSkippedDueToNoScrubNonIntegrityStreamFlag) as usize
                - ptr as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(DataBytesSkippedDueToNoScrubNonIntegrityStreamFlag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataBytesScrubbed) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(DataBytesScrubbed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResumeContext) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(ResumeContext)
        )
    );
}
pub type SCRUB_DATA_OUTPUT = _SCRUB_DATA_OUTPUT;
pub type PSCRUB_DATA_OUTPUT = *mut _SCRUB_DATA_OUTPUT;
extern "C" {
    pub static GUID_MAX_POWER_SAVINGS: GUID;
}
extern "C" {
    pub static GUID_MIN_POWER_SAVINGS: GUID;
}
extern "C" {
    pub static GUID_TYPICAL_POWER_SAVINGS: GUID;
}
extern "C" {
    pub static NO_SUBGROUP_GUID: GUID;
}
extern "C" {
    pub static ALL_POWERSCHEMES_GUID: GUID;
}
extern "C" {
    pub static GUID_POWERSCHEME_PERSONALITY: GUID;
}
extern "C" {
    pub static GUID_ACTIVE_POWERSCHEME: GUID;
}
extern "C" {
    pub static GUID_IDLE_RESILIENCY_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_IDLE_RESILIENCY_PERIOD: GUID;
}
extern "C" {
    pub static GUID_DISK_COALESCING_POWERDOWN_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_VIDEO_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_VIDEO_POWERDOWN_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_VIDEO_ANNOYANCE_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE: GUID;
}
extern "C" {
    pub static GUID_VIDEO_DIM_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_VIDEO_ADAPTIVE_POWERDOWN: GUID;
}
extern "C" {
    pub static GUID_MONITOR_POWER_ON: GUID;
}
extern "C" {
    pub static GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS: GUID;
}
extern "C" {
    pub static GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS: GUID;
}
extern "C" {
    pub static GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS: GUID;
}
extern "C" {
    pub static GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS: GUID;
}
extern "C" {
    pub static GUID_CONSOLE_DISPLAY_STATE: GUID;
}
extern "C" {
    pub static GUID_ALLOW_DISPLAY_REQUIRED: GUID;
}
extern "C" {
    pub static GUID_VIDEO_CONSOLE_LOCK_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_NON_ADAPTIVE_INPUT_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_DISK_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_DISK_POWERDOWN_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_DISK_IDLE_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_DISK_BURST_IGNORE_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_DISK_ADAPTIVE_POWERDOWN: GUID;
}
extern "C" {
    pub static GUID_SLEEP_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_SLEEP_IDLE_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_STANDBY_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_UNATTEND_SLEEP_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_HIBERNATE_TIMEOUT: GUID;
}
extern "C" {
    pub static GUID_HIBERNATE_FASTS4_POLICY: GUID;
}
extern "C" {
    pub static GUID_CRITICAL_POWER_TRANSITION: GUID;
}
extern "C" {
    pub static GUID_SYSTEM_AWAYMODE: GUID;
}
extern "C" {
    pub static GUID_ALLOW_AWAYMODE: GUID;
}
extern "C" {
    pub static GUID_ALLOW_STANDBY_STATES: GUID;
}
extern "C" {
    pub static GUID_ALLOW_RTC_WAKE: GUID;
}
extern "C" {
    pub static GUID_ALLOW_SYSTEM_REQUIRED: GUID;
}
extern "C" {
    pub static GUID_SYSTEM_BUTTON_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_POWERBUTTON_ACTION: GUID;
}
extern "C" {
    pub static GUID_SLEEPBUTTON_ACTION: GUID;
}
extern "C" {
    pub static GUID_USERINTERFACEBUTTON_ACTION: GUID;
}
extern "C" {
    pub static GUID_LIDCLOSE_ACTION: GUID;
}
extern "C" {
    pub static GUID_LIDOPEN_POWERSTATE: GUID;
}
extern "C" {
    pub static GUID_BATTERY_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_ACTION_0: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_LEVEL_0: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_FLAGS_0: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_ACTION_1: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_LEVEL_1: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_FLAGS_1: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_ACTION_2: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_LEVEL_2: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_FLAGS_2: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_ACTION_3: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_LEVEL_3: GUID;
}
extern "C" {
    pub static GUID_BATTERY_DISCHARGE_FLAGS_3: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_SETTINGS_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_THROTTLE_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_THROTTLE_MAXIMUM: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_THROTTLE_MINIMUM: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_ALLOW_THROTTLING: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_IDLESTATE_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERFSTATE_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_INCREASE_TIME: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_DECREASE_TIME: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_TIME_CHECK: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_BOOST_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_BOOST_MODE: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_IDLE_ALLOW_SCALING: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_IDLE_DISABLE: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_IDLE_STATE_MAXIMUM: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_IDLE_TIME_CHECK: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_MAX_CORES: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_MIN_CORES: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PARKING_CORE_OVERRIDE: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PARKING_PERF_STATE: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_HISTORY: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_PERF_LATENCY_HINT: GUID;
}
extern "C" {
    pub static GUID_PROCESSOR_DISTRIBUTE_UTILITY: GUID;
}
extern "C" {
    pub static GUID_SYSTEM_COOLING_POLICY: GUID;
}
extern "C" {
    pub static GUID_LOCK_CONSOLE_ON_WAKE: GUID;
}
extern "C" {
    pub static GUID_DEVICE_IDLE_POLICY: GUID;
}
extern "C" {
    pub static GUID_ACDC_POWER_SOURCE: GUID;
}
extern "C" {
    pub static GUID_LIDSWITCH_STATE_CHANGE: GUID;
}
extern "C" {
    pub static GUID_BATTERY_PERCENTAGE_REMAINING: GUID;
}
extern "C" {
    pub static GUID_GLOBAL_USER_PRESENCE: GUID;
}
extern "C" {
    pub static GUID_SESSION_DISPLAY_STATUS: GUID;
}
extern "C" {
    pub static GUID_SESSION_USER_PRESENCE: GUID;
}
extern "C" {
    pub static GUID_IDLE_BACKGROUND_TASK: GUID;
}
extern "C" {
    pub static GUID_BACKGROUND_TASK_NOTIFICATION: GUID;
}
extern "C" {
    pub static GUID_APPLAUNCH_BUTTON: GUID;
}
extern "C" {
    pub static GUID_PCIEXPRESS_SETTINGS_SUBGROUP: GUID;
}
extern "C" {
    pub static GUID_PCIEXPRESS_ASPM_POLICY: GUID;
}
extern "C" {
    pub static GUID_ENABLE_SWITCH_FORCED_SHUTDOWN: GUID;
}
pub const _SYSTEM_POWER_STATE_PowerSystemUnspecified: _SYSTEM_POWER_STATE = 0;
pub const _SYSTEM_POWER_STATE_PowerSystemWorking: _SYSTEM_POWER_STATE = 1;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping1: _SYSTEM_POWER_STATE = 2;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping2: _SYSTEM_POWER_STATE = 3;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping3: _SYSTEM_POWER_STATE = 4;
pub const _SYSTEM_POWER_STATE_PowerSystemHibernate: _SYSTEM_POWER_STATE = 5;
pub const _SYSTEM_POWER_STATE_PowerSystemShutdown: _SYSTEM_POWER_STATE = 6;
pub const _SYSTEM_POWER_STATE_PowerSystemMaximum: _SYSTEM_POWER_STATE = 7;
pub type _SYSTEM_POWER_STATE = ::std::os::raw::c_uint;
pub use self::_SYSTEM_POWER_STATE as SYSTEM_POWER_STATE;
pub type PSYSTEM_POWER_STATE = *mut _SYSTEM_POWER_STATE;
pub const POWER_ACTION_PowerActionNone: POWER_ACTION = 0;
pub const POWER_ACTION_PowerActionReserved: POWER_ACTION = 1;
pub const POWER_ACTION_PowerActionSleep: POWER_ACTION = 2;
pub const POWER_ACTION_PowerActionHibernate: POWER_ACTION = 3;
pub const POWER_ACTION_PowerActionShutdown: POWER_ACTION = 4;
pub const POWER_ACTION_PowerActionShutdownReset: POWER_ACTION = 5;
pub const POWER_ACTION_PowerActionShutdownOff: POWER_ACTION = 6;
pub const POWER_ACTION_PowerActionWarmEject: POWER_ACTION = 7;
pub type POWER_ACTION = ::std::os::raw::c_uint;
pub type PPOWER_ACTION = *mut POWER_ACTION;
pub const _DEVICE_POWER_STATE_PowerDeviceUnspecified: _DEVICE_POWER_STATE = 0;
pub const _DEVICE_POWER_STATE_PowerDeviceD0: _DEVICE_POWER_STATE = 1;
pub const _DEVICE_POWER_STATE_PowerDeviceD1: _DEVICE_POWER_STATE = 2;
pub const _DEVICE_POWER_STATE_PowerDeviceD2: _DEVICE_POWER_STATE = 3;
pub const _DEVICE_POWER_STATE_PowerDeviceD3: _DEVICE_POWER_STATE = 4;
pub const _DEVICE_POWER_STATE_PowerDeviceMaximum: _DEVICE_POWER_STATE = 5;
pub type _DEVICE_POWER_STATE = ::std::os::raw::c_uint;
pub use self::_DEVICE_POWER_STATE as DEVICE_POWER_STATE;
pub type PDEVICE_POWER_STATE = *mut _DEVICE_POWER_STATE;
pub const _MONITOR_DISPLAY_STATE_PowerMonitorOff: _MONITOR_DISPLAY_STATE = 0;
pub const _MONITOR_DISPLAY_STATE_PowerMonitorOn: _MONITOR_DISPLAY_STATE = 1;
pub const _MONITOR_DISPLAY_STATE_PowerMonitorDim: _MONITOR_DISPLAY_STATE = 2;
pub type _MONITOR_DISPLAY_STATE = ::std::os::raw::c_uint;
pub use self::_MONITOR_DISPLAY_STATE as MONITOR_DISPLAY_STATE;
pub type PMONITOR_DISPLAY_STATE = *mut _MONITOR_DISPLAY_STATE;
pub const _USER_ACTIVITY_PRESENCE_PowerUserPresent: _USER_ACTIVITY_PRESENCE = 0;
pub const _USER_ACTIVITY_PRESENCE_PowerUserNotPresent: _USER_ACTIVITY_PRESENCE = 1;
pub const _USER_ACTIVITY_PRESENCE_PowerUserInactive: _USER_ACTIVITY_PRESENCE = 2;
pub const _USER_ACTIVITY_PRESENCE_PowerUserMaximum: _USER_ACTIVITY_PRESENCE = 3;
pub const _USER_ACTIVITY_PRESENCE_PowerUserInvalid: _USER_ACTIVITY_PRESENCE = 3;
pub type _USER_ACTIVITY_PRESENCE = ::std::os::raw::c_uint;
pub use self::_USER_ACTIVITY_PRESENCE as USER_ACTIVITY_PRESENCE;
pub type PUSER_ACTIVITY_PRESENCE = *mut _USER_ACTIVITY_PRESENCE;
pub type EXECUTION_STATE = DWORD;
pub type PEXECUTION_STATE = *mut DWORD;
pub const LATENCY_TIME_LT_DONT_CARE: LATENCY_TIME = 0;
pub const LATENCY_TIME_LT_LOWEST_LATENCY: LATENCY_TIME = 1;
pub type LATENCY_TIME = ::std::os::raw::c_uint;
pub const _POWER_REQUEST_TYPE_PowerRequestDisplayRequired: _POWER_REQUEST_TYPE = 0;
pub const _POWER_REQUEST_TYPE_PowerRequestSystemRequired: _POWER_REQUEST_TYPE = 1;
pub const _POWER_REQUEST_TYPE_PowerRequestAwayModeRequired: _POWER_REQUEST_TYPE = 2;
pub const _POWER_REQUEST_TYPE_PowerRequestExecutionRequired: _POWER_REQUEST_TYPE = 3;
pub type _POWER_REQUEST_TYPE = ::std::os::raw::c_uint;
pub use self::_POWER_REQUEST_TYPE as POWER_REQUEST_TYPE;
pub type PPOWER_REQUEST_TYPE = *mut _POWER_REQUEST_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CM_Power_Data_s {
    pub PD_Size: DWORD,
    pub PD_MostRecentPowerState: DEVICE_POWER_STATE,
    pub PD_Capabilities: DWORD,
    pub PD_D1Latency: DWORD,
    pub PD_D2Latency: DWORD,
    pub PD_D3Latency: DWORD,
    pub PD_PowerStateMapping: [DEVICE_POWER_STATE; 7usize],
    pub PD_DeepestSystemWake: SYSTEM_POWER_STATE,
}
#[test]
fn bindgen_test_layout_CM_Power_Data_s() {
    const UNINIT: ::std::mem::MaybeUninit<CM_Power_Data_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CM_Power_Data_s>(),
        56usize,
        concat!("Size of: ", stringify!(CM_Power_Data_s))
    );
    assert_eq!(
        ::std::mem::align_of::<CM_Power_Data_s>(),
        4usize,
        concat!("Alignment of ", stringify!(CM_Power_Data_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PD_Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CM_Power_Data_s),
            "::",
            stringify!(PD_Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PD_MostRecentPowerState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CM_Power_Data_s),
            "::",
            stringify!(PD_MostRecentPowerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PD_Capabilities) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CM_Power_Data_s),
            "::",
            stringify!(PD_Capabilities)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PD_D1Latency) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CM_Power_Data_s),
            "::",
            stringify!(PD_D1Latency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PD_D2Latency) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CM_Power_Data_s),
            "::",
            stringify!(PD_D2Latency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PD_D3Latency) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CM_Power_Data_s),
            "::",
            stringify!(PD_D3Latency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PD_PowerStateMapping) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CM_Power_Data_s),
            "::",
            stringify!(PD_PowerStateMapping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PD_DeepestSystemWake) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CM_Power_Data_s),
            "::",
            stringify!(PD_DeepestSystemWake)
        )
    );
}
pub type CM_POWER_DATA = CM_Power_Data_s;
pub type PCM_POWER_DATA = *mut CM_Power_Data_s;
pub const POWER_INFORMATION_LEVEL_SystemPowerPolicyAc: POWER_INFORMATION_LEVEL = 0;
pub const POWER_INFORMATION_LEVEL_SystemPowerPolicyDc: POWER_INFORMATION_LEVEL = 1;
pub const POWER_INFORMATION_LEVEL_VerifySystemPolicyAc: POWER_INFORMATION_LEVEL = 2;
pub const POWER_INFORMATION_LEVEL_VerifySystemPolicyDc: POWER_INFORMATION_LEVEL = 3;
pub const POWER_INFORMATION_LEVEL_SystemPowerCapabilities: POWER_INFORMATION_LEVEL = 4;
pub const POWER_INFORMATION_LEVEL_SystemBatteryState: POWER_INFORMATION_LEVEL = 5;
pub const POWER_INFORMATION_LEVEL_SystemPowerStateHandler: POWER_INFORMATION_LEVEL = 6;
pub const POWER_INFORMATION_LEVEL_ProcessorStateHandler: POWER_INFORMATION_LEVEL = 7;
pub const POWER_INFORMATION_LEVEL_SystemPowerPolicyCurrent: POWER_INFORMATION_LEVEL = 8;
pub const POWER_INFORMATION_LEVEL_AdministratorPowerPolicy: POWER_INFORMATION_LEVEL = 9;
pub const POWER_INFORMATION_LEVEL_SystemReserveHiberFile: POWER_INFORMATION_LEVEL = 10;
pub const POWER_INFORMATION_LEVEL_ProcessorInformation: POWER_INFORMATION_LEVEL = 11;
pub const POWER_INFORMATION_LEVEL_SystemPowerInformation: POWER_INFORMATION_LEVEL = 12;
pub const POWER_INFORMATION_LEVEL_ProcessorStateHandler2: POWER_INFORMATION_LEVEL = 13;
pub const POWER_INFORMATION_LEVEL_LastWakeTime: POWER_INFORMATION_LEVEL = 14;
pub const POWER_INFORMATION_LEVEL_LastSleepTime: POWER_INFORMATION_LEVEL = 15;
pub const POWER_INFORMATION_LEVEL_SystemExecutionState: POWER_INFORMATION_LEVEL = 16;
pub const POWER_INFORMATION_LEVEL_SystemPowerStateNotifyHandler: POWER_INFORMATION_LEVEL = 17;
pub const POWER_INFORMATION_LEVEL_ProcessorPowerPolicyAc: POWER_INFORMATION_LEVEL = 18;
pub const POWER_INFORMATION_LEVEL_ProcessorPowerPolicyDc: POWER_INFORMATION_LEVEL = 19;
pub const POWER_INFORMATION_LEVEL_VerifyProcessorPowerPolicyAc: POWER_INFORMATION_LEVEL = 20;
pub const POWER_INFORMATION_LEVEL_VerifyProcessorPowerPolicyDc: POWER_INFORMATION_LEVEL = 21;
pub const POWER_INFORMATION_LEVEL_ProcessorPowerPolicyCurrent: POWER_INFORMATION_LEVEL = 22;
pub const POWER_INFORMATION_LEVEL_SystemPowerStateLogging: POWER_INFORMATION_LEVEL = 23;
pub const POWER_INFORMATION_LEVEL_SystemPowerLoggingEntry: POWER_INFORMATION_LEVEL = 24;
pub const POWER_INFORMATION_LEVEL_SetPowerSettingValue: POWER_INFORMATION_LEVEL = 25;
pub const POWER_INFORMATION_LEVEL_NotifyUserPowerSetting: POWER_INFORMATION_LEVEL = 26;
pub const POWER_INFORMATION_LEVEL_PowerInformationLevelUnused0: POWER_INFORMATION_LEVEL = 27;
pub const POWER_INFORMATION_LEVEL_SystemMonitorHiberBootPowerOff: POWER_INFORMATION_LEVEL = 28;
pub const POWER_INFORMATION_LEVEL_SystemVideoState: POWER_INFORMATION_LEVEL = 29;
pub const POWER_INFORMATION_LEVEL_TraceApplicationPowerMessage: POWER_INFORMATION_LEVEL = 30;
pub const POWER_INFORMATION_LEVEL_TraceApplicationPowerMessageEnd: POWER_INFORMATION_LEVEL = 31;
pub const POWER_INFORMATION_LEVEL_ProcessorPerfStates: POWER_INFORMATION_LEVEL = 32;
pub const POWER_INFORMATION_LEVEL_ProcessorIdleStates: POWER_INFORMATION_LEVEL = 33;
pub const POWER_INFORMATION_LEVEL_ProcessorCap: POWER_INFORMATION_LEVEL = 34;
pub const POWER_INFORMATION_LEVEL_SystemWakeSource: POWER_INFORMATION_LEVEL = 35;
pub const POWER_INFORMATION_LEVEL_SystemHiberFileInformation: POWER_INFORMATION_LEVEL = 36;
pub const POWER_INFORMATION_LEVEL_TraceServicePowerMessage: POWER_INFORMATION_LEVEL = 37;
pub const POWER_INFORMATION_LEVEL_ProcessorLoad: POWER_INFORMATION_LEVEL = 38;
pub const POWER_INFORMATION_LEVEL_PowerShutdownNotification: POWER_INFORMATION_LEVEL = 39;
pub const POWER_INFORMATION_LEVEL_MonitorCapabilities: POWER_INFORMATION_LEVEL = 40;
pub const POWER_INFORMATION_LEVEL_SessionPowerInit: POWER_INFORMATION_LEVEL = 41;
pub const POWER_INFORMATION_LEVEL_SessionDisplayState: POWER_INFORMATION_LEVEL = 42;
pub const POWER_INFORMATION_LEVEL_PowerRequestCreate: POWER_INFORMATION_LEVEL = 43;
pub const POWER_INFORMATION_LEVEL_PowerRequestAction: POWER_INFORMATION_LEVEL = 44;
pub const POWER_INFORMATION_LEVEL_GetPowerRequestList: POWER_INFORMATION_LEVEL = 45;
pub const POWER_INFORMATION_LEVEL_ProcessorInformationEx: POWER_INFORMATION_LEVEL = 46;
pub const POWER_INFORMATION_LEVEL_NotifyUserModeLegacyPowerEvent: POWER_INFORMATION_LEVEL = 47;
pub const POWER_INFORMATION_LEVEL_GroupPark: POWER_INFORMATION_LEVEL = 48;
pub const POWER_INFORMATION_LEVEL_ProcessorIdleDomains: POWER_INFORMATION_LEVEL = 49;
pub const POWER_INFORMATION_LEVEL_WakeTimerList: POWER_INFORMATION_LEVEL = 50;
pub const POWER_INFORMATION_LEVEL_SystemHiberFileSize: POWER_INFORMATION_LEVEL = 51;
pub const POWER_INFORMATION_LEVEL_ProcessorIdleStatesHv: POWER_INFORMATION_LEVEL = 52;
pub const POWER_INFORMATION_LEVEL_ProcessorPerfStatesHv: POWER_INFORMATION_LEVEL = 53;
pub const POWER_INFORMATION_LEVEL_ProcessorPerfCapHv: POWER_INFORMATION_LEVEL = 54;
pub const POWER_INFORMATION_LEVEL_ProcessorSetIdle: POWER_INFORMATION_LEVEL = 55;
pub const POWER_INFORMATION_LEVEL_LogicalProcessorIdling: POWER_INFORMATION_LEVEL = 56;
pub const POWER_INFORMATION_LEVEL_UserPresence: POWER_INFORMATION_LEVEL = 57;
pub const POWER_INFORMATION_LEVEL_PowerSettingNotificationName: POWER_INFORMATION_LEVEL = 58;
pub const POWER_INFORMATION_LEVEL_GetPowerSettingValue: POWER_INFORMATION_LEVEL = 59;
pub const POWER_INFORMATION_LEVEL_IdleResiliency: POWER_INFORMATION_LEVEL = 60;
pub const POWER_INFORMATION_LEVEL_SessionRITState: POWER_INFORMATION_LEVEL = 61;
pub const POWER_INFORMATION_LEVEL_SessionConnectNotification: POWER_INFORMATION_LEVEL = 62;
pub const POWER_INFORMATION_LEVEL_SessionPowerCleanup: POWER_INFORMATION_LEVEL = 63;
pub const POWER_INFORMATION_LEVEL_SessionLockState: POWER_INFORMATION_LEVEL = 64;
pub const POWER_INFORMATION_LEVEL_SystemHiberbootState: POWER_INFORMATION_LEVEL = 65;
pub const POWER_INFORMATION_LEVEL_PlatformInformation: POWER_INFORMATION_LEVEL = 66;
pub const POWER_INFORMATION_LEVEL_PdcInvocation: POWER_INFORMATION_LEVEL = 67;
pub const POWER_INFORMATION_LEVEL_MonitorInvocation: POWER_INFORMATION_LEVEL = 68;
pub const POWER_INFORMATION_LEVEL_FirmwareTableInformationRegistered: POWER_INFORMATION_LEVEL = 69;
pub const POWER_INFORMATION_LEVEL_SetShutdownSelectedTime: POWER_INFORMATION_LEVEL = 70;
pub const POWER_INFORMATION_LEVEL_SuspendResumeInvocation: POWER_INFORMATION_LEVEL = 71;
pub const POWER_INFORMATION_LEVEL_PlmPowerRequestCreate: POWER_INFORMATION_LEVEL = 72;
pub const POWER_INFORMATION_LEVEL_ScreenOff: POWER_INFORMATION_LEVEL = 73;
pub const POWER_INFORMATION_LEVEL_CsDeviceNotification: POWER_INFORMATION_LEVEL = 74;
pub const POWER_INFORMATION_LEVEL_PlatformRole: POWER_INFORMATION_LEVEL = 75;
pub const POWER_INFORMATION_LEVEL_LastResumePerformance: POWER_INFORMATION_LEVEL = 76;
pub const POWER_INFORMATION_LEVEL_DisplayBurst: POWER_INFORMATION_LEVEL = 77;
pub const POWER_INFORMATION_LEVEL_ExitLatencySamplingPercentage: POWER_INFORMATION_LEVEL = 78;
pub const POWER_INFORMATION_LEVEL_ApplyLowPowerScenarioSettings: POWER_INFORMATION_LEVEL = 79;
pub const POWER_INFORMATION_LEVEL_PowerInformationLevelMaximum: POWER_INFORMATION_LEVEL = 80;
pub type POWER_INFORMATION_LEVEL = ::std::os::raw::c_uint;
pub const POWER_USER_PRESENCE_TYPE_UserNotPresent: POWER_USER_PRESENCE_TYPE = 0;
pub const POWER_USER_PRESENCE_TYPE_UserPresent: POWER_USER_PRESENCE_TYPE = 1;
pub const POWER_USER_PRESENCE_TYPE_UserUnknown: POWER_USER_PRESENCE_TYPE = 255;
pub type POWER_USER_PRESENCE_TYPE = ::std::os::raw::c_uint;
pub type PPOWER_USER_PRESENCE_TYPE = *mut POWER_USER_PRESENCE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_USER_PRESENCE {
    pub UserPresence: POWER_USER_PRESENCE_TYPE,
}
#[test]
fn bindgen_test_layout__POWER_USER_PRESENCE() {
    const UNINIT: ::std::mem::MaybeUninit<_POWER_USER_PRESENCE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_POWER_USER_PRESENCE>(),
        4usize,
        concat!("Size of: ", stringify!(_POWER_USER_PRESENCE))
    );
    assert_eq!(
        ::std::mem::align_of::<_POWER_USER_PRESENCE>(),
        4usize,
        concat!("Alignment of ", stringify!(_POWER_USER_PRESENCE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserPresence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_USER_PRESENCE),
            "::",
            stringify!(UserPresence)
        )
    );
}
pub type POWER_USER_PRESENCE = _POWER_USER_PRESENCE;
pub type PPOWER_USER_PRESENCE = *mut _POWER_USER_PRESENCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_CONNECT {
    pub Connected: BOOLEAN,
    pub Console: BOOLEAN,
}
#[test]
fn bindgen_test_layout__POWER_SESSION_CONNECT() {
    const UNINIT: ::std::mem::MaybeUninit<_POWER_SESSION_CONNECT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_POWER_SESSION_CONNECT>(),
        2usize,
        concat!("Size of: ", stringify!(_POWER_SESSION_CONNECT))
    );
    assert_eq!(
        ::std::mem::align_of::<_POWER_SESSION_CONNECT>(),
        1usize,
        concat!("Alignment of ", stringify!(_POWER_SESSION_CONNECT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Connected) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SESSION_CONNECT),
            "::",
            stringify!(Connected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Console) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SESSION_CONNECT),
            "::",
            stringify!(Console)
        )
    );
}
pub type POWER_SESSION_CONNECT = _POWER_SESSION_CONNECT;
pub type PPOWER_SESSION_CONNECT = *mut _POWER_SESSION_CONNECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_TIMEOUTS {
    pub InputTimeout: DWORD,
    pub DisplayTimeout: DWORD,
}
#[test]
fn bindgen_test_layout__POWER_SESSION_TIMEOUTS() {
    const UNINIT: ::std::mem::MaybeUninit<_POWER_SESSION_TIMEOUTS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_POWER_SESSION_TIMEOUTS>(),
        8usize,
        concat!("Size of: ", stringify!(_POWER_SESSION_TIMEOUTS))
    );
    assert_eq!(
        ::std::mem::align_of::<_POWER_SESSION_TIMEOUTS>(),
        4usize,
        concat!("Alignment of ", stringify!(_POWER_SESSION_TIMEOUTS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InputTimeout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SESSION_TIMEOUTS),
            "::",
            stringify!(InputTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisplayTimeout) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SESSION_TIMEOUTS),
            "::",
            stringify!(DisplayTimeout)
        )
    );
}
pub type POWER_SESSION_TIMEOUTS = _POWER_SESSION_TIMEOUTS;
pub type PPOWER_SESSION_TIMEOUTS = *mut _POWER_SESSION_TIMEOUTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_RIT_STATE {
    pub Active: BOOLEAN,
    pub LastInputTime: DWORD,
}
#[test]
fn bindgen_test_layout__POWER_SESSION_RIT_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_POWER_SESSION_RIT_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_POWER_SESSION_RIT_STATE>(),
        8usize,
        concat!("Size of: ", stringify!(_POWER_SESSION_RIT_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_POWER_SESSION_RIT_STATE>(),
        4usize,
        concat!("Alignment of ", stringify!(_POWER_SESSION_RIT_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Active) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SESSION_RIT_STATE),
            "::",
            stringify!(Active)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastInputTime) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SESSION_RIT_STATE),
            "::",
            stringify!(LastInputTime)
        )
    );
}
pub type POWER_SESSION_RIT_STATE = _POWER_SESSION_RIT_STATE;
pub type PPOWER_SESSION_RIT_STATE = *mut _POWER_SESSION_RIT_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_WINLOGON {
    pub SessionId: DWORD,
    pub Console: BOOLEAN,
    pub Locked: BOOLEAN,
}
#[test]
fn bindgen_test_layout__POWER_SESSION_WINLOGON() {
    const UNINIT: ::std::mem::MaybeUninit<_POWER_SESSION_WINLOGON> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_POWER_SESSION_WINLOGON>(),
        8usize,
        concat!("Size of: ", stringify!(_POWER_SESSION_WINLOGON))
    );
    assert_eq!(
        ::std::mem::align_of::<_POWER_SESSION_WINLOGON>(),
        4usize,
        concat!("Alignment of ", stringify!(_POWER_SESSION_WINLOGON))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SESSION_WINLOGON),
            "::",
            stringify!(SessionId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Console) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SESSION_WINLOGON),
            "::",
            stringify!(Console)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Locked) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SESSION_WINLOGON),
            "::",
            stringify!(Locked)
        )
    );
}
pub type POWER_SESSION_WINLOGON = _POWER_SESSION_WINLOGON;
pub type PPOWER_SESSION_WINLOGON = *mut _POWER_SESSION_WINLOGON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_IDLE_RESILIENCY {
    pub CoalescingTimeout: DWORD,
    pub IdleResiliencyPeriod: DWORD,
}
#[test]
fn bindgen_test_layout__POWER_IDLE_RESILIENCY() {
    const UNINIT: ::std::mem::MaybeUninit<_POWER_IDLE_RESILIENCY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_POWER_IDLE_RESILIENCY>(),
        8usize,
        concat!("Size of: ", stringify!(_POWER_IDLE_RESILIENCY))
    );
    assert_eq!(
        ::std::mem::align_of::<_POWER_IDLE_RESILIENCY>(),
        4usize,
        concat!("Alignment of ", stringify!(_POWER_IDLE_RESILIENCY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CoalescingTimeout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_IDLE_RESILIENCY),
            "::",
            stringify!(CoalescingTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IdleResiliencyPeriod) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_IDLE_RESILIENCY),
            "::",
            stringify!(IdleResiliencyPeriod)
        )
    );
}
pub type POWER_IDLE_RESILIENCY = _POWER_IDLE_RESILIENCY;
pub type PPOWER_IDLE_RESILIENCY = *mut _POWER_IDLE_RESILIENCY;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUnknown: POWER_MONITOR_REQUEST_REASON =
    0;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPowerButton:
    POWER_MONITOR_REQUEST_REASON = 1;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonRemoteConnection:
    POWER_MONITOR_REQUEST_REASON = 2;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonScMonitorpower:
    POWER_MONITOR_REQUEST_REASON = 3;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInput: POWER_MONITOR_REQUEST_REASON =
    4;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonAcDcDisplayBurst:
    POWER_MONITOR_REQUEST_REASON = 5;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserDisplayBurst:
    POWER_MONITOR_REQUEST_REASON = 6;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPoSetSystemState:
    POWER_MONITOR_REQUEST_REASON = 7;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSetThreadExecutionState:
    POWER_MONITOR_REQUEST_REASON = 8;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonFullWake: POWER_MONITOR_REQUEST_REASON =
    9;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSessionUnlock:
    POWER_MONITOR_REQUEST_REASON = 10;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonScreenOffRequest:
    POWER_MONITOR_REQUEST_REASON = 11;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonIdleTimeout:
    POWER_MONITOR_REQUEST_REASON = 12;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPolicyChange:
    POWER_MONITOR_REQUEST_REASON = 13;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonMax: POWER_MONITOR_REQUEST_REASON = 14;
pub type POWER_MONITOR_REQUEST_REASON = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_MONITOR_INVOCATION {
    pub On: BOOLEAN,
    pub Console: BOOLEAN,
    pub RequestReason: POWER_MONITOR_REQUEST_REASON,
}
#[test]
fn bindgen_test_layout__POWER_MONITOR_INVOCATION() {
    const UNINIT: ::std::mem::MaybeUninit<_POWER_MONITOR_INVOCATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_POWER_MONITOR_INVOCATION>(),
        8usize,
        concat!("Size of: ", stringify!(_POWER_MONITOR_INVOCATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_POWER_MONITOR_INVOCATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_POWER_MONITOR_INVOCATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).On) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_MONITOR_INVOCATION),
            "::",
            stringify!(On)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Console) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_MONITOR_INVOCATION),
            "::",
            stringify!(Console)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RequestReason) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_MONITOR_INVOCATION),
            "::",
            stringify!(RequestReason)
        )
    );
}
pub type POWER_MONITOR_INVOCATION = _POWER_MONITOR_INVOCATION;
pub type PPOWER_MONITOR_INVOCATION = *mut _POWER_MONITOR_INVOCATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RESUME_PERFORMANCE {
    pub PostTimeMs: DWORD,
    pub TotalResumeTimeMs: ULONGLONG,
    pub ResumeCompleteTimestamp: ULONGLONG,
}
#[test]
fn bindgen_test_layout__RESUME_PERFORMANCE() {
    const UNINIT: ::std::mem::MaybeUninit<_RESUME_PERFORMANCE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RESUME_PERFORMANCE>(),
        24usize,
        concat!("Size of: ", stringify!(_RESUME_PERFORMANCE))
    );
    assert_eq!(
        ::std::mem::align_of::<_RESUME_PERFORMANCE>(),
        8usize,
        concat!("Alignment of ", stringify!(_RESUME_PERFORMANCE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PostTimeMs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RESUME_PERFORMANCE),
            "::",
            stringify!(PostTimeMs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalResumeTimeMs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RESUME_PERFORMANCE),
            "::",
            stringify!(TotalResumeTimeMs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResumeCompleteTimestamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RESUME_PERFORMANCE),
            "::",
            stringify!(ResumeCompleteTimestamp)
        )
    );
}
pub type RESUME_PERFORMANCE = _RESUME_PERFORMANCE;
pub type PRESUME_PERFORMANCE = *mut _RESUME_PERFORMANCE;
pub const SYSTEM_POWER_CONDITION_PoAc: SYSTEM_POWER_CONDITION = 0;
pub const SYSTEM_POWER_CONDITION_PoDc: SYSTEM_POWER_CONDITION = 1;
pub const SYSTEM_POWER_CONDITION_PoHot: SYSTEM_POWER_CONDITION = 2;
pub const SYSTEM_POWER_CONDITION_PoConditionMaximum: SYSTEM_POWER_CONDITION = 3;
pub type SYSTEM_POWER_CONDITION = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SET_POWER_SETTING_VALUE {
    pub Version: DWORD,
    pub Guid: GUID,
    pub PowerCondition: SYSTEM_POWER_CONDITION,
    pub DataLength: DWORD,
    pub Data: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_SET_POWER_SETTING_VALUE() {
    const UNINIT: ::std::mem::MaybeUninit<SET_POWER_SETTING_VALUE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SET_POWER_SETTING_VALUE>(),
        32usize,
        concat!("Size of: ", stringify!(SET_POWER_SETTING_VALUE))
    );
    assert_eq!(
        ::std::mem::align_of::<SET_POWER_SETTING_VALUE>(),
        4usize,
        concat!("Alignment of ", stringify!(SET_POWER_SETTING_VALUE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SET_POWER_SETTING_VALUE),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Guid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SET_POWER_SETTING_VALUE),
            "::",
            stringify!(Guid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PowerCondition) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SET_POWER_SETTING_VALUE),
            "::",
            stringify!(PowerCondition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataLength) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SET_POWER_SETTING_VALUE),
            "::",
            stringify!(DataLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SET_POWER_SETTING_VALUE),
            "::",
            stringify!(Data)
        )
    );
}
pub type PSET_POWER_SETTING_VALUE = *mut SET_POWER_SETTING_VALUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NOTIFY_USER_POWER_SETTING {
    pub Guid: GUID,
}
#[test]
fn bindgen_test_layout_NOTIFY_USER_POWER_SETTING() {
    const UNINIT: ::std::mem::MaybeUninit<NOTIFY_USER_POWER_SETTING> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NOTIFY_USER_POWER_SETTING>(),
        16usize,
        concat!("Size of: ", stringify!(NOTIFY_USER_POWER_SETTING))
    );
    assert_eq!(
        ::std::mem::align_of::<NOTIFY_USER_POWER_SETTING>(),
        4usize,
        concat!("Alignment of ", stringify!(NOTIFY_USER_POWER_SETTING))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Guid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NOTIFY_USER_POWER_SETTING),
            "::",
            stringify!(Guid)
        )
    );
}
pub type PNOTIFY_USER_POWER_SETTING = *mut NOTIFY_USER_POWER_SETTING;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _APPLICATIONLAUNCH_SETTING_VALUE {
    pub ActivationTime: LARGE_INTEGER,
    pub Flags: DWORD,
    pub ButtonInstanceID: DWORD,
}
#[test]
fn bindgen_test_layout__APPLICATIONLAUNCH_SETTING_VALUE() {
    const UNINIT: ::std::mem::MaybeUninit<_APPLICATIONLAUNCH_SETTING_VALUE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_APPLICATIONLAUNCH_SETTING_VALUE>(),
        16usize,
        concat!("Size of: ", stringify!(_APPLICATIONLAUNCH_SETTING_VALUE))
    );
    assert_eq!(
        ::std::mem::align_of::<_APPLICATIONLAUNCH_SETTING_VALUE>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_APPLICATIONLAUNCH_SETTING_VALUE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ActivationTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_APPLICATIONLAUNCH_SETTING_VALUE),
            "::",
            stringify!(ActivationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_APPLICATIONLAUNCH_SETTING_VALUE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ButtonInstanceID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_APPLICATIONLAUNCH_SETTING_VALUE),
            "::",
            stringify!(ButtonInstanceID)
        )
    );
}
pub type APPLICATIONLAUNCH_SETTING_VALUE = _APPLICATIONLAUNCH_SETTING_VALUE;
pub type PAPPLICATIONLAUNCH_SETTING_VALUE = *mut _APPLICATIONLAUNCH_SETTING_VALUE;
pub const _POWER_PLATFORM_ROLE_PlatformRoleUnspecified: _POWER_PLATFORM_ROLE = 0;
pub const _POWER_PLATFORM_ROLE_PlatformRoleDesktop: _POWER_PLATFORM_ROLE = 1;
pub const _POWER_PLATFORM_ROLE_PlatformRoleMobile: _POWER_PLATFORM_ROLE = 2;
pub const _POWER_PLATFORM_ROLE_PlatformRoleWorkstation: _POWER_PLATFORM_ROLE = 3;
pub const _POWER_PLATFORM_ROLE_PlatformRoleEnterpriseServer: _POWER_PLATFORM_ROLE = 4;
pub const _POWER_PLATFORM_ROLE_PlatformRoleSOHOServer: _POWER_PLATFORM_ROLE = 5;
pub const _POWER_PLATFORM_ROLE_PlatformRoleAppliancePC: _POWER_PLATFORM_ROLE = 6;
pub const _POWER_PLATFORM_ROLE_PlatformRolePerformanceServer: _POWER_PLATFORM_ROLE = 7;
pub const _POWER_PLATFORM_ROLE_PlatformRoleSlate: _POWER_PLATFORM_ROLE = 8;
pub const _POWER_PLATFORM_ROLE_PlatformRoleMaximum: _POWER_PLATFORM_ROLE = 9;
pub type _POWER_PLATFORM_ROLE = ::std::os::raw::c_uint;
pub use self::_POWER_PLATFORM_ROLE as POWER_PLATFORM_ROLE;
pub type PPOWER_PLATFORM_ROLE = *mut _POWER_PLATFORM_ROLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_PLATFORM_INFORMATION {
    pub AoAc: BOOLEAN,
}
#[test]
fn bindgen_test_layout__POWER_PLATFORM_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_POWER_PLATFORM_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_POWER_PLATFORM_INFORMATION>(),
        1usize,
        concat!("Size of: ", stringify!(_POWER_PLATFORM_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_POWER_PLATFORM_INFORMATION>(),
        1usize,
        concat!("Alignment of ", stringify!(_POWER_PLATFORM_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AoAc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_PLATFORM_INFORMATION),
            "::",
            stringify!(AoAc)
        )
    );
}
pub type POWER_PLATFORM_INFORMATION = _POWER_PLATFORM_INFORMATION;
pub type PPOWER_PLATFORM_INFORMATION = *mut _POWER_PLATFORM_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BATTERY_REPORTING_SCALE {
    pub Granularity: DWORD,
    pub Capacity: DWORD,
}
#[test]
fn bindgen_test_layout_BATTERY_REPORTING_SCALE() {
    const UNINIT: ::std::mem::MaybeUninit<BATTERY_REPORTING_SCALE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BATTERY_REPORTING_SCALE>(),
        8usize,
        concat!("Size of: ", stringify!(BATTERY_REPORTING_SCALE))
    );
    assert_eq!(
        ::std::mem::align_of::<BATTERY_REPORTING_SCALE>(),
        4usize,
        concat!("Alignment of ", stringify!(BATTERY_REPORTING_SCALE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Granularity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BATTERY_REPORTING_SCALE),
            "::",
            stringify!(Granularity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Capacity) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BATTERY_REPORTING_SCALE),
            "::",
            stringify!(Capacity)
        )
    );
}
pub type PBATTERY_REPORTING_SCALE = *mut BATTERY_REPORTING_SCALE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_LEGACY_PERFSTATE {
    pub Frequency: DWORD,
    pub Flags: DWORD,
    pub PercentFrequency: DWORD,
}
#[test]
fn bindgen_test_layout_PPM_WMI_LEGACY_PERFSTATE() {
    const UNINIT: ::std::mem::MaybeUninit<PPM_WMI_LEGACY_PERFSTATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PPM_WMI_LEGACY_PERFSTATE>(),
        12usize,
        concat!("Size of: ", stringify!(PPM_WMI_LEGACY_PERFSTATE))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_WMI_LEGACY_PERFSTATE>(),
        4usize,
        concat!("Alignment of ", stringify!(PPM_WMI_LEGACY_PERFSTATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Frequency) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_LEGACY_PERFSTATE),
            "::",
            stringify!(Frequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_LEGACY_PERFSTATE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PercentFrequency) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_LEGACY_PERFSTATE),
            "::",
            stringify!(PercentFrequency)
        )
    );
}
pub type PPPM_WMI_LEGACY_PERFSTATE = *mut PPM_WMI_LEGACY_PERFSTATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_IDLE_STATE {
    pub Latency: DWORD,
    pub Power: DWORD,
    pub TimeCheck: DWORD,
    pub PromotePercent: BYTE,
    pub DemotePercent: BYTE,
    pub StateType: BYTE,
    pub Reserved: BYTE,
    pub StateFlags: DWORD,
    pub Context: DWORD,
    pub IdleHandler: DWORD,
    pub Reserved1: DWORD,
}
#[test]
fn bindgen_test_layout_PPM_WMI_IDLE_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<PPM_WMI_IDLE_STATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PPM_WMI_IDLE_STATE>(),
        32usize,
        concat!("Size of: ", stringify!(PPM_WMI_IDLE_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_WMI_IDLE_STATE>(),
        4usize,
        concat!("Alignment of ", stringify!(PPM_WMI_IDLE_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Latency) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(Latency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Power) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(Power)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeCheck) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(TimeCheck)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PromotePercent) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(PromotePercent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DemotePercent) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(DemotePercent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StateType) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(StateType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StateFlags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(StateFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Context) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(Context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IdleHandler) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(IdleHandler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(Reserved1)
        )
    );
}
pub type PPPM_WMI_IDLE_STATE = *mut PPM_WMI_IDLE_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_IDLE_STATES {
    pub Type: DWORD,
    pub Count: DWORD,
    pub TargetState: DWORD,
    pub OldState: DWORD,
    pub TargetProcessors: DWORD64,
    pub State: [PPM_WMI_IDLE_STATE; 1usize],
}
#[test]
fn bindgen_test_layout_PPM_WMI_IDLE_STATES() {
    const UNINIT: ::std::mem::MaybeUninit<PPM_WMI_IDLE_STATES> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PPM_WMI_IDLE_STATES>(),
        56usize,
        concat!("Size of: ", stringify!(PPM_WMI_IDLE_STATES))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_WMI_IDLE_STATES>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_WMI_IDLE_STATES))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES),
            "::",
            stringify!(TargetState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OldState) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES),
            "::",
            stringify!(OldState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetProcessors) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES),
            "::",
            stringify!(TargetProcessors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES),
            "::",
            stringify!(State)
        )
    );
}
pub type PPPM_WMI_IDLE_STATES = *mut PPM_WMI_IDLE_STATES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_IDLE_STATES_EX {
    pub Type: DWORD,
    pub Count: DWORD,
    pub TargetState: DWORD,
    pub OldState: DWORD,
    pub TargetProcessors: PVOID,
    pub State: [PPM_WMI_IDLE_STATE; 1usize],
}
#[test]
fn bindgen_test_layout_PPM_WMI_IDLE_STATES_EX() {
    const UNINIT: ::std::mem::MaybeUninit<PPM_WMI_IDLE_STATES_EX> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PPM_WMI_IDLE_STATES_EX>(),
        56usize,
        concat!("Size of: ", stringify!(PPM_WMI_IDLE_STATES_EX))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_WMI_IDLE_STATES_EX>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_WMI_IDLE_STATES_EX))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES_EX),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES_EX),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES_EX),
            "::",
            stringify!(TargetState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OldState) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES_EX),
            "::",
            stringify!(OldState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetProcessors) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES_EX),
            "::",
            stringify!(TargetProcessors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES_EX),
            "::",
            stringify!(State)
        )
    );
}
pub type PPPM_WMI_IDLE_STATES_EX = *mut PPM_WMI_IDLE_STATES_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_PERF_STATE {
    pub Frequency: DWORD,
    pub Power: DWORD,
    pub PercentFrequency: BYTE,
    pub IncreaseLevel: BYTE,
    pub DecreaseLevel: BYTE,
    pub Type: BYTE,
    pub IncreaseTime: DWORD,
    pub DecreaseTime: DWORD,
    pub Control: DWORD64,
    pub Status: DWORD64,
    pub HitCount: DWORD,
    pub Reserved1: DWORD,
    pub Reserved2: DWORD64,
    pub Reserved3: DWORD64,
}
#[test]
fn bindgen_test_layout_PPM_WMI_PERF_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<PPM_WMI_PERF_STATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PPM_WMI_PERF_STATE>(),
        64usize,
        concat!("Size of: ", stringify!(PPM_WMI_PERF_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_WMI_PERF_STATE>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_WMI_PERF_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Frequency) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(Frequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Power) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(Power)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PercentFrequency) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(PercentFrequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IncreaseLevel) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(IncreaseLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DecreaseLevel) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(DecreaseLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IncreaseTime) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(IncreaseTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DecreaseTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(DecreaseTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Control) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(Control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Status) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HitCount) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(HitCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(Reserved3)
        )
    );
}
pub type PPPM_WMI_PERF_STATE = *mut PPM_WMI_PERF_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_PERF_STATES {
    pub Count: DWORD,
    pub MaxFrequency: DWORD,
    pub CurrentState: DWORD,
    pub MaxPerfState: DWORD,
    pub MinPerfState: DWORD,
    pub LowestPerfState: DWORD,
    pub ThermalConstraint: DWORD,
    pub BusyAdjThreshold: BYTE,
    pub PolicyType: BYTE,
    pub Type: BYTE,
    pub Reserved: BYTE,
    pub TimerInterval: DWORD,
    pub TargetProcessors: DWORD64,
    pub PStateHandler: DWORD,
    pub PStateContext: DWORD,
    pub TStateHandler: DWORD,
    pub TStateContext: DWORD,
    pub FeedbackHandler: DWORD,
    pub Reserved1: DWORD,
    pub Reserved2: DWORD64,
    pub State: [PPM_WMI_PERF_STATE; 1usize],
}
#[test]
fn bindgen_test_layout_PPM_WMI_PERF_STATES() {
    const UNINIT: ::std::mem::MaybeUninit<PPM_WMI_PERF_STATES> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PPM_WMI_PERF_STATES>(),
        144usize,
        concat!("Size of: ", stringify!(PPM_WMI_PERF_STATES))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_WMI_PERF_STATES>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_WMI_PERF_STATES))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxFrequency) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(MaxFrequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(CurrentState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxPerfState) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(MaxPerfState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinPerfState) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(MinPerfState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LowestPerfState) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(LowestPerfState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ThermalConstraint) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(ThermalConstraint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BusyAdjThreshold) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(BusyAdjThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PolicyType) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(PolicyType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimerInterval) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(TimerInterval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetProcessors) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(TargetProcessors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PStateHandler) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(PStateHandler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PStateContext) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(PStateContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TStateHandler) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(TStateHandler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TStateContext) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(TStateContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FeedbackHandler) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(FeedbackHandler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(State)
        )
    );
}
pub type PPPM_WMI_PERF_STATES = *mut PPM_WMI_PERF_STATES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_PERF_STATES_EX {
    pub Count: DWORD,
    pub MaxFrequency: DWORD,
    pub CurrentState: DWORD,
    pub MaxPerfState: DWORD,
    pub MinPerfState: DWORD,
    pub LowestPerfState: DWORD,
    pub ThermalConstraint: DWORD,
    pub BusyAdjThreshold: BYTE,
    pub PolicyType: BYTE,
    pub Type: BYTE,
    pub Reserved: BYTE,
    pub TimerInterval: DWORD,
    pub TargetProcessors: PVOID,
    pub PStateHandler: DWORD,
    pub PStateContext: DWORD,
    pub TStateHandler: DWORD,
    pub TStateContext: DWORD,
    pub FeedbackHandler: DWORD,
    pub Reserved1: DWORD,
    pub Reserved2: DWORD64,
    pub State: [PPM_WMI_PERF_STATE; 1usize],
}
#[test]
fn bindgen_test_layout_PPM_WMI_PERF_STATES_EX() {
    const UNINIT: ::std::mem::MaybeUninit<PPM_WMI_PERF_STATES_EX> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PPM_WMI_PERF_STATES_EX>(),
        144usize,
        concat!("Size of: ", stringify!(PPM_WMI_PERF_STATES_EX))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_WMI_PERF_STATES_EX>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_WMI_PERF_STATES_EX))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxFrequency) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(MaxFrequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(CurrentState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxPerfState) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(MaxPerfState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinPerfState) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(MinPerfState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LowestPerfState) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(LowestPerfState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ThermalConstraint) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(ThermalConstraint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BusyAdjThreshold) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(BusyAdjThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PolicyType) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(PolicyType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimerInterval) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(TimerInterval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetProcessors) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(TargetProcessors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PStateHandler) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(PStateHandler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PStateContext) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(PStateContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TStateHandler) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(TStateHandler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TStateContext) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(TStateContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FeedbackHandler) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(FeedbackHandler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(State)
        )
    );
}
pub type PPPM_WMI_PERF_STATES_EX = *mut PPM_WMI_PERF_STATES_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_IDLE_STATE_ACCOUNTING {
    pub IdleTransitions: DWORD,
    pub FailedTransitions: DWORD,
    pub InvalidBucketIndex: DWORD,
    pub TotalTime: DWORD64,
    pub IdleTimeBuckets: [DWORD; 6usize],
}
#[test]
fn bindgen_test_layout_PPM_IDLE_STATE_ACCOUNTING() {
    const UNINIT: ::std::mem::MaybeUninit<PPM_IDLE_STATE_ACCOUNTING> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PPM_IDLE_STATE_ACCOUNTING>(),
        48usize,
        concat!("Size of: ", stringify!(PPM_IDLE_STATE_ACCOUNTING))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_IDLE_STATE_ACCOUNTING>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_IDLE_STATE_ACCOUNTING))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IdleTransitions) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING),
            "::",
            stringify!(IdleTransitions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FailedTransitions) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING),
            "::",
            stringify!(FailedTransitions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InvalidBucketIndex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING),
            "::",
            stringify!(InvalidBucketIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING),
            "::",
            stringify!(TotalTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IdleTimeBuckets) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING),
            "::",
            stringify!(IdleTimeBuckets)
        )
    );
}
pub type PPPM_IDLE_STATE_ACCOUNTING = *mut PPM_IDLE_STATE_ACCOUNTING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_IDLE_ACCOUNTING {
    pub StateCount: DWORD,
    pub TotalTransitions: DWORD,
    pub ResetCount: DWORD,
    pub StartTime: DWORD64,
    pub State: [PPM_IDLE_STATE_ACCOUNTING; 1usize],
}
#[test]
fn bindgen_test_layout_PPM_IDLE_ACCOUNTING() {
    const UNINIT: ::std::mem::MaybeUninit<PPM_IDLE_ACCOUNTING> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PPM_IDLE_ACCOUNTING>(),
        72usize,
        concat!("Size of: ", stringify!(PPM_IDLE_ACCOUNTING))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_IDLE_ACCOUNTING>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_IDLE_ACCOUNTING))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StateCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING),
            "::",
            stringify!(StateCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalTransitions) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING),
            "::",
            stringify!(TotalTransitions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResetCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING),
            "::",
            stringify!(ResetCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StartTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING),
            "::",
            stringify!(StartTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING),
            "::",
            stringify!(State)
        )
    );
}
pub type PPPM_IDLE_ACCOUNTING = *mut PPM_IDLE_ACCOUNTING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_IDLE_STATE_BUCKET_EX {
    pub TotalTimeUs: DWORD64,
    pub MinTimeUs: DWORD,
    pub MaxTimeUs: DWORD,
    pub Count: DWORD,
}
#[test]
fn bindgen_test_layout_PPM_IDLE_STATE_BUCKET_EX() {
    const UNINIT: ::std::mem::MaybeUninit<PPM_IDLE_STATE_BUCKET_EX> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PPM_IDLE_STATE_BUCKET_EX>(),
        24usize,
        concat!("Size of: ", stringify!(PPM_IDLE_STATE_BUCKET_EX))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_IDLE_STATE_BUCKET_EX>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_IDLE_STATE_BUCKET_EX))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalTimeUs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_BUCKET_EX),
            "::",
            stringify!(TotalTimeUs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinTimeUs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_BUCKET_EX),
            "::",
            stringify!(MinTimeUs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxTimeUs) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_BUCKET_EX),
            "::",
            stringify!(MaxTimeUs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_BUCKET_EX),
            "::",
            stringify!(Count)
        )
    );
}
pub type PPPM_IDLE_STATE_BUCKET_EX = *mut PPM_IDLE_STATE_BUCKET_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_IDLE_STATE_ACCOUNTING_EX {
    pub TotalTime: DWORD64,
    pub IdleTransitions: DWORD,
    pub FailedTransitions: DWORD,
    pub InvalidBucketIndex: DWORD,
    pub MinTimeUs: DWORD,
    pub MaxTimeUs: DWORD,
    pub CancelledTransitions: DWORD,
    pub IdleTimeBuckets: [PPM_IDLE_STATE_BUCKET_EX; 16usize],
}
#[test]
fn bindgen_test_layout_PPM_IDLE_STATE_ACCOUNTING_EX() {
    const UNINIT: ::std::mem::MaybeUninit<PPM_IDLE_STATE_ACCOUNTING_EX> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PPM_IDLE_STATE_ACCOUNTING_EX>(),
        416usize,
        concat!("Size of: ", stringify!(PPM_IDLE_STATE_ACCOUNTING_EX))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_IDLE_STATE_ACCOUNTING_EX>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_IDLE_STATE_ACCOUNTING_EX))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
            "::",
            stringify!(TotalTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IdleTransitions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
            "::",
            stringify!(IdleTransitions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FailedTransitions) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
            "::",
            stringify!(FailedTransitions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InvalidBucketIndex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
            "::",
            stringify!(InvalidBucketIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinTimeUs) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
            "::",
            stringify!(MinTimeUs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxTimeUs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
            "::",
            stringify!(MaxTimeUs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CancelledTransitions) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
            "::",
            stringify!(CancelledTransitions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IdleTimeBuckets) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
            "::",
            stringify!(IdleTimeBuckets)
        )
    );
}
pub type PPPM_IDLE_STATE_ACCOUNTING_EX = *mut PPM_IDLE_STATE_ACCOUNTING_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_IDLE_ACCOUNTING_EX {
    pub StateCount: DWORD,
    pub TotalTransitions: DWORD,
    pub ResetCount: DWORD,
    pub AbortCount: DWORD,
    pub StartTime: DWORD64,
    pub State: [PPM_IDLE_STATE_ACCOUNTING_EX; 1usize],
}
#[test]
fn bindgen_test_layout_PPM_IDLE_ACCOUNTING_EX() {
    const UNINIT: ::std::mem::MaybeUninit<PPM_IDLE_ACCOUNTING_EX> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PPM_IDLE_ACCOUNTING_EX>(),
        440usize,
        concat!("Size of: ", stringify!(PPM_IDLE_ACCOUNTING_EX))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_IDLE_ACCOUNTING_EX>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_IDLE_ACCOUNTING_EX))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StateCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING_EX),
            "::",
            stringify!(StateCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalTransitions) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING_EX),
            "::",
            stringify!(TotalTransitions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResetCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING_EX),
            "::",
            stringify!(ResetCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AbortCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING_EX),
            "::",
            stringify!(AbortCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StartTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING_EX),
            "::",
            stringify!(StartTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING_EX),
            "::",
            stringify!(State)
        )
    );
}
pub type PPPM_IDLE_ACCOUNTING_EX = *mut PPM_IDLE_ACCOUNTING_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_PERFSTATE_EVENT {
    pub State: DWORD,
    pub Status: DWORD,
    pub Latency: DWORD,
    pub Speed: DWORD,
    pub Processor: DWORD,
}
#[test]
fn bindgen_test_layout_PPM_PERFSTATE_EVENT() {
    const UNINIT: ::std::mem::MaybeUninit<PPM_PERFSTATE_EVENT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PPM_PERFSTATE_EVENT>(),
        20usize,
        concat!("Size of: ", stringify!(PPM_PERFSTATE_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_PERFSTATE_EVENT>(),
        4usize,
        concat!("Alignment of ", stringify!(PPM_PERFSTATE_EVENT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_PERFSTATE_EVENT),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_PERFSTATE_EVENT),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Latency) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_PERFSTATE_EVENT),
            "::",
            stringify!(Latency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Speed) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_PERFSTATE_EVENT),
            "::",
            stringify!(Speed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Processor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_PERFSTATE_EVENT),
            "::",
            stringify!(Processor)
        )
    );
}
pub type PPPM_PERFSTATE_EVENT = *mut PPM_PERFSTATE_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_PERFSTATE_DOMAIN_EVENT {
    pub State: DWORD,
    pub Latency: DWORD,
    pub Speed: DWORD,
    pub Processors: DWORD64,
}
#[test]
fn bindgen_test_layout_PPM_PERFSTATE_DOMAIN_EVENT() {
    const UNINIT: ::std::mem::MaybeUninit<PPM_PERFSTATE_DOMAIN_EVENT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PPM_PERFSTATE_DOMAIN_EVENT>(),
        24usize,
        concat!("Size of: ", stringify!(PPM_PERFSTATE_DOMAIN_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_PERFSTATE_DOMAIN_EVENT>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_PERFSTATE_DOMAIN_EVENT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_PERFSTATE_DOMAIN_EVENT),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Latency) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_PERFSTATE_DOMAIN_EVENT),
            "::",
            stringify!(Latency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Speed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_PERFSTATE_DOMAIN_EVENT),
            "::",
            stringify!(Speed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Processors) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_PERFSTATE_DOMAIN_EVENT),
            "::",
            stringify!(Processors)
        )
    );
}
pub type PPPM_PERFSTATE_DOMAIN_EVENT = *mut PPM_PERFSTATE_DOMAIN_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_IDLESTATE_EVENT {
    pub NewState: DWORD,
    pub OldState: DWORD,
    pub Processors: DWORD64,
}
#[test]
fn bindgen_test_layout_PPM_IDLESTATE_EVENT() {
    const UNINIT: ::std::mem::MaybeUninit<PPM_IDLESTATE_EVENT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PPM_IDLESTATE_EVENT>(),
        16usize,
        concat!("Size of: ", stringify!(PPM_IDLESTATE_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_IDLESTATE_EVENT>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_IDLESTATE_EVENT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NewState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLESTATE_EVENT),
            "::",
            stringify!(NewState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OldState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLESTATE_EVENT),
            "::",
            stringify!(OldState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Processors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLESTATE_EVENT),
            "::",
            stringify!(Processors)
        )
    );
}
pub type PPPM_IDLESTATE_EVENT = *mut PPM_IDLESTATE_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_THERMALCHANGE_EVENT {
    pub ThermalConstraint: DWORD,
    pub Processors: DWORD64,
}
#[test]
fn bindgen_test_layout_PPM_THERMALCHANGE_EVENT() {
    const UNINIT: ::std::mem::MaybeUninit<PPM_THERMALCHANGE_EVENT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PPM_THERMALCHANGE_EVENT>(),
        16usize,
        concat!("Size of: ", stringify!(PPM_THERMALCHANGE_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_THERMALCHANGE_EVENT>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_THERMALCHANGE_EVENT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ThermalConstraint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_THERMALCHANGE_EVENT),
            "::",
            stringify!(ThermalConstraint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Processors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_THERMALCHANGE_EVENT),
            "::",
            stringify!(Processors)
        )
    );
}
pub type PPPM_THERMALCHANGE_EVENT = *mut PPM_THERMALCHANGE_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_THERMAL_POLICY_EVENT {
    pub Mode: BYTE,
    pub Processors: DWORD64,
}
#[test]
fn bindgen_test_layout_PPM_THERMAL_POLICY_EVENT() {
    const UNINIT: ::std::mem::MaybeUninit<PPM_THERMAL_POLICY_EVENT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PPM_THERMAL_POLICY_EVENT>(),
        16usize,
        concat!("Size of: ", stringify!(PPM_THERMAL_POLICY_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_THERMAL_POLICY_EVENT>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_THERMAL_POLICY_EVENT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_THERMAL_POLICY_EVENT),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Processors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_THERMAL_POLICY_EVENT),
            "::",
            stringify!(Processors)
        )
    );
}
pub type PPPM_THERMAL_POLICY_EVENT = *mut PPM_THERMAL_POLICY_EVENT;
extern "C" {
    pub static PPM_PERFSTATE_CHANGE_GUID: GUID;
}
extern "C" {
    pub static PPM_PERFSTATE_DOMAIN_CHANGE_GUID: GUID;
}
extern "C" {
    pub static PPM_IDLESTATE_CHANGE_GUID: GUID;
}
extern "C" {
    pub static PPM_PERFSTATES_DATA_GUID: GUID;
}
extern "C" {
    pub static PPM_IDLESTATES_DATA_GUID: GUID;
}
extern "C" {
    pub static PPM_IDLE_ACCOUNTING_GUID: GUID;
}
extern "C" {
    pub static PPM_IDLE_ACCOUNTING_EX_GUID: GUID;
}
extern "C" {
    pub static PPM_THERMALCONSTRAINT_GUID: GUID;
}
extern "C" {
    pub static PPM_PERFMON_PERFSTATE_GUID: GUID;
}
extern "C" {
    pub static PPM_THERMAL_POLICY_CHANGE_GUID: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POWER_ACTION_POLICY {
    pub Action: POWER_ACTION,
    pub Flags: DWORD,
    pub EventCode: DWORD,
}
#[test]
fn bindgen_test_layout_POWER_ACTION_POLICY() {
    const UNINIT: ::std::mem::MaybeUninit<POWER_ACTION_POLICY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<POWER_ACTION_POLICY>(),
        12usize,
        concat!("Size of: ", stringify!(POWER_ACTION_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<POWER_ACTION_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(POWER_ACTION_POLICY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Action) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POWER_ACTION_POLICY),
            "::",
            stringify!(Action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(POWER_ACTION_POLICY),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EventCode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(POWER_ACTION_POLICY),
            "::",
            stringify!(EventCode)
        )
    );
}
pub type PPOWER_ACTION_POLICY = *mut POWER_ACTION_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROCESSOR_IDLESTATE_INFO {
    pub TimeCheck: DWORD,
    pub DemotePercent: BYTE,
    pub PromotePercent: BYTE,
    pub Spare: [BYTE; 2usize],
}
#[test]
fn bindgen_test_layout_PROCESSOR_IDLESTATE_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<PROCESSOR_IDLESTATE_INFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PROCESSOR_IDLESTATE_INFO>(),
        8usize,
        concat!("Size of: ", stringify!(PROCESSOR_IDLESTATE_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<PROCESSOR_IDLESTATE_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(PROCESSOR_IDLESTATE_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeCheck) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_IDLESTATE_INFO),
            "::",
            stringify!(TimeCheck)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DemotePercent) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_IDLESTATE_INFO),
            "::",
            stringify!(DemotePercent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PromotePercent) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_IDLESTATE_INFO),
            "::",
            stringify!(PromotePercent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Spare) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_IDLESTATE_INFO),
            "::",
            stringify!(Spare)
        )
    );
}
pub type PPROCESSOR_IDLESTATE_INFO = *mut PROCESSOR_IDLESTATE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSTEM_POWER_LEVEL {
    pub Enable: BOOLEAN,
    pub Spare: [BYTE; 3usize],
    pub BatteryLevel: DWORD,
    pub PowerPolicy: POWER_ACTION_POLICY,
    pub MinSystemState: SYSTEM_POWER_STATE,
}
#[test]
fn bindgen_test_layout_SYSTEM_POWER_LEVEL() {
    const UNINIT: ::std::mem::MaybeUninit<SYSTEM_POWER_LEVEL> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SYSTEM_POWER_LEVEL>(),
        24usize,
        concat!("Size of: ", stringify!(SYSTEM_POWER_LEVEL))
    );
    assert_eq!(
        ::std::mem::align_of::<SYSTEM_POWER_LEVEL>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSTEM_POWER_LEVEL))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_LEVEL),
            "::",
            stringify!(Enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Spare) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_LEVEL),
            "::",
            stringify!(Spare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BatteryLevel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_LEVEL),
            "::",
            stringify!(BatteryLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PowerPolicy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_LEVEL),
            "::",
            stringify!(PowerPolicy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinSystemState) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_LEVEL),
            "::",
            stringify!(MinSystemState)
        )
    );
}
pub type PSYSTEM_POWER_LEVEL = *mut SYSTEM_POWER_LEVEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_POWER_POLICY {
    pub Revision: DWORD,
    pub PowerButton: POWER_ACTION_POLICY,
    pub SleepButton: POWER_ACTION_POLICY,
    pub LidClose: POWER_ACTION_POLICY,
    pub LidOpenWake: SYSTEM_POWER_STATE,
    pub Reserved: DWORD,
    pub Idle: POWER_ACTION_POLICY,
    pub IdleTimeout: DWORD,
    pub IdleSensitivity: BYTE,
    pub DynamicThrottle: BYTE,
    pub Spare2: [BYTE; 2usize],
    pub MinSleep: SYSTEM_POWER_STATE,
    pub MaxSleep: SYSTEM_POWER_STATE,
    pub ReducedLatencySleep: SYSTEM_POWER_STATE,
    pub WinLogonFlags: DWORD,
    pub Spare3: DWORD,
    pub DozeS4Timeout: DWORD,
    pub BroadcastCapacityResolution: DWORD,
    pub DischargePolicy: [SYSTEM_POWER_LEVEL; 4usize],
    pub VideoTimeout: DWORD,
    pub VideoDimDisplay: BOOLEAN,
    pub VideoReserved: [DWORD; 3usize],
    pub SpindownTimeout: DWORD,
    pub OptimizeForPower: BOOLEAN,
    pub FanThrottleTolerance: BYTE,
    pub ForcedThrottle: BYTE,
    pub MinThrottle: BYTE,
    pub OverThrottled: POWER_ACTION_POLICY,
}
#[test]
fn bindgen_test_layout__SYSTEM_POWER_POLICY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_POWER_POLICY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_POWER_POLICY>(),
        232usize,
        concat!("Size of: ", stringify!(_SYSTEM_POWER_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_POWER_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_POWER_POLICY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Revision) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(Revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PowerButton) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(PowerButton)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SleepButton) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(SleepButton)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LidClose) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(LidClose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LidOpenWake) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(LidOpenWake)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Idle) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(Idle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IdleTimeout) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(IdleTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IdleSensitivity) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(IdleSensitivity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DynamicThrottle) as usize - ptr as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(DynamicThrottle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Spare2) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(Spare2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinSleep) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(MinSleep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxSleep) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(MaxSleep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReducedLatencySleep) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(ReducedLatencySleep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WinLogonFlags) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(WinLogonFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Spare3) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(Spare3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DozeS4Timeout) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(DozeS4Timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BroadcastCapacityResolution) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(BroadcastCapacityResolution)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DischargePolicy) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(DischargePolicy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VideoTimeout) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(VideoTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VideoDimDisplay) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(VideoDimDisplay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VideoReserved) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(VideoReserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SpindownTimeout) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(SpindownTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OptimizeForPower) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(OptimizeForPower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FanThrottleTolerance) as usize - ptr as usize },
        217usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(FanThrottleTolerance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ForcedThrottle) as usize - ptr as usize },
        218usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(ForcedThrottle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinThrottle) as usize - ptr as usize },
        219usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(MinThrottle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OverThrottled) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(OverThrottled)
        )
    );
}
pub type SYSTEM_POWER_POLICY = _SYSTEM_POWER_POLICY;
pub type PSYSTEM_POWER_POLICY = *mut _SYSTEM_POWER_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PROCESSOR_IDLESTATE_POLICY {
    pub Revision: WORD,
    pub Flags: PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1,
    pub PolicyCount: DWORD,
    pub Policy: [PROCESSOR_IDLESTATE_INFO; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1 {
    pub AsWORD: WORD,
    pub __bindgen_anon_1: PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn AllowScaling(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AllowScaling(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Disabled(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Disabled(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AllowScaling: WORD,
        Disabled: WORD,
        Reserved: WORD,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AllowScaling: u16 = unsafe { ::std::mem::transmute(AllowScaling) };
            AllowScaling as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Disabled: u16 = unsafe { ::std::mem::transmute(Disabled) };
            Disabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let Reserved: u16 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AsWORD) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1),
            "::",
            stringify!(AsWORD)
        )
    );
}
#[test]
fn bindgen_test_layout_PROCESSOR_IDLESTATE_POLICY() {
    const UNINIT: ::std::mem::MaybeUninit<PROCESSOR_IDLESTATE_POLICY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PROCESSOR_IDLESTATE_POLICY>(),
        32usize,
        concat!("Size of: ", stringify!(PROCESSOR_IDLESTATE_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<PROCESSOR_IDLESTATE_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(PROCESSOR_IDLESTATE_POLICY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Revision) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_IDLESTATE_POLICY),
            "::",
            stringify!(Revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_IDLESTATE_POLICY),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PolicyCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_IDLESTATE_POLICY),
            "::",
            stringify!(PolicyCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Policy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_IDLESTATE_POLICY),
            "::",
            stringify!(Policy)
        )
    );
}
pub type PPROCESSOR_IDLESTATE_POLICY = *mut PROCESSOR_IDLESTATE_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_POWER_POLICY_INFO {
    pub TimeCheck: DWORD,
    pub DemoteLimit: DWORD,
    pub PromoteLimit: DWORD,
    pub DemotePercent: BYTE,
    pub PromotePercent: BYTE,
    pub Spare: [BYTE; 2usize],
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__PROCESSOR_POWER_POLICY_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<_PROCESSOR_POWER_POLICY_INFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESSOR_POWER_POLICY_INFO>(),
        20usize,
        concat!("Size of: ", stringify!(_PROCESSOR_POWER_POLICY_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESSOR_POWER_POLICY_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_PROCESSOR_POWER_POLICY_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeCheck) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY_INFO),
            "::",
            stringify!(TimeCheck)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DemoteLimit) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY_INFO),
            "::",
            stringify!(DemoteLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PromoteLimit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY_INFO),
            "::",
            stringify!(PromoteLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DemotePercent) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY_INFO),
            "::",
            stringify!(DemotePercent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PromotePercent) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY_INFO),
            "::",
            stringify!(PromotePercent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Spare) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY_INFO),
            "::",
            stringify!(Spare)
        )
    );
}
impl _PROCESSOR_POWER_POLICY_INFO {
    #[inline]
    pub fn AllowDemotion(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowDemotion(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AllowPromotion(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowPromotion(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AllowDemotion: DWORD,
        AllowPromotion: DWORD,
        Reserved: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AllowDemotion: u32 = unsafe { ::std::mem::transmute(AllowDemotion) };
            AllowDemotion as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AllowPromotion: u32 = unsafe { ::std::mem::transmute(AllowPromotion) };
            AllowPromotion as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESSOR_POWER_POLICY_INFO = _PROCESSOR_POWER_POLICY_INFO;
pub type PPROCESSOR_POWER_POLICY_INFO = *mut _PROCESSOR_POWER_POLICY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_POWER_POLICY {
    pub Revision: DWORD,
    pub DynamicThrottle: BYTE,
    pub Spare: [BYTE; 3usize],
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub PolicyCount: DWORD,
    pub Policy: [PROCESSOR_POWER_POLICY_INFO; 3usize],
}
#[test]
fn bindgen_test_layout__PROCESSOR_POWER_POLICY() {
    const UNINIT: ::std::mem::MaybeUninit<_PROCESSOR_POWER_POLICY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESSOR_POWER_POLICY>(),
        76usize,
        concat!("Size of: ", stringify!(_PROCESSOR_POWER_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESSOR_POWER_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(_PROCESSOR_POWER_POLICY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Revision) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY),
            "::",
            stringify!(Revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DynamicThrottle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY),
            "::",
            stringify!(DynamicThrottle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Spare) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY),
            "::",
            stringify!(Spare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PolicyCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY),
            "::",
            stringify!(PolicyCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Policy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY),
            "::",
            stringify!(Policy)
        )
    );
}
impl _PROCESSOR_POWER_POLICY {
    #[inline]
    pub fn DisableCStates(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableCStates(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DisableCStates: DWORD,
        Reserved: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DisableCStates: u32 = unsafe { ::std::mem::transmute(DisableCStates) };
            DisableCStates as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESSOR_POWER_POLICY = _PROCESSOR_POWER_POLICY;
pub type PPROCESSOR_POWER_POLICY = *mut _PROCESSOR_POWER_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PROCESSOR_PERFSTATE_POLICY {
    pub Revision: DWORD,
    pub MaxThrottle: BYTE,
    pub MinThrottle: BYTE,
    pub BusyAdjThreshold: BYTE,
    pub __bindgen_anon_1: PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1,
    pub TimeCheck: DWORD,
    pub IncreaseTime: DWORD,
    pub DecreaseTime: DWORD,
    pub IncreasePercent: DWORD,
    pub DecreasePercent: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1 {
    pub Spare: BYTE,
    pub Flags: PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub AsBYTE: BYTE,
    pub __bindgen_anon_1: PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
        ),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
        ),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NoDomainAccounting(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_NoDomainAccounting(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IncreasePolicy(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_IncreasePolicy(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn DecreasePolicy(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_DecreasePolicy(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NoDomainAccounting: BYTE,
        IncreasePolicy: BYTE,
        DecreasePolicy: BYTE,
        Reserved: BYTE,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NoDomainAccounting: u8 = unsafe { ::std::mem::transmute(NoDomainAccounting) };
            NoDomainAccounting as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let IncreasePolicy: u8 = unsafe { ::std::mem::transmute(IncreasePolicy) };
            IncreasePolicy as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let DecreasePolicy: u8 = unsafe { ::std::mem::transmute(DecreasePolicy) };
            DecreasePolicy as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let Reserved: u8 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AsBYTE) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(AsBYTE)
        )
    );
}
#[test]
fn bindgen_test_layout_PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Spare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1),
            "::",
            stringify!(Spare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout_PROCESSOR_PERFSTATE_POLICY() {
    const UNINIT: ::std::mem::MaybeUninit<PROCESSOR_PERFSTATE_POLICY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PROCESSOR_PERFSTATE_POLICY>(),
        28usize,
        concat!("Size of: ", stringify!(PROCESSOR_PERFSTATE_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<PROCESSOR_PERFSTATE_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(PROCESSOR_PERFSTATE_POLICY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Revision) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY),
            "::",
            stringify!(Revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxThrottle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY),
            "::",
            stringify!(MaxThrottle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinThrottle) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY),
            "::",
            stringify!(MinThrottle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BusyAdjThreshold) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY),
            "::",
            stringify!(BusyAdjThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeCheck) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY),
            "::",
            stringify!(TimeCheck)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IncreaseTime) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY),
            "::",
            stringify!(IncreaseTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DecreaseTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY),
            "::",
            stringify!(DecreaseTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IncreasePercent) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY),
            "::",
            stringify!(IncreasePercent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DecreasePercent) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY),
            "::",
            stringify!(DecreasePercent)
        )
    );
}
pub type PPROCESSOR_PERFSTATE_POLICY = *mut PROCESSOR_PERFSTATE_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ADMINISTRATOR_POWER_POLICY {
    pub MinSleep: SYSTEM_POWER_STATE,
    pub MaxSleep: SYSTEM_POWER_STATE,
    pub MinVideoTimeout: DWORD,
    pub MaxVideoTimeout: DWORD,
    pub MinSpindownTimeout: DWORD,
    pub MaxSpindownTimeout: DWORD,
}
#[test]
fn bindgen_test_layout__ADMINISTRATOR_POWER_POLICY() {
    const UNINIT: ::std::mem::MaybeUninit<_ADMINISTRATOR_POWER_POLICY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ADMINISTRATOR_POWER_POLICY>(),
        24usize,
        concat!("Size of: ", stringify!(_ADMINISTRATOR_POWER_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<_ADMINISTRATOR_POWER_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(_ADMINISTRATOR_POWER_POLICY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinSleep) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ADMINISTRATOR_POWER_POLICY),
            "::",
            stringify!(MinSleep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxSleep) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ADMINISTRATOR_POWER_POLICY),
            "::",
            stringify!(MaxSleep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinVideoTimeout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ADMINISTRATOR_POWER_POLICY),
            "::",
            stringify!(MinVideoTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxVideoTimeout) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ADMINISTRATOR_POWER_POLICY),
            "::",
            stringify!(MaxVideoTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinSpindownTimeout) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ADMINISTRATOR_POWER_POLICY),
            "::",
            stringify!(MinSpindownTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxSpindownTimeout) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ADMINISTRATOR_POWER_POLICY),
            "::",
            stringify!(MaxSpindownTimeout)
        )
    );
}
pub type ADMINISTRATOR_POWER_POLICY = _ADMINISTRATOR_POWER_POLICY;
pub type PADMINISTRATOR_POWER_POLICY = *mut _ADMINISTRATOR_POWER_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSTEM_POWER_CAPABILITIES {
    pub PowerButtonPresent: BOOLEAN,
    pub SleepButtonPresent: BOOLEAN,
    pub LidPresent: BOOLEAN,
    pub SystemS1: BOOLEAN,
    pub SystemS2: BOOLEAN,
    pub SystemS3: BOOLEAN,
    pub SystemS4: BOOLEAN,
    pub SystemS5: BOOLEAN,
    pub HiberFilePresent: BOOLEAN,
    pub FullWake: BOOLEAN,
    pub VideoDimPresent: BOOLEAN,
    pub ApmPresent: BOOLEAN,
    pub UpsPresent: BOOLEAN,
    pub ThermalControl: BOOLEAN,
    pub ProcessorThrottle: BOOLEAN,
    pub ProcessorMinThrottle: BYTE,
    pub ProcessorMaxThrottle: BYTE,
    pub FastSystemS4: BOOLEAN,
    pub spare2: [BYTE; 3usize],
    pub DiskSpinDown: BOOLEAN,
    pub spare3: [BYTE; 8usize],
    pub SystemBatteriesPresent: BOOLEAN,
    pub BatteriesAreShortTerm: BOOLEAN,
    pub BatteryScale: [BATTERY_REPORTING_SCALE; 3usize],
    pub AcOnLineWake: SYSTEM_POWER_STATE,
    pub SoftLidWake: SYSTEM_POWER_STATE,
    pub RtcWake: SYSTEM_POWER_STATE,
    pub MinDeviceWakeState: SYSTEM_POWER_STATE,
    pub DefaultLowLatencyWake: SYSTEM_POWER_STATE,
}
#[test]
fn bindgen_test_layout_SYSTEM_POWER_CAPABILITIES() {
    const UNINIT: ::std::mem::MaybeUninit<SYSTEM_POWER_CAPABILITIES> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SYSTEM_POWER_CAPABILITIES>(),
        76usize,
        concat!("Size of: ", stringify!(SYSTEM_POWER_CAPABILITIES))
    );
    assert_eq!(
        ::std::mem::align_of::<SYSTEM_POWER_CAPABILITIES>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSTEM_POWER_CAPABILITIES))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PowerButtonPresent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(PowerButtonPresent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SleepButtonPresent) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(SleepButtonPresent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LidPresent) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(LidPresent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SystemS1) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(SystemS1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SystemS2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(SystemS2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SystemS3) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(SystemS3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SystemS4) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(SystemS4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SystemS5) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(SystemS5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HiberFilePresent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(HiberFilePresent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FullWake) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(FullWake)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VideoDimPresent) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(VideoDimPresent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApmPresent) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(ApmPresent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UpsPresent) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(UpsPresent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ThermalControl) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(ThermalControl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProcessorThrottle) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(ProcessorThrottle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProcessorMinThrottle) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(ProcessorMinThrottle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProcessorMaxThrottle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(ProcessorMaxThrottle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FastSystemS4) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(FastSystemS4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spare2) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(spare2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DiskSpinDown) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(DiskSpinDown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spare3) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(spare3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SystemBatteriesPresent) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(SystemBatteriesPresent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BatteriesAreShortTerm) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(BatteriesAreShortTerm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BatteryScale) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(BatteryScale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AcOnLineWake) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(AcOnLineWake)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SoftLidWake) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(SoftLidWake)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RtcWake) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(RtcWake)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinDeviceWakeState) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(MinDeviceWakeState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DefaultLowLatencyWake) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(DefaultLowLatencyWake)
        )
    );
}
pub type PSYSTEM_POWER_CAPABILITIES = *mut SYSTEM_POWER_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSTEM_BATTERY_STATE {
    pub AcOnLine: BOOLEAN,
    pub BatteryPresent: BOOLEAN,
    pub Charging: BOOLEAN,
    pub Discharging: BOOLEAN,
    pub Spare1: [BOOLEAN; 4usize],
    pub MaxCapacity: DWORD,
    pub RemainingCapacity: DWORD,
    pub Rate: DWORD,
    pub EstimatedTime: DWORD,
    pub DefaultAlert1: DWORD,
    pub DefaultAlert2: DWORD,
}
#[test]
fn bindgen_test_layout_SYSTEM_BATTERY_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<SYSTEM_BATTERY_STATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SYSTEM_BATTERY_STATE>(),
        32usize,
        concat!("Size of: ", stringify!(SYSTEM_BATTERY_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<SYSTEM_BATTERY_STATE>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSTEM_BATTERY_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AcOnLine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(AcOnLine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BatteryPresent) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(BatteryPresent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Charging) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(Charging)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Discharging) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(Discharging)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Spare1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(Spare1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxCapacity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(MaxCapacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RemainingCapacity) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(RemainingCapacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(Rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EstimatedTime) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(EstimatedTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DefaultAlert1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(DefaultAlert1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DefaultAlert2) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(DefaultAlert2)
        )
    );
}
pub type PSYSTEM_BATTERY_STATE = *mut SYSTEM_BATTERY_STATE;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DOS_HEADER {
    pub e_magic: WORD,
    pub e_cblp: WORD,
    pub e_cp: WORD,
    pub e_crlc: WORD,
    pub e_cparhdr: WORD,
    pub e_minalloc: WORD,
    pub e_maxalloc: WORD,
    pub e_ss: WORD,
    pub e_sp: WORD,
    pub e_csum: WORD,
    pub e_ip: WORD,
    pub e_cs: WORD,
    pub e_lfarlc: WORD,
    pub e_ovno: WORD,
    pub e_res: [WORD; 4usize],
    pub e_oemid: WORD,
    pub e_oeminfo: WORD,
    pub e_res2: [WORD; 10usize],
    pub e_lfanew: LONG,
}
#[test]
fn bindgen_test_layout__IMAGE_DOS_HEADER() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_DOS_HEADER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_DOS_HEADER>(),
        64usize,
        concat!("Size of: ", stringify!(_IMAGE_DOS_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_DOS_HEADER>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_DOS_HEADER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_cblp) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_cblp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_cp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_cp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_crlc) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_crlc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_cparhdr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_cparhdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_minalloc) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_minalloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_maxalloc) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_maxalloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_ss) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_sp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_csum) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_csum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_ip) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_cs) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_cs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_lfarlc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_lfarlc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_ovno) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_ovno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_res) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_res)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_oemid) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_oemid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_oeminfo) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_oeminfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_res2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_res2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_lfanew) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_lfanew)
        )
    );
}
pub type IMAGE_DOS_HEADER = _IMAGE_DOS_HEADER;
pub type PIMAGE_DOS_HEADER = *mut _IMAGE_DOS_HEADER;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_OS2_HEADER {
    pub ne_magic: WORD,
    pub ne_ver: CHAR,
    pub ne_rev: CHAR,
    pub ne_enttab: WORD,
    pub ne_cbenttab: WORD,
    pub ne_crc: LONG,
    pub ne_flags: WORD,
    pub ne_autodata: WORD,
    pub ne_heap: WORD,
    pub ne_stack: WORD,
    pub ne_csip: LONG,
    pub ne_sssp: LONG,
    pub ne_cseg: WORD,
    pub ne_cmod: WORD,
    pub ne_cbnrestab: WORD,
    pub ne_segtab: WORD,
    pub ne_rsrctab: WORD,
    pub ne_restab: WORD,
    pub ne_modtab: WORD,
    pub ne_imptab: WORD,
    pub ne_nrestab: LONG,
    pub ne_cmovent: WORD,
    pub ne_align: WORD,
    pub ne_cres: WORD,
    pub ne_exetyp: BYTE,
    pub ne_flagsothers: BYTE,
    pub ne_pretthunks: WORD,
    pub ne_psegrefbytes: WORD,
    pub ne_swaparea: WORD,
    pub ne_expver: WORD,
}
#[test]
fn bindgen_test_layout__IMAGE_OS2_HEADER() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_OS2_HEADER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_OS2_HEADER>(),
        64usize,
        concat!("Size of: ", stringify!(_IMAGE_OS2_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_OS2_HEADER>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_OS2_HEADER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_ver) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_ver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_rev) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_rev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_enttab) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_enttab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_cbenttab) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_cbenttab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_crc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_crc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_autodata) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_autodata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_heap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_heap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_stack) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_csip) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_csip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_sssp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_sssp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_cseg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_cseg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_cmod) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_cmod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_cbnrestab) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_cbnrestab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_segtab) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_segtab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_rsrctab) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_rsrctab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_restab) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_restab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_modtab) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_modtab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_imptab) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_imptab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_nrestab) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_nrestab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_cmovent) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_cmovent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_align) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_align)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_cres) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_cres)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_exetyp) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_exetyp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_flagsothers) as usize - ptr as usize },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_flagsothers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_pretthunks) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_pretthunks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_psegrefbytes) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_psegrefbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_swaparea) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_swaparea)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ne_expver) as usize - ptr as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OS2_HEADER),
            "::",
            stringify!(ne_expver)
        )
    );
}
pub type IMAGE_OS2_HEADER = _IMAGE_OS2_HEADER;
pub type PIMAGE_OS2_HEADER = *mut _IMAGE_OS2_HEADER;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_VXD_HEADER {
    pub e32_magic: WORD,
    pub e32_border: BYTE,
    pub e32_worder: BYTE,
    pub e32_level: DWORD,
    pub e32_cpu: WORD,
    pub e32_os: WORD,
    pub e32_ver: DWORD,
    pub e32_mflags: DWORD,
    pub e32_mpages: DWORD,
    pub e32_startobj: DWORD,
    pub e32_eip: DWORD,
    pub e32_stackobj: DWORD,
    pub e32_esp: DWORD,
    pub e32_pagesize: DWORD,
    pub e32_lastpagesize: DWORD,
    pub e32_fixupsize: DWORD,
    pub e32_fixupsum: DWORD,
    pub e32_ldrsize: DWORD,
    pub e32_ldrsum: DWORD,
    pub e32_objtab: DWORD,
    pub e32_objcnt: DWORD,
    pub e32_objmap: DWORD,
    pub e32_itermap: DWORD,
    pub e32_rsrctab: DWORD,
    pub e32_rsrccnt: DWORD,
    pub e32_restab: DWORD,
    pub e32_enttab: DWORD,
    pub e32_dirtab: DWORD,
    pub e32_dircnt: DWORD,
    pub e32_fpagetab: DWORD,
    pub e32_frectab: DWORD,
    pub e32_impmod: DWORD,
    pub e32_impmodcnt: DWORD,
    pub e32_impproc: DWORD,
    pub e32_pagesum: DWORD,
    pub e32_datapage: DWORD,
    pub e32_preload: DWORD,
    pub e32_nrestab: DWORD,
    pub e32_cbnrestab: DWORD,
    pub e32_nressum: DWORD,
    pub e32_autodata: DWORD,
    pub e32_debuginfo: DWORD,
    pub e32_debuglen: DWORD,
    pub e32_instpreload: DWORD,
    pub e32_instdemand: DWORD,
    pub e32_heapsize: DWORD,
    pub e32_res3: [BYTE; 12usize],
    pub e32_winresoff: DWORD,
    pub e32_winreslen: DWORD,
    pub e32_devid: WORD,
    pub e32_ddkver: WORD,
}
#[test]
fn bindgen_test_layout__IMAGE_VXD_HEADER() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_VXD_HEADER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_VXD_HEADER>(),
        196usize,
        concat!("Size of: ", stringify!(_IMAGE_VXD_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_VXD_HEADER>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_VXD_HEADER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_border) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_border)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_worder) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_worder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_level) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_cpu) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_cpu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_os) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_os)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_ver) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_ver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_mflags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_mflags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_mpages) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_mpages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_startobj) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_startobj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_eip) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_eip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_stackobj) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_stackobj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_esp) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_esp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_pagesize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_pagesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_lastpagesize) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_lastpagesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_fixupsize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_fixupsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_fixupsum) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_fixupsum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_ldrsize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_ldrsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_ldrsum) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_ldrsum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_objtab) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_objtab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_objcnt) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_objcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_objmap) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_objmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_itermap) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_itermap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_rsrctab) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_rsrctab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_rsrccnt) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_rsrccnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_restab) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_restab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_enttab) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_enttab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_dirtab) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_dirtab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_dircnt) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_dircnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_fpagetab) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_fpagetab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_frectab) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_frectab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_impmod) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_impmod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_impmodcnt) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_impmodcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_impproc) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_impproc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_pagesum) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_pagesum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_datapage) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_datapage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_preload) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_preload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_nrestab) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_nrestab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_cbnrestab) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_cbnrestab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_nressum) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_nressum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_autodata) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_autodata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_debuginfo) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_debuginfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_debuglen) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_debuglen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_instpreload) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_instpreload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_instdemand) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_instdemand)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_heapsize) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_heapsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_res3) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_res3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_winresoff) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_winresoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_winreslen) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_winreslen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_devid) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_devid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e32_ddkver) as usize - ptr as usize },
        194usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_VXD_HEADER),
            "::",
            stringify!(e32_ddkver)
        )
    );
}
pub type IMAGE_VXD_HEADER = _IMAGE_VXD_HEADER;
pub type PIMAGE_VXD_HEADER = *mut _IMAGE_VXD_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_FILE_HEADER {
    pub Machine: WORD,
    pub NumberOfSections: WORD,
    pub TimeDateStamp: DWORD,
    pub PointerToSymbolTable: DWORD,
    pub NumberOfSymbols: DWORD,
    pub SizeOfOptionalHeader: WORD,
    pub Characteristics: WORD,
}
#[test]
fn bindgen_test_layout__IMAGE_FILE_HEADER() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_FILE_HEADER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_FILE_HEADER>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_FILE_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_FILE_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_FILE_HEADER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Machine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(Machine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfSections) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(NumberOfSections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PointerToSymbolTable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(PointerToSymbolTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfSymbols) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(NumberOfSymbols)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfOptionalHeader) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(SizeOfOptionalHeader)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Characteristics) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(Characteristics)
        )
    );
}
pub type IMAGE_FILE_HEADER = _IMAGE_FILE_HEADER;
pub type PIMAGE_FILE_HEADER = *mut _IMAGE_FILE_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DATA_DIRECTORY {
    pub VirtualAddress: DWORD,
    pub Size: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_DATA_DIRECTORY() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_DATA_DIRECTORY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_DATA_DIRECTORY>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_DATA_DIRECTORY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_DATA_DIRECTORY>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_DATA_DIRECTORY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VirtualAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DATA_DIRECTORY),
            "::",
            stringify!(VirtualAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DATA_DIRECTORY),
            "::",
            stringify!(Size)
        )
    );
}
pub type IMAGE_DATA_DIRECTORY = _IMAGE_DATA_DIRECTORY;
pub type PIMAGE_DATA_DIRECTORY = *mut _IMAGE_DATA_DIRECTORY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_OPTIONAL_HEADER {
    pub Magic: WORD,
    pub MajorLinkerVersion: BYTE,
    pub MinorLinkerVersion: BYTE,
    pub SizeOfCode: DWORD,
    pub SizeOfInitializedData: DWORD,
    pub SizeOfUninitializedData: DWORD,
    pub AddressOfEntryPoint: DWORD,
    pub BaseOfCode: DWORD,
    pub BaseOfData: DWORD,
    pub ImageBase: DWORD,
    pub SectionAlignment: DWORD,
    pub FileAlignment: DWORD,
    pub MajorOperatingSystemVersion: WORD,
    pub MinorOperatingSystemVersion: WORD,
    pub MajorImageVersion: WORD,
    pub MinorImageVersion: WORD,
    pub MajorSubsystemVersion: WORD,
    pub MinorSubsystemVersion: WORD,
    pub Win32VersionValue: DWORD,
    pub SizeOfImage: DWORD,
    pub SizeOfHeaders: DWORD,
    pub CheckSum: DWORD,
    pub Subsystem: WORD,
    pub DllCharacteristics: WORD,
    pub SizeOfStackReserve: DWORD,
    pub SizeOfStackCommit: DWORD,
    pub SizeOfHeapReserve: DWORD,
    pub SizeOfHeapCommit: DWORD,
    pub LoaderFlags: DWORD,
    pub NumberOfRvaAndSizes: DWORD,
    pub DataDirectory: [IMAGE_DATA_DIRECTORY; 16usize],
}
#[test]
fn bindgen_test_layout__IMAGE_OPTIONAL_HEADER() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_OPTIONAL_HEADER> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_OPTIONAL_HEADER>(),
        224usize,
        concat!("Size of: ", stringify!(_IMAGE_OPTIONAL_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_OPTIONAL_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_OPTIONAL_HEADER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(Magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MajorLinkerVersion) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MajorLinkerVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinorLinkerVersion) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MinorLinkerVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfCode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfInitializedData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfInitializedData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfUninitializedData) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfUninitializedData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddressOfEntryPoint) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(AddressOfEntryPoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BaseOfCode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(BaseOfCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BaseOfData) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(BaseOfData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ImageBase) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(ImageBase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SectionAlignment) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SectionAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileAlignment) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(FileAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MajorOperatingSystemVersion) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MajorOperatingSystemVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinorOperatingSystemVersion) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MinorOperatingSystemVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MajorImageVersion) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MajorImageVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinorImageVersion) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MinorImageVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MajorSubsystemVersion) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MajorSubsystemVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinorSubsystemVersion) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MinorSubsystemVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Win32VersionValue) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(Win32VersionValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfImage) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfImage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfHeaders) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfHeaders)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CheckSum) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(CheckSum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Subsystem) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(Subsystem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DllCharacteristics) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(DllCharacteristics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfStackReserve) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfStackReserve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfStackCommit) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfStackCommit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfHeapReserve) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfHeapReserve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfHeapCommit) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfHeapCommit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LoaderFlags) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(LoaderFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfRvaAndSizes) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(NumberOfRvaAndSizes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataDirectory) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(DataDirectory)
        )
    );
}
pub type IMAGE_OPTIONAL_HEADER32 = _IMAGE_OPTIONAL_HEADER;
pub type PIMAGE_OPTIONAL_HEADER32 = *mut _IMAGE_OPTIONAL_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ROM_OPTIONAL_HEADER {
    pub Magic: WORD,
    pub MajorLinkerVersion: BYTE,
    pub MinorLinkerVersion: BYTE,
    pub SizeOfCode: DWORD,
    pub SizeOfInitializedData: DWORD,
    pub SizeOfUninitializedData: DWORD,
    pub AddressOfEntryPoint: DWORD,
    pub BaseOfCode: DWORD,
    pub BaseOfData: DWORD,
    pub BaseOfBss: DWORD,
    pub GprMask: DWORD,
    pub CprMask: [DWORD; 4usize],
    pub GpValue: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_ROM_OPTIONAL_HEADER() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_ROM_OPTIONAL_HEADER> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ROM_OPTIONAL_HEADER>(),
        56usize,
        concat!("Size of: ", stringify!(_IMAGE_ROM_OPTIONAL_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ROM_OPTIONAL_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_ROM_OPTIONAL_HEADER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(Magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MajorLinkerVersion) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(MajorLinkerVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinorLinkerVersion) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(MinorLinkerVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfCode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfInitializedData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfInitializedData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfUninitializedData) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfUninitializedData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddressOfEntryPoint) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(AddressOfEntryPoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BaseOfCode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(BaseOfCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BaseOfData) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(BaseOfData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BaseOfBss) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(BaseOfBss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GprMask) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(GprMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CprMask) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(CprMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GpValue) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(GpValue)
        )
    );
}
pub type IMAGE_ROM_OPTIONAL_HEADER = _IMAGE_ROM_OPTIONAL_HEADER;
pub type PIMAGE_ROM_OPTIONAL_HEADER = *mut _IMAGE_ROM_OPTIONAL_HEADER;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_OPTIONAL_HEADER64 {
    pub Magic: WORD,
    pub MajorLinkerVersion: BYTE,
    pub MinorLinkerVersion: BYTE,
    pub SizeOfCode: DWORD,
    pub SizeOfInitializedData: DWORD,
    pub SizeOfUninitializedData: DWORD,
    pub AddressOfEntryPoint: DWORD,
    pub BaseOfCode: DWORD,
    pub ImageBase: ULONGLONG,
    pub SectionAlignment: DWORD,
    pub FileAlignment: DWORD,
    pub MajorOperatingSystemVersion: WORD,
    pub MinorOperatingSystemVersion: WORD,
    pub MajorImageVersion: WORD,
    pub MinorImageVersion: WORD,
    pub MajorSubsystemVersion: WORD,
    pub MinorSubsystemVersion: WORD,
    pub Win32VersionValue: DWORD,
    pub SizeOfImage: DWORD,
    pub SizeOfHeaders: DWORD,
    pub CheckSum: DWORD,
    pub Subsystem: WORD,
    pub DllCharacteristics: WORD,
    pub SizeOfStackReserve: ULONGLONG,
    pub SizeOfStackCommit: ULONGLONG,
    pub SizeOfHeapReserve: ULONGLONG,
    pub SizeOfHeapCommit: ULONGLONG,
    pub LoaderFlags: DWORD,
    pub NumberOfRvaAndSizes: DWORD,
    pub DataDirectory: [IMAGE_DATA_DIRECTORY; 16usize],
}
#[test]
fn bindgen_test_layout__IMAGE_OPTIONAL_HEADER64() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_OPTIONAL_HEADER64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_OPTIONAL_HEADER64>(),
        240usize,
        concat!("Size of: ", stringify!(_IMAGE_OPTIONAL_HEADER64))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_OPTIONAL_HEADER64>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_OPTIONAL_HEADER64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(Magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MajorLinkerVersion) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(MajorLinkerVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinorLinkerVersion) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(MinorLinkerVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfCode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(SizeOfCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfInitializedData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(SizeOfInitializedData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfUninitializedData) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(SizeOfUninitializedData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddressOfEntryPoint) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(AddressOfEntryPoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BaseOfCode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(BaseOfCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ImageBase) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(ImageBase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SectionAlignment) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(SectionAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileAlignment) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(FileAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MajorOperatingSystemVersion) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(MajorOperatingSystemVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinorOperatingSystemVersion) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(MinorOperatingSystemVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MajorImageVersion) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(MajorImageVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinorImageVersion) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(MinorImageVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MajorSubsystemVersion) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(MajorSubsystemVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinorSubsystemVersion) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(MinorSubsystemVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Win32VersionValue) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(Win32VersionValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfImage) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(SizeOfImage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfHeaders) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(SizeOfHeaders)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CheckSum) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(CheckSum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Subsystem) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(Subsystem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DllCharacteristics) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(DllCharacteristics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfStackReserve) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(SizeOfStackReserve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfStackCommit) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(SizeOfStackCommit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfHeapReserve) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(SizeOfHeapReserve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfHeapCommit) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(SizeOfHeapCommit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LoaderFlags) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(LoaderFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfRvaAndSizes) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(NumberOfRvaAndSizes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataDirectory) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER64),
            "::",
            stringify!(DataDirectory)
        )
    );
}
pub type IMAGE_OPTIONAL_HEADER64 = _IMAGE_OPTIONAL_HEADER64;
pub type PIMAGE_OPTIONAL_HEADER64 = *mut _IMAGE_OPTIONAL_HEADER64;
pub type IMAGE_OPTIONAL_HEADER = IMAGE_OPTIONAL_HEADER64;
pub type PIMAGE_OPTIONAL_HEADER = PIMAGE_OPTIONAL_HEADER64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_NT_HEADERS64 {
    pub Signature: DWORD,
    pub FileHeader: IMAGE_FILE_HEADER,
    pub OptionalHeader: IMAGE_OPTIONAL_HEADER64,
}
#[test]
fn bindgen_test_layout__IMAGE_NT_HEADERS64() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_NT_HEADERS64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_NT_HEADERS64>(),
        264usize,
        concat!("Size of: ", stringify!(_IMAGE_NT_HEADERS64))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_NT_HEADERS64>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_NT_HEADERS64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Signature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_NT_HEADERS64),
            "::",
            stringify!(Signature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileHeader) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_NT_HEADERS64),
            "::",
            stringify!(FileHeader)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OptionalHeader) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_NT_HEADERS64),
            "::",
            stringify!(OptionalHeader)
        )
    );
}
pub type IMAGE_NT_HEADERS64 = _IMAGE_NT_HEADERS64;
pub type PIMAGE_NT_HEADERS64 = *mut _IMAGE_NT_HEADERS64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_NT_HEADERS {
    pub Signature: DWORD,
    pub FileHeader: IMAGE_FILE_HEADER,
    pub OptionalHeader: IMAGE_OPTIONAL_HEADER32,
}
#[test]
fn bindgen_test_layout__IMAGE_NT_HEADERS() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_NT_HEADERS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_NT_HEADERS>(),
        248usize,
        concat!("Size of: ", stringify!(_IMAGE_NT_HEADERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_NT_HEADERS>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_NT_HEADERS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Signature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_NT_HEADERS),
            "::",
            stringify!(Signature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileHeader) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_NT_HEADERS),
            "::",
            stringify!(FileHeader)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OptionalHeader) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_NT_HEADERS),
            "::",
            stringify!(OptionalHeader)
        )
    );
}
pub type IMAGE_NT_HEADERS32 = _IMAGE_NT_HEADERS;
pub type PIMAGE_NT_HEADERS32 = *mut _IMAGE_NT_HEADERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ROM_HEADERS {
    pub FileHeader: IMAGE_FILE_HEADER,
    pub OptionalHeader: IMAGE_ROM_OPTIONAL_HEADER,
}
#[test]
fn bindgen_test_layout__IMAGE_ROM_HEADERS() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_ROM_HEADERS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ROM_HEADERS>(),
        76usize,
        concat!("Size of: ", stringify!(_IMAGE_ROM_HEADERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ROM_HEADERS>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_ROM_HEADERS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileHeader) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_HEADERS),
            "::",
            stringify!(FileHeader)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OptionalHeader) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_HEADERS),
            "::",
            stringify!(OptionalHeader)
        )
    );
}
pub type IMAGE_ROM_HEADERS = _IMAGE_ROM_HEADERS;
pub type PIMAGE_ROM_HEADERS = *mut _IMAGE_ROM_HEADERS;
pub type IMAGE_NT_HEADERS = IMAGE_NT_HEADERS64;
pub type PIMAGE_NT_HEADERS = PIMAGE_NT_HEADERS64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANON_OBJECT_HEADER {
    pub Sig1: WORD,
    pub Sig2: WORD,
    pub Version: WORD,
    pub Machine: WORD,
    pub TimeDateStamp: DWORD,
    pub ClassID: CLSID,
    pub SizeOfData: DWORD,
}
#[test]
fn bindgen_test_layout_ANON_OBJECT_HEADER() {
    const UNINIT: ::std::mem::MaybeUninit<ANON_OBJECT_HEADER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ANON_OBJECT_HEADER>(),
        32usize,
        concat!("Size of: ", stringify!(ANON_OBJECT_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<ANON_OBJECT_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(ANON_OBJECT_HEADER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sig1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER),
            "::",
            stringify!(Sig1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sig2) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER),
            "::",
            stringify!(Sig2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Machine) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER),
            "::",
            stringify!(Machine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClassID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER),
            "::",
            stringify!(ClassID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfData) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER),
            "::",
            stringify!(SizeOfData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANON_OBJECT_HEADER_V2 {
    pub Sig1: WORD,
    pub Sig2: WORD,
    pub Version: WORD,
    pub Machine: WORD,
    pub TimeDateStamp: DWORD,
    pub ClassID: CLSID,
    pub SizeOfData: DWORD,
    pub Flags: DWORD,
    pub MetaDataSize: DWORD,
    pub MetaDataOffset: DWORD,
}
#[test]
fn bindgen_test_layout_ANON_OBJECT_HEADER_V2() {
    const UNINIT: ::std::mem::MaybeUninit<ANON_OBJECT_HEADER_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ANON_OBJECT_HEADER_V2>(),
        44usize,
        concat!("Size of: ", stringify!(ANON_OBJECT_HEADER_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<ANON_OBJECT_HEADER_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(ANON_OBJECT_HEADER_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sig1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_V2),
            "::",
            stringify!(Sig1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sig2) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_V2),
            "::",
            stringify!(Sig2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_V2),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Machine) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_V2),
            "::",
            stringify!(Machine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_V2),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClassID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_V2),
            "::",
            stringify!(ClassID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfData) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_V2),
            "::",
            stringify!(SizeOfData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_V2),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MetaDataSize) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_V2),
            "::",
            stringify!(MetaDataSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MetaDataOffset) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_V2),
            "::",
            stringify!(MetaDataOffset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANON_OBJECT_HEADER_BIGOBJ {
    pub Sig1: WORD,
    pub Sig2: WORD,
    pub Version: WORD,
    pub Machine: WORD,
    pub TimeDateStamp: DWORD,
    pub ClassID: CLSID,
    pub SizeOfData: DWORD,
    pub Flags: DWORD,
    pub MetaDataSize: DWORD,
    pub MetaDataOffset: DWORD,
    pub NumberOfSections: DWORD,
    pub PointerToSymbolTable: DWORD,
    pub NumberOfSymbols: DWORD,
}
#[test]
fn bindgen_test_layout_ANON_OBJECT_HEADER_BIGOBJ() {
    const UNINIT: ::std::mem::MaybeUninit<ANON_OBJECT_HEADER_BIGOBJ> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ANON_OBJECT_HEADER_BIGOBJ>(),
        56usize,
        concat!("Size of: ", stringify!(ANON_OBJECT_HEADER_BIGOBJ))
    );
    assert_eq!(
        ::std::mem::align_of::<ANON_OBJECT_HEADER_BIGOBJ>(),
        4usize,
        concat!("Alignment of ", stringify!(ANON_OBJECT_HEADER_BIGOBJ))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sig1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(Sig1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sig2) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(Sig2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Machine) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(Machine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClassID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(ClassID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfData) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(SizeOfData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MetaDataSize) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(MetaDataSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MetaDataOffset) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(MetaDataOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfSections) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(NumberOfSections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PointerToSymbolTable) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(PointerToSymbolTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfSymbols) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(NumberOfSymbols)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_SECTION_HEADER {
    pub Name: [BYTE; 8usize],
    pub Misc: _IMAGE_SECTION_HEADER__bindgen_ty_1,
    pub VirtualAddress: DWORD,
    pub SizeOfRawData: DWORD,
    pub PointerToRawData: DWORD,
    pub PointerToRelocations: DWORD,
    pub PointerToLinenumbers: DWORD,
    pub NumberOfRelocations: WORD,
    pub NumberOfLinenumbers: WORD,
    pub Characteristics: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_SECTION_HEADER__bindgen_ty_1 {
    pub PhysicalAddress: DWORD,
    pub VirtualSize: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_SECTION_HEADER__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_SECTION_HEADER__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_SECTION_HEADER__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_IMAGE_SECTION_HEADER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_SECTION_HEADER__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_SECTION_HEADER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PhysicalAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER__bindgen_ty_1),
            "::",
            stringify!(PhysicalAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VirtualSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER__bindgen_ty_1),
            "::",
            stringify!(VirtualSize)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_SECTION_HEADER() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_SECTION_HEADER> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_SECTION_HEADER>(),
        40usize,
        concat!("Size of: ", stringify!(_IMAGE_SECTION_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_SECTION_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_SECTION_HEADER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Misc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(Misc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VirtualAddress) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(VirtualAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfRawData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(SizeOfRawData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PointerToRawData) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(PointerToRawData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PointerToRelocations) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(PointerToRelocations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PointerToLinenumbers) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(PointerToLinenumbers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfRelocations) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(NumberOfRelocations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfLinenumbers) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(NumberOfLinenumbers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Characteristics) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(Characteristics)
        )
    );
}
pub type IMAGE_SECTION_HEADER = _IMAGE_SECTION_HEADER;
pub type PIMAGE_SECTION_HEADER = *mut _IMAGE_SECTION_HEADER;
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub struct _IMAGE_SYMBOL {
    pub N: _IMAGE_SYMBOL__bindgen_ty_1,
    pub Value: DWORD,
    pub SectionNumber: SHORT,
    pub Type: WORD,
    pub StorageClass: BYTE,
    pub NumberOfAuxSymbols: BYTE,
}
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub union _IMAGE_SYMBOL__bindgen_ty_1 {
    pub ShortName: [BYTE; 8usize],
    pub Name: _IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1,
    pub LongName: [DWORD; 2usize],
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1 {
    pub Short: DWORD,
    pub Long: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Short) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Short)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Long) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Long)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_SYMBOL__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_SYMBOL__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_SYMBOL__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_SYMBOL__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_SYMBOL__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_SYMBOL__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ShortName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL__bindgen_ty_1),
            "::",
            stringify!(ShortName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL__bindgen_ty_1),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LongName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL__bindgen_ty_1),
            "::",
            stringify!(LongName)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_SYMBOL() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_SYMBOL> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_SYMBOL>(),
        18usize,
        concat!("Size of: ", stringify!(_IMAGE_SYMBOL))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_SYMBOL>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_SYMBOL))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).N) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL),
            "::",
            stringify!(Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SectionNumber) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL),
            "::",
            stringify!(SectionNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StorageClass) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL),
            "::",
            stringify!(StorageClass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfAuxSymbols) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL),
            "::",
            stringify!(NumberOfAuxSymbols)
        )
    );
}
pub type IMAGE_SYMBOL = _IMAGE_SYMBOL;
pub type PIMAGE_SYMBOL = *mut IMAGE_SYMBOL;
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub struct _IMAGE_SYMBOL_EX {
    pub N: _IMAGE_SYMBOL_EX__bindgen_ty_1,
    pub Value: DWORD,
    pub SectionNumber: LONG,
    pub Type: WORD,
    pub StorageClass: BYTE,
    pub NumberOfAuxSymbols: BYTE,
}
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub union _IMAGE_SYMBOL_EX__bindgen_ty_1 {
    pub ShortName: [BYTE; 8usize],
    pub Name: _IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1,
    pub LongName: [DWORD; 2usize],
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1 {
    pub Short: DWORD,
    pub Long: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Short) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Short)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Long) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Long)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_SYMBOL_EX__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_SYMBOL_EX__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_SYMBOL_EX__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_SYMBOL_EX__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_SYMBOL_EX__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_SYMBOL_EX__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ShortName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL_EX__bindgen_ty_1),
            "::",
            stringify!(ShortName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL_EX__bindgen_ty_1),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LongName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL_EX__bindgen_ty_1),
            "::",
            stringify!(LongName)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_SYMBOL_EX() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_SYMBOL_EX> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_SYMBOL_EX>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_SYMBOL_EX))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_SYMBOL_EX>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_SYMBOL_EX))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).N) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL_EX),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL_EX),
            "::",
            stringify!(Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SectionNumber) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL_EX),
            "::",
            stringify!(SectionNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL_EX),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StorageClass) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL_EX),
            "::",
            stringify!(StorageClass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfAuxSymbols) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SYMBOL_EX),
            "::",
            stringify!(NumberOfAuxSymbols)
        )
    );
}
pub type IMAGE_SYMBOL_EX = _IMAGE_SYMBOL_EX;
pub type PIMAGE_SYMBOL_EX = *mut _IMAGE_SYMBOL_EX;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct IMAGE_AUX_SYMBOL_TOKEN_DEF {
    pub bAuxType: BYTE,
    pub bReserved: BYTE,
    pub SymbolTableIndex: DWORD,
    pub rgbReserved: [BYTE; 12usize],
}
#[test]
fn bindgen_test_layout_IMAGE_AUX_SYMBOL_TOKEN_DEF() {
    const UNINIT: ::std::mem::MaybeUninit<IMAGE_AUX_SYMBOL_TOKEN_DEF> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMAGE_AUX_SYMBOL_TOKEN_DEF>(),
        18usize,
        concat!("Size of: ", stringify!(IMAGE_AUX_SYMBOL_TOKEN_DEF))
    );
    assert_eq!(
        ::std::mem::align_of::<IMAGE_AUX_SYMBOL_TOKEN_DEF>(),
        2usize,
        concat!("Alignment of ", stringify!(IMAGE_AUX_SYMBOL_TOKEN_DEF))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bAuxType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_AUX_SYMBOL_TOKEN_DEF),
            "::",
            stringify!(bAuxType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bReserved) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_AUX_SYMBOL_TOKEN_DEF),
            "::",
            stringify!(bReserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SymbolTableIndex) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_AUX_SYMBOL_TOKEN_DEF),
            "::",
            stringify!(SymbolTableIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgbReserved) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_AUX_SYMBOL_TOKEN_DEF),
            "::",
            stringify!(rgbReserved)
        )
    );
}
pub type PIMAGE_AUX_SYMBOL_TOKEN_DEF = *mut IMAGE_AUX_SYMBOL_TOKEN_DEF;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_AUX_SYMBOL {
    pub Sym: _IMAGE_AUX_SYMBOL__bindgen_ty_1,
    pub File: _IMAGE_AUX_SYMBOL__bindgen_ty_2,
    pub Section: _IMAGE_AUX_SYMBOL__bindgen_ty_3,
    pub TokenDef: IMAGE_AUX_SYMBOL_TOKEN_DEF,
    pub CRC: _IMAGE_AUX_SYMBOL__bindgen_ty_4,
}
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_1 {
    pub TagIndex: DWORD,
    pub Misc: _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1,
    pub FcnAry: _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2,
    pub TvIndex: WORD,
}
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub union _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1 {
    pub LnSz: _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub TotalSize: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub Linenumber: WORD,
    pub Size: WORD,
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Linenumber) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Linenumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Size)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LnSz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(LnSz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(TotalSize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2 {
    pub Function: _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub Array: _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub PointerToLinenumber: DWORD,
    pub PointerToNextFunction: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PointerToLinenumber) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(PointerToLinenumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PointerToNextFunction) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(PointerToNextFunction)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 {
    pub Dimension: [WORD; 4usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<
        _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Dimension) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(Dimension)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Function) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Array)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_AUX_SYMBOL__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1>(),
        18usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TagIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1),
            "::",
            stringify!(TagIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Misc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1),
            "::",
            stringify!(Misc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FcnAry) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1),
            "::",
            stringify!(FcnAry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TvIndex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1),
            "::",
            stringify!(TvIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_2 {
    pub Name: [BYTE; 18usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_AUX_SYMBOL__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_2>(),
        18usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_2),
            "::",
            stringify!(Name)
        )
    );
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_3 {
    pub Length: DWORD,
    pub NumberOfRelocations: WORD,
    pub NumberOfLinenumbers: WORD,
    pub CheckSum: DWORD,
    pub Number: SHORT,
    pub Selection: BYTE,
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_AUX_SYMBOL__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_3>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_3),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfRelocations) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_3),
            "::",
            stringify!(NumberOfRelocations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfLinenumbers) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_3),
            "::",
            stringify!(NumberOfLinenumbers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CheckSum) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_3),
            "::",
            stringify!(CheckSum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Number) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_3),
            "::",
            stringify!(Number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Selection) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_3),
            "::",
            stringify!(Selection)
        )
    );
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_4 {
    pub crc: DWORD,
    pub rgbReserved: [BYTE; 14usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_AUX_SYMBOL__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_4>(),
        18usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_4>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_4),
            "::",
            stringify!(crc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgbReserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_4),
            "::",
            stringify!(rgbReserved)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_AUX_SYMBOL> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL>(),
        18usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_AUX_SYMBOL))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sym) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL),
            "::",
            stringify!(Sym)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).File) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL),
            "::",
            stringify!(File)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Section) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL),
            "::",
            stringify!(Section)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TokenDef) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL),
            "::",
            stringify!(TokenDef)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CRC) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL),
            "::",
            stringify!(CRC)
        )
    );
}
pub type IMAGE_AUX_SYMBOL = _IMAGE_AUX_SYMBOL;
pub type PIMAGE_AUX_SYMBOL = *mut _IMAGE_AUX_SYMBOL;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_AUX_SYMBOL_EX {
    pub Sym: _IMAGE_AUX_SYMBOL_EX__bindgen_ty_1,
    pub File: _IMAGE_AUX_SYMBOL_EX__bindgen_ty_2,
    pub Section: _IMAGE_AUX_SYMBOL_EX__bindgen_ty_3,
    pub __bindgen_anon_1: _IMAGE_AUX_SYMBOL_EX__bindgen_ty_4,
    pub CRC: _IMAGE_AUX_SYMBOL_EX__bindgen_ty_5,
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL_EX__bindgen_ty_1 {
    pub WeakDefaultSymIndex: DWORD,
    pub WeakSearchType: DWORD,
    pub rgbReserved: [BYTE; 12usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL_EX__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WeakDefaultSymIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_1),
            "::",
            stringify!(WeakDefaultSymIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WeakSearchType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_1),
            "::",
            stringify!(WeakSearchType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgbReserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_1),
            "::",
            stringify!(rgbReserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL_EX__bindgen_ty_2 {
    pub Name: [BYTE; 20usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL_EX__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_2>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_2),
            "::",
            stringify!(Name)
        )
    );
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL_EX__bindgen_ty_3 {
    pub Length: DWORD,
    pub NumberOfRelocations: WORD,
    pub NumberOfLinenumbers: WORD,
    pub CheckSum: DWORD,
    pub Number: SHORT,
    pub Selection: BYTE,
    pub bReserved: BYTE,
    pub HighNumber: SHORT,
    pub rgbReserved: [BYTE; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL_EX__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfRelocations) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3),
            "::",
            stringify!(NumberOfRelocations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfLinenumbers) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3),
            "::",
            stringify!(NumberOfLinenumbers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CheckSum) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3),
            "::",
            stringify!(CheckSum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Number) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3),
            "::",
            stringify!(Number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Selection) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3),
            "::",
            stringify!(Selection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bReserved) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3),
            "::",
            stringify!(bReserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighNumber) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3),
            "::",
            stringify!(HighNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgbReserved) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3),
            "::",
            stringify!(rgbReserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL_EX__bindgen_ty_4 {
    pub TokenDef: IMAGE_AUX_SYMBOL_TOKEN_DEF,
    pub rgbReserved: [BYTE; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL_EX__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_4>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_4>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TokenDef) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_4),
            "::",
            stringify!(TokenDef)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgbReserved) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_4),
            "::",
            stringify!(rgbReserved)
        )
    );
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL_EX__bindgen_ty_5 {
    pub crc: DWORD,
    pub rgbReserved: [BYTE; 16usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL_EX__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_5>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_5>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_5),
            "::",
            stringify!(crc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgbReserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_5),
            "::",
            stringify!(rgbReserved)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL_EX() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_AUX_SYMBOL_EX> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL_EX>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL_EX))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL_EX>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_AUX_SYMBOL_EX))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sym) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX),
            "::",
            stringify!(Sym)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).File) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX),
            "::",
            stringify!(File)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Section) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX),
            "::",
            stringify!(Section)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CRC) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX),
            "::",
            stringify!(CRC)
        )
    );
}
pub type IMAGE_AUX_SYMBOL_EX = _IMAGE_AUX_SYMBOL_EX;
pub type PIMAGE_AUX_SYMBOL_EX = *mut _IMAGE_AUX_SYMBOL_EX;
pub const IMAGE_AUX_SYMBOL_TYPE_IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF: IMAGE_AUX_SYMBOL_TYPE = 1;
pub type IMAGE_AUX_SYMBOL_TYPE = ::std::os::raw::c_uint;
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub struct _IMAGE_RELOCATION {
    pub __bindgen_anon_1: _IMAGE_RELOCATION__bindgen_ty_1,
    pub SymbolTableIndex: DWORD,
    pub Type: WORD,
}
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub union _IMAGE_RELOCATION__bindgen_ty_1 {
    pub VirtualAddress: DWORD,
    pub RelocCount: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_RELOCATION__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_RELOCATION__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RELOCATION__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_IMAGE_RELOCATION__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RELOCATION__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_RELOCATION__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VirtualAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RELOCATION__bindgen_ty_1),
            "::",
            stringify!(VirtualAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RelocCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RELOCATION__bindgen_ty_1),
            "::",
            stringify!(RelocCount)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_RELOCATION() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_RELOCATION> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RELOCATION>(),
        10usize,
        concat!("Size of: ", stringify!(_IMAGE_RELOCATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RELOCATION>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_RELOCATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SymbolTableIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RELOCATION),
            "::",
            stringify!(SymbolTableIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RELOCATION),
            "::",
            stringify!(Type)
        )
    );
}
pub type IMAGE_RELOCATION = _IMAGE_RELOCATION;
pub type PIMAGE_RELOCATION = *mut IMAGE_RELOCATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_LINENUMBER {
    pub Type: _IMAGE_LINENUMBER__bindgen_ty_1,
    pub Linenumber: WORD,
}
#[repr(C, packed(2))]
#[derive(Copy, Clone)]
pub union _IMAGE_LINENUMBER__bindgen_ty_1 {
    pub SymbolTableIndex: DWORD,
    pub VirtualAddress: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_LINENUMBER__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_LINENUMBER__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_LINENUMBER__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_IMAGE_LINENUMBER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_LINENUMBER__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_LINENUMBER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SymbolTableIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LINENUMBER__bindgen_ty_1),
            "::",
            stringify!(SymbolTableIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VirtualAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LINENUMBER__bindgen_ty_1),
            "::",
            stringify!(VirtualAddress)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_LINENUMBER() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_LINENUMBER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_LINENUMBER>(),
        6usize,
        concat!("Size of: ", stringify!(_IMAGE_LINENUMBER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_LINENUMBER>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_LINENUMBER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LINENUMBER),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Linenumber) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LINENUMBER),
            "::",
            stringify!(Linenumber)
        )
    );
}
pub type IMAGE_LINENUMBER = _IMAGE_LINENUMBER;
pub type PIMAGE_LINENUMBER = *mut IMAGE_LINENUMBER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_BASE_RELOCATION {
    pub VirtualAddress: DWORD,
    pub SizeOfBlock: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_BASE_RELOCATION() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_BASE_RELOCATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_BASE_RELOCATION>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_BASE_RELOCATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_BASE_RELOCATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_BASE_RELOCATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VirtualAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_BASE_RELOCATION),
            "::",
            stringify!(VirtualAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfBlock) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_BASE_RELOCATION),
            "::",
            stringify!(SizeOfBlock)
        )
    );
}
pub type IMAGE_BASE_RELOCATION = _IMAGE_BASE_RELOCATION;
pub type PIMAGE_BASE_RELOCATION = *mut IMAGE_BASE_RELOCATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    pub Name: [BYTE; 16usize],
    pub Date: [BYTE; 12usize],
    pub UserID: [BYTE; 6usize],
    pub GroupID: [BYTE; 6usize],
    pub Mode: [BYTE; 8usize],
    pub Size: [BYTE; 10usize],
    pub EndHeader: [BYTE; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_ARCHIVE_MEMBER_HEADER() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_ARCHIVE_MEMBER_HEADER> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ARCHIVE_MEMBER_HEADER>(),
        60usize,
        concat!("Size of: ", stringify!(_IMAGE_ARCHIVE_MEMBER_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ARCHIVE_MEMBER_HEADER>(),
        1usize,
        concat!("Alignment of ", stringify!(_IMAGE_ARCHIVE_MEMBER_HEADER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARCHIVE_MEMBER_HEADER),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Date) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARCHIVE_MEMBER_HEADER),
            "::",
            stringify!(Date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserID) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARCHIVE_MEMBER_HEADER),
            "::",
            stringify!(UserID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GroupID) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARCHIVE_MEMBER_HEADER),
            "::",
            stringify!(GroupID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARCHIVE_MEMBER_HEADER),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARCHIVE_MEMBER_HEADER),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndHeader) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARCHIVE_MEMBER_HEADER),
            "::",
            stringify!(EndHeader)
        )
    );
}
pub type IMAGE_ARCHIVE_MEMBER_HEADER = _IMAGE_ARCHIVE_MEMBER_HEADER;
pub type PIMAGE_ARCHIVE_MEMBER_HEADER = *mut _IMAGE_ARCHIVE_MEMBER_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_EXPORT_DIRECTORY {
    pub Characteristics: DWORD,
    pub TimeDateStamp: DWORD,
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
    pub Name: DWORD,
    pub Base: DWORD,
    pub NumberOfFunctions: DWORD,
    pub NumberOfNames: DWORD,
    pub AddressOfFunctions: DWORD,
    pub AddressOfNames: DWORD,
    pub AddressOfNameOrdinals: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_EXPORT_DIRECTORY() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_EXPORT_DIRECTORY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_EXPORT_DIRECTORY>(),
        40usize,
        concat!("Size of: ", stringify!(_IMAGE_EXPORT_DIRECTORY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_EXPORT_DIRECTORY>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_EXPORT_DIRECTORY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Characteristics) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(Characteristics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MajorVersion) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(MajorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinorVersion) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(MinorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Base) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(Base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfFunctions) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(NumberOfFunctions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfNames) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(NumberOfNames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddressOfFunctions) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(AddressOfFunctions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddressOfNames) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(AddressOfNames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddressOfNameOrdinals) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(AddressOfNameOrdinals)
        )
    );
}
pub type IMAGE_EXPORT_DIRECTORY = _IMAGE_EXPORT_DIRECTORY;
pub type PIMAGE_EXPORT_DIRECTORY = *mut _IMAGE_EXPORT_DIRECTORY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_IMPORT_BY_NAME {
    pub Hint: WORD,
    pub Name: [CHAR; 1usize],
}
#[test]
fn bindgen_test_layout__IMAGE_IMPORT_BY_NAME() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_IMPORT_BY_NAME> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_IMPORT_BY_NAME>(),
        4usize,
        concat!("Size of: ", stringify!(_IMAGE_IMPORT_BY_NAME))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_IMPORT_BY_NAME>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_IMPORT_BY_NAME))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Hint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_BY_NAME),
            "::",
            stringify!(Hint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_BY_NAME),
            "::",
            stringify!(Name)
        )
    );
}
pub type IMAGE_IMPORT_BY_NAME = _IMAGE_IMPORT_BY_NAME;
pub type PIMAGE_IMPORT_BY_NAME = *mut _IMAGE_IMPORT_BY_NAME;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_THUNK_DATA64 {
    pub u1: _IMAGE_THUNK_DATA64__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_THUNK_DATA64__bindgen_ty_1 {
    pub ForwarderString: ULONGLONG,
    pub Function: ULONGLONG,
    pub Ordinal: ULONGLONG,
    pub AddressOfData: ULONGLONG,
}
#[test]
fn bindgen_test_layout__IMAGE_THUNK_DATA64__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_THUNK_DATA64__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_THUNK_DATA64__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_THUNK_DATA64__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_THUNK_DATA64__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_THUNK_DATA64__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ForwarderString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_THUNK_DATA64__bindgen_ty_1),
            "::",
            stringify!(ForwarderString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Function) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_THUNK_DATA64__bindgen_ty_1),
            "::",
            stringify!(Function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ordinal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_THUNK_DATA64__bindgen_ty_1),
            "::",
            stringify!(Ordinal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddressOfData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_THUNK_DATA64__bindgen_ty_1),
            "::",
            stringify!(AddressOfData)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_THUNK_DATA64() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_THUNK_DATA64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_THUNK_DATA64>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_THUNK_DATA64))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_THUNK_DATA64>(),
        8usize,
        concat!("Alignment of ", stringify!(_IMAGE_THUNK_DATA64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_THUNK_DATA64),
            "::",
            stringify!(u1)
        )
    );
}
pub type IMAGE_THUNK_DATA64 = _IMAGE_THUNK_DATA64;
pub type PIMAGE_THUNK_DATA64 = *mut IMAGE_THUNK_DATA64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_THUNK_DATA32 {
    pub u1: _IMAGE_THUNK_DATA32__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_THUNK_DATA32__bindgen_ty_1 {
    pub ForwarderString: DWORD,
    pub Function: DWORD,
    pub Ordinal: DWORD,
    pub AddressOfData: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_THUNK_DATA32__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_THUNK_DATA32__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_THUNK_DATA32__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_IMAGE_THUNK_DATA32__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_THUNK_DATA32__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_THUNK_DATA32__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ForwarderString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_THUNK_DATA32__bindgen_ty_1),
            "::",
            stringify!(ForwarderString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Function) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_THUNK_DATA32__bindgen_ty_1),
            "::",
            stringify!(Function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ordinal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_THUNK_DATA32__bindgen_ty_1),
            "::",
            stringify!(Ordinal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddressOfData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_THUNK_DATA32__bindgen_ty_1),
            "::",
            stringify!(AddressOfData)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_THUNK_DATA32() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_THUNK_DATA32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_THUNK_DATA32>(),
        4usize,
        concat!("Size of: ", stringify!(_IMAGE_THUNK_DATA32))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_THUNK_DATA32>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_THUNK_DATA32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_THUNK_DATA32),
            "::",
            stringify!(u1)
        )
    );
}
pub type IMAGE_THUNK_DATA32 = _IMAGE_THUNK_DATA32;
pub type PIMAGE_THUNK_DATA32 = *mut IMAGE_THUNK_DATA32;
pub type PIMAGE_TLS_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(DllHandle: PVOID, Reason: DWORD, Reserved: PVOID)>;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_TLS_DIRECTORY64 {
    pub StartAddressOfRawData: ULONGLONG,
    pub EndAddressOfRawData: ULONGLONG,
    pub AddressOfIndex: ULONGLONG,
    pub AddressOfCallBacks: ULONGLONG,
    pub SizeOfZeroFill: DWORD,
    pub Characteristics: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_TLS_DIRECTORY64() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_TLS_DIRECTORY64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_TLS_DIRECTORY64>(),
        40usize,
        concat!("Size of: ", stringify!(_IMAGE_TLS_DIRECTORY64))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_TLS_DIRECTORY64>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_TLS_DIRECTORY64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StartAddressOfRawData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY64),
            "::",
            stringify!(StartAddressOfRawData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndAddressOfRawData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY64),
            "::",
            stringify!(EndAddressOfRawData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddressOfIndex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY64),
            "::",
            stringify!(AddressOfIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddressOfCallBacks) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY64),
            "::",
            stringify!(AddressOfCallBacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfZeroFill) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY64),
            "::",
            stringify!(SizeOfZeroFill)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Characteristics) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY64),
            "::",
            stringify!(Characteristics)
        )
    );
}
pub type IMAGE_TLS_DIRECTORY64 = _IMAGE_TLS_DIRECTORY64;
pub type PIMAGE_TLS_DIRECTORY64 = *mut IMAGE_TLS_DIRECTORY64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_TLS_DIRECTORY32 {
    pub StartAddressOfRawData: DWORD,
    pub EndAddressOfRawData: DWORD,
    pub AddressOfIndex: DWORD,
    pub AddressOfCallBacks: DWORD,
    pub SizeOfZeroFill: DWORD,
    pub Characteristics: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_TLS_DIRECTORY32() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_TLS_DIRECTORY32> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_TLS_DIRECTORY32>(),
        24usize,
        concat!("Size of: ", stringify!(_IMAGE_TLS_DIRECTORY32))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_TLS_DIRECTORY32>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_TLS_DIRECTORY32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StartAddressOfRawData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY32),
            "::",
            stringify!(StartAddressOfRawData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndAddressOfRawData) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY32),
            "::",
            stringify!(EndAddressOfRawData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddressOfIndex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY32),
            "::",
            stringify!(AddressOfIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddressOfCallBacks) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY32),
            "::",
            stringify!(AddressOfCallBacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfZeroFill) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY32),
            "::",
            stringify!(SizeOfZeroFill)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Characteristics) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY32),
            "::",
            stringify!(Characteristics)
        )
    );
}
pub type IMAGE_TLS_DIRECTORY32 = _IMAGE_TLS_DIRECTORY32;
pub type PIMAGE_TLS_DIRECTORY32 = *mut IMAGE_TLS_DIRECTORY32;
pub type IMAGE_THUNK_DATA = IMAGE_THUNK_DATA64;
pub type PIMAGE_THUNK_DATA = PIMAGE_THUNK_DATA64;
pub type IMAGE_TLS_DIRECTORY = IMAGE_TLS_DIRECTORY64;
pub type PIMAGE_TLS_DIRECTORY = PIMAGE_TLS_DIRECTORY64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_IMPORT_DESCRIPTOR {
    pub __bindgen_anon_1: _IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1,
    pub TimeDateStamp: DWORD,
    pub ForwarderChain: DWORD,
    pub Name: DWORD,
    pub FirstThunk: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1 {
    pub Characteristics: DWORD,
    pub OriginalFirstThunk: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Characteristics) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Characteristics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OriginalFirstThunk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(OriginalFirstThunk)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_IMPORT_DESCRIPTOR() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_IMPORT_DESCRIPTOR> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_IMPORT_DESCRIPTOR>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_IMPORT_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_IMPORT_DESCRIPTOR>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_IMPORT_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ForwarderChain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR),
            "::",
            stringify!(ForwarderChain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FirstThunk) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR),
            "::",
            stringify!(FirstThunk)
        )
    );
}
pub type IMAGE_IMPORT_DESCRIPTOR = _IMAGE_IMPORT_DESCRIPTOR;
pub type PIMAGE_IMPORT_DESCRIPTOR = *mut IMAGE_IMPORT_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
    pub TimeDateStamp: DWORD,
    pub OffsetModuleName: WORD,
    pub NumberOfModuleForwarderRefs: WORD,
}
#[test]
fn bindgen_test_layout__IMAGE_BOUND_IMPORT_DESCRIPTOR() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_BOUND_IMPORT_DESCRIPTOR> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_BOUND_IMPORT_DESCRIPTOR>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_BOUND_IMPORT_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_BOUND_IMPORT_DESCRIPTOR>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_BOUND_IMPORT_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_BOUND_IMPORT_DESCRIPTOR),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OffsetModuleName) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_BOUND_IMPORT_DESCRIPTOR),
            "::",
            stringify!(OffsetModuleName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfModuleForwarderRefs) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_BOUND_IMPORT_DESCRIPTOR),
            "::",
            stringify!(NumberOfModuleForwarderRefs)
        )
    );
}
pub type IMAGE_BOUND_IMPORT_DESCRIPTOR = _IMAGE_BOUND_IMPORT_DESCRIPTOR;
pub type PIMAGE_BOUND_IMPORT_DESCRIPTOR = *mut _IMAGE_BOUND_IMPORT_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_BOUND_FORWARDER_REF {
    pub TimeDateStamp: DWORD,
    pub OffsetModuleName: WORD,
    pub Reserved: WORD,
}
#[test]
fn bindgen_test_layout__IMAGE_BOUND_FORWARDER_REF() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_BOUND_FORWARDER_REF> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_BOUND_FORWARDER_REF>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_BOUND_FORWARDER_REF))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_BOUND_FORWARDER_REF>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_BOUND_FORWARDER_REF))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_BOUND_FORWARDER_REF),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OffsetModuleName) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_BOUND_FORWARDER_REF),
            "::",
            stringify!(OffsetModuleName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_BOUND_FORWARDER_REF),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type IMAGE_BOUND_FORWARDER_REF = _IMAGE_BOUND_FORWARDER_REF;
pub type PIMAGE_BOUND_FORWARDER_REF = *mut _IMAGE_BOUND_FORWARDER_REF;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_DELAYLOAD_DESCRIPTOR {
    pub Attributes: _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1,
    pub DllNameRVA: DWORD,
    pub ModuleHandleRVA: DWORD,
    pub ImportAddressTableRVA: DWORD,
    pub ImportNameTableRVA: DWORD,
    pub BoundImportAddressTableRVA: DWORD,
    pub UnloadInformationTableRVA: DWORD,
    pub TimeDateStamp: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1 {
    pub AllAttributes: DWORD,
    pub __bindgen_anon_1: _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn RvaBased(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RvaBased(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedAttributes(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedAttributes(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RvaBased: DWORD,
        ReservedAttributes: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RvaBased: u32 = unsafe { ::std::mem::transmute(RvaBased) };
            RvaBased as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let ReservedAttributes: u32 = unsafe { ::std::mem::transmute(ReservedAttributes) };
            ReservedAttributes as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllAttributes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(AllAttributes)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_DELAYLOAD_DESCRIPTOR() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_DELAYLOAD_DESCRIPTOR> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_DELAYLOAD_DESCRIPTOR>(),
        32usize,
        concat!("Size of: ", stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_DELAYLOAD_DESCRIPTOR>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Attributes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR),
            "::",
            stringify!(Attributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DllNameRVA) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR),
            "::",
            stringify!(DllNameRVA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ModuleHandleRVA) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR),
            "::",
            stringify!(ModuleHandleRVA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ImportAddressTableRVA) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR),
            "::",
            stringify!(ImportAddressTableRVA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ImportNameTableRVA) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR),
            "::",
            stringify!(ImportNameTableRVA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BoundImportAddressTableRVA) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR),
            "::",
            stringify!(BoundImportAddressTableRVA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnloadInformationTableRVA) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR),
            "::",
            stringify!(UnloadInformationTableRVA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR),
            "::",
            stringify!(TimeDateStamp)
        )
    );
}
pub type IMAGE_DELAYLOAD_DESCRIPTOR = _IMAGE_DELAYLOAD_DESCRIPTOR;
pub type PIMAGE_DELAYLOAD_DESCRIPTOR = *mut _IMAGE_DELAYLOAD_DESCRIPTOR;
pub type PCIMAGE_DELAYLOAD_DESCRIPTOR = *const IMAGE_DELAYLOAD_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIRECTORY {
    pub Characteristics: DWORD,
    pub TimeDateStamp: DWORD,
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
    pub NumberOfNamedEntries: WORD,
    pub NumberOfIdEntries: WORD,
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_RESOURCE_DIRECTORY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY>(),
        16usize,
        concat!("Size of: ", stringify!(_IMAGE_RESOURCE_DIRECTORY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_RESOURCE_DIRECTORY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Characteristics) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY),
            "::",
            stringify!(Characteristics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MajorVersion) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY),
            "::",
            stringify!(MajorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinorVersion) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY),
            "::",
            stringify!(MinorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfNamedEntries) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY),
            "::",
            stringify!(NumberOfNamedEntries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfIdEntries) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY),
            "::",
            stringify!(NumberOfIdEntries)
        )
    );
}
pub type IMAGE_RESOURCE_DIRECTORY = _IMAGE_RESOURCE_DIRECTORY;
pub type PIMAGE_RESOURCE_DIRECTORY = *mut _IMAGE_RESOURCE_DIRECTORY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    pub __bindgen_anon_1: _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1,
    pub __bindgen_anon_2: _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1 {
    pub __bindgen_anon_1: _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1,
    pub Name: DWORD,
    pub Id: WORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NameOffset(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_NameOffset(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn NameIsString(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NameIsString(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NameOffset: DWORD,
        NameIsString: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let NameOffset: u32 = unsafe { ::std::mem::transmute(NameOffset) };
            NameOffset as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let NameIsString: u32 = unsafe { ::std::mem::transmute(NameIsString) };
            NameIsString as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1),
            "::",
            stringify!(Id)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2 {
    pub OffsetToData: DWORD,
    pub __bindgen_anon_1: _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1)
        )
    );
}
impl _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn OffsetToDirectory(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_OffsetToDirectory(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn DataIsDirectory(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DataIsDirectory(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OffsetToDirectory: DWORD,
        DataIsDirectory: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let OffsetToDirectory: u32 = unsafe { ::std::mem::transmute(OffsetToDirectory) };
            OffsetToDirectory as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let DataIsDirectory: u32 = unsafe { ::std::mem::transmute(DataIsDirectory) };
            DataIsDirectory as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OffsetToData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2),
            "::",
            stringify!(OffsetToData)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY))
    );
}
pub type IMAGE_RESOURCE_DIRECTORY_ENTRY = _IMAGE_RESOURCE_DIRECTORY_ENTRY;
pub type PIMAGE_RESOURCE_DIRECTORY_ENTRY = *mut _IMAGE_RESOURCE_DIRECTORY_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIRECTORY_STRING {
    pub Length: WORD,
    pub NameString: [CHAR; 1usize],
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY_STRING() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_RESOURCE_DIRECTORY_STRING> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY_STRING>(),
        4usize,
        concat!("Size of: ", stringify!(_IMAGE_RESOURCE_DIRECTORY_STRING))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY_STRING>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_STRING)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_STRING),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NameString) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_STRING),
            "::",
            stringify!(NameString)
        )
    );
}
pub type IMAGE_RESOURCE_DIRECTORY_STRING = _IMAGE_RESOURCE_DIRECTORY_STRING;
pub type PIMAGE_RESOURCE_DIRECTORY_STRING = *mut _IMAGE_RESOURCE_DIRECTORY_STRING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIR_STRING_U {
    pub Length: WORD,
    pub NameString: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIR_STRING_U() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_RESOURCE_DIR_STRING_U> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RESOURCE_DIR_STRING_U>(),
        4usize,
        concat!("Size of: ", stringify!(_IMAGE_RESOURCE_DIR_STRING_U))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RESOURCE_DIR_STRING_U>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_RESOURCE_DIR_STRING_U))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIR_STRING_U),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NameString) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIR_STRING_U),
            "::",
            stringify!(NameString)
        )
    );
}
pub type IMAGE_RESOURCE_DIR_STRING_U = _IMAGE_RESOURCE_DIR_STRING_U;
pub type PIMAGE_RESOURCE_DIR_STRING_U = *mut _IMAGE_RESOURCE_DIR_STRING_U;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DATA_ENTRY {
    pub OffsetToData: DWORD,
    pub Size: DWORD,
    pub CodePage: DWORD,
    pub Reserved: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DATA_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_RESOURCE_DATA_ENTRY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RESOURCE_DATA_ENTRY>(),
        16usize,
        concat!("Size of: ", stringify!(_IMAGE_RESOURCE_DATA_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RESOURCE_DATA_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_RESOURCE_DATA_ENTRY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OffsetToData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DATA_ENTRY),
            "::",
            stringify!(OffsetToData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DATA_ENTRY),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CodePage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DATA_ENTRY),
            "::",
            stringify!(CodePage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DATA_ENTRY),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type IMAGE_RESOURCE_DATA_ENTRY = _IMAGE_RESOURCE_DATA_ENTRY;
pub type PIMAGE_RESOURCE_DATA_ENTRY = *mut _IMAGE_RESOURCE_DATA_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMAGE_LOAD_CONFIG_DIRECTORY32 {
    pub Size: DWORD,
    pub TimeDateStamp: DWORD,
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
    pub GlobalFlagsClear: DWORD,
    pub GlobalFlagsSet: DWORD,
    pub CriticalSectionDefaultTimeout: DWORD,
    pub DeCommitFreeBlockThreshold: DWORD,
    pub DeCommitTotalFreeThreshold: DWORD,
    pub LockPrefixTable: DWORD,
    pub MaximumAllocationSize: DWORD,
    pub VirtualMemoryThreshold: DWORD,
    pub ProcessHeapFlags: DWORD,
    pub ProcessAffinityMask: DWORD,
    pub CSDVersion: WORD,
    pub Reserved1: WORD,
    pub EditList: DWORD,
    pub SecurityCookie: DWORD,
    pub SEHandlerTable: DWORD,
    pub SEHandlerCount: DWORD,
}
#[test]
fn bindgen_test_layout_IMAGE_LOAD_CONFIG_DIRECTORY32() {
    const UNINIT: ::std::mem::MaybeUninit<IMAGE_LOAD_CONFIG_DIRECTORY32> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMAGE_LOAD_CONFIG_DIRECTORY32>(),
        72usize,
        concat!("Size of: ", stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32))
    );
    assert_eq!(
        ::std::mem::align_of::<IMAGE_LOAD_CONFIG_DIRECTORY32>(),
        4usize,
        concat!("Alignment of ", stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MajorVersion) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(MajorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinorVersion) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(MinorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GlobalFlagsClear) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(GlobalFlagsClear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GlobalFlagsSet) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(GlobalFlagsSet)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CriticalSectionDefaultTimeout) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(CriticalSectionDefaultTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeCommitFreeBlockThreshold) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(DeCommitFreeBlockThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeCommitTotalFreeThreshold) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(DeCommitTotalFreeThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LockPrefixTable) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(LockPrefixTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumAllocationSize) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(MaximumAllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VirtualMemoryThreshold) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(VirtualMemoryThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProcessHeapFlags) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(ProcessHeapFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProcessAffinityMask) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(ProcessAffinityMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CSDVersion) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(CSDVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EditList) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(EditList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SecurityCookie) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(SecurityCookie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SEHandlerTable) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(SEHandlerTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SEHandlerCount) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(SEHandlerCount)
        )
    );
}
pub type PIMAGE_LOAD_CONFIG_DIRECTORY32 = *mut IMAGE_LOAD_CONFIG_DIRECTORY32;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct IMAGE_LOAD_CONFIG_DIRECTORY64 {
    pub Size: DWORD,
    pub TimeDateStamp: DWORD,
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
    pub GlobalFlagsClear: DWORD,
    pub GlobalFlagsSet: DWORD,
    pub CriticalSectionDefaultTimeout: DWORD,
    pub DeCommitFreeBlockThreshold: ULONGLONG,
    pub DeCommitTotalFreeThreshold: ULONGLONG,
    pub LockPrefixTable: ULONGLONG,
    pub MaximumAllocationSize: ULONGLONG,
    pub VirtualMemoryThreshold: ULONGLONG,
    pub ProcessAffinityMask: ULONGLONG,
    pub ProcessHeapFlags: DWORD,
    pub CSDVersion: WORD,
    pub Reserved1: WORD,
    pub EditList: ULONGLONG,
    pub SecurityCookie: ULONGLONG,
    pub SEHandlerTable: ULONGLONG,
    pub SEHandlerCount: ULONGLONG,
}
#[test]
fn bindgen_test_layout_IMAGE_LOAD_CONFIG_DIRECTORY64() {
    const UNINIT: ::std::mem::MaybeUninit<IMAGE_LOAD_CONFIG_DIRECTORY64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMAGE_LOAD_CONFIG_DIRECTORY64>(),
        112usize,
        concat!("Size of: ", stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64))
    );
    assert_eq!(
        ::std::mem::align_of::<IMAGE_LOAD_CONFIG_DIRECTORY64>(),
        4usize,
        concat!("Alignment of ", stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MajorVersion) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64),
            "::",
            stringify!(MajorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinorVersion) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64),
            "::",
            stringify!(MinorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GlobalFlagsClear) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64),
            "::",
            stringify!(GlobalFlagsClear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GlobalFlagsSet) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64),
            "::",
            stringify!(GlobalFlagsSet)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CriticalSectionDefaultTimeout) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64),
            "::",
            stringify!(CriticalSectionDefaultTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeCommitFreeBlockThreshold) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64),
            "::",
            stringify!(DeCommitFreeBlockThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeCommitTotalFreeThreshold) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64),
            "::",
            stringify!(DeCommitTotalFreeThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LockPrefixTable) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64),
            "::",
            stringify!(LockPrefixTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumAllocationSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64),
            "::",
            stringify!(MaximumAllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VirtualMemoryThreshold) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64),
            "::",
            stringify!(VirtualMemoryThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProcessAffinityMask) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64),
            "::",
            stringify!(ProcessAffinityMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProcessHeapFlags) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64),
            "::",
            stringify!(ProcessHeapFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CSDVersion) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64),
            "::",
            stringify!(CSDVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EditList) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64),
            "::",
            stringify!(EditList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SecurityCookie) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64),
            "::",
            stringify!(SecurityCookie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SEHandlerTable) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64),
            "::",
            stringify!(SEHandlerTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SEHandlerCount) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_LOAD_CONFIG_DIRECTORY64),
            "::",
            stringify!(SEHandlerCount)
        )
    );
}
pub type PIMAGE_LOAD_CONFIG_DIRECTORY64 = *mut IMAGE_LOAD_CONFIG_DIRECTORY64;
pub type IMAGE_LOAD_CONFIG_DIRECTORY = IMAGE_LOAD_CONFIG_DIRECTORY64;
pub type PIMAGE_LOAD_CONFIG_DIRECTORY = PIMAGE_LOAD_CONFIG_DIRECTORY64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    pub FuncStart: DWORD,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__IMAGE_CE_RUNTIME_FUNCTION_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_CE_RUNTIME_FUNCTION_ENTRY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_CE_RUNTIME_FUNCTION_ENTRY>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_CE_RUNTIME_FUNCTION_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_CE_RUNTIME_FUNCTION_ENTRY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_CE_RUNTIME_FUNCTION_ENTRY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FuncStart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_CE_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(FuncStart)
        )
    );
}
impl _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    #[inline]
    pub fn PrologLen(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PrologLen(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn FuncLen(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_FuncLen(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn ThirtyTwoBit(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ThirtyTwoBit(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExceptionFlag(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExceptionFlag(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PrologLen: DWORD,
        FuncLen: DWORD,
        ThirtyTwoBit: DWORD,
        ExceptionFlag: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PrologLen: u32 = unsafe { ::std::mem::transmute(PrologLen) };
            PrologLen as u64
        });
        __bindgen_bitfield_unit.set(8usize, 22u8, {
            let FuncLen: u32 = unsafe { ::std::mem::transmute(FuncLen) };
            FuncLen as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ThirtyTwoBit: u32 = unsafe { ::std::mem::transmute(ThirtyTwoBit) };
            ThirtyTwoBit as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let ExceptionFlag: u32 = unsafe { ::std::mem::transmute(ExceptionFlag) };
            ExceptionFlag as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IMAGE_CE_RUNTIME_FUNCTION_ENTRY = _IMAGE_CE_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_CE_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_CE_RUNTIME_FUNCTION_ENTRY;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
    pub BeginAddress: ULONGLONG,
    pub EndAddress: ULONGLONG,
    pub ExceptionHandler: ULONGLONG,
    pub HandlerData: ULONGLONG,
    pub PrologEndAddress: ULONGLONG,
}
#[test]
fn bindgen_test_layout__IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BeginAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(BeginAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndAddress) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(EndAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionHandler) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(ExceptionHandler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HandlerData) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(HandlerData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrologEndAddress) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(PrologEndAddress)
        )
    );
}
pub type IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
    pub BeginAddress: DWORD,
    pub EndAddress: DWORD,
    pub ExceptionHandler: DWORD,
    pub HandlerData: DWORD,
    pub PrologEndAddress: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BeginAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(BeginAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndAddress) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(EndAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExceptionHandler) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(ExceptionHandler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HandlerData) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(HandlerData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrologEndAddress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(PrologEndAddress)
        )
    );
}
pub type IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY {
    pub BeginAddress: DWORD,
    pub __bindgen_anon_1: _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
    pub UnwindData: DWORD,
    pub __bindgen_anon_1: _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Flag(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Flag(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn FunctionLength(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionLength(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn Ret(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Ret(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn H(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_H(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reg(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Reg(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn R(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_R(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn L(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_L(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StackAdjust(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_StackAdjust(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Flag: DWORD,
        FunctionLength: DWORD,
        Ret: DWORD,
        H: DWORD,
        Reg: DWORD,
        R: DWORD,
        L: DWORD,
        C: DWORD,
        StackAdjust: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Flag: u32 = unsafe { ::std::mem::transmute(Flag) };
            Flag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 11u8, {
            let FunctionLength: u32 = unsafe { ::std::mem::transmute(FunctionLength) };
            FunctionLength as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let Ret: u32 = unsafe { ::std::mem::transmute(Ret) };
            Ret as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let H: u32 = unsafe { ::std::mem::transmute(H) };
            H as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let Reg: u32 = unsafe { ::std::mem::transmute(Reg) };
            Reg as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let R: u32 = unsafe { ::std::mem::transmute(R) };
            R as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let L: u32 = unsafe { ::std::mem::transmute(L) };
            L as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let C: u32 = unsafe { ::std::mem::transmute(C) };
            C as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let StackAdjust: u32 = unsafe { ::std::mem::transmute(StackAdjust) };
            StackAdjust as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnwindData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1),
            "::",
            stringify!(UnwindData)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_ARM_RUNTIME_FUNCTION_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BeginAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(BeginAddress)
        )
    );
}
pub type IMAGE_ARM_RUNTIME_FUNCTION_ENTRY = _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY;
pub const ARM64_FNPDATA_FLAGS_PdataRefToFullXdata: ARM64_FNPDATA_FLAGS = 0;
pub const ARM64_FNPDATA_FLAGS_PdataPackedUnwindFunction: ARM64_FNPDATA_FLAGS = 1;
pub const ARM64_FNPDATA_FLAGS_PdataPackedUnwindFragment: ARM64_FNPDATA_FLAGS = 2;
pub type ARM64_FNPDATA_FLAGS = ::std::os::raw::c_uint;
pub const ARM64_FNPDATA_CR_PdataCrUnchained: ARM64_FNPDATA_CR = 0;
pub const ARM64_FNPDATA_CR_PdataCrUnchainedSavedLr: ARM64_FNPDATA_CR = 1;
pub const ARM64_FNPDATA_CR_PdataCrChainedWithPac: ARM64_FNPDATA_CR = 2;
pub const ARM64_FNPDATA_CR_PdataCrChained: ARM64_FNPDATA_CR = 3;
pub type ARM64_FNPDATA_CR = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY {
    pub BeginAddress: DWORD,
    pub __bindgen_anon_1: _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
    pub UnwindData: DWORD,
    pub __bindgen_anon_1: _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Flag(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Flag(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn FunctionLength(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionLength(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn RegF(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_RegF(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RegI(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_RegI(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn H(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_H(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CR(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CR(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn FrameSize(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_FrameSize(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Flag: DWORD,
        FunctionLength: DWORD,
        RegF: DWORD,
        RegI: DWORD,
        H: DWORD,
        CR: DWORD,
        FrameSize: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Flag: u32 = unsafe { ::std::mem::transmute(Flag) };
            Flag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 11u8, {
            let FunctionLength: u32 = unsafe { ::std::mem::transmute(FunctionLength) };
            FunctionLength as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let RegF: u32 = unsafe { ::std::mem::transmute(RegF) };
            RegF as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let RegI: u32 = unsafe { ::std::mem::transmute(RegI) };
            RegI as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let H: u32 = unsafe { ::std::mem::transmute(H) };
            H as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let CR: u32 = unsafe { ::std::mem::transmute(CR) };
            CR as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let FrameSize: u32 = unsafe { ::std::mem::transmute(FrameSize) };
            FrameSize as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnwindData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1),
            "::",
            stringify!(UnwindData)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BeginAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(BeginAddress)
        )
    );
}
pub type IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA {
    pub HeaderData: DWORD,
    pub __bindgen_anon_1: IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA__bindgen_ty_1)
        )
    );
}
impl IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA__bindgen_ty_1 {
    #[inline]
    pub fn FunctionLength(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionLength(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn Version(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Version(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ExceptionDataPresent(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExceptionDataPresent(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EpilogInHeader(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EpilogInHeader(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EpilogCount(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_EpilogCount(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn CodeWords(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_CodeWords(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FunctionLength: DWORD,
        Version: DWORD,
        ExceptionDataPresent: DWORD,
        EpilogInHeader: DWORD,
        EpilogCount: DWORD,
        CodeWords: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 18u8, {
            let FunctionLength: u32 = unsafe { ::std::mem::transmute(FunctionLength) };
            FunctionLength as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let Version: u32 = unsafe { ::std::mem::transmute(Version) };
            Version as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let ExceptionDataPresent: u32 = unsafe { ::std::mem::transmute(ExceptionDataPresent) };
            ExceptionDataPresent as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let EpilogInHeader: u32 = unsafe { ::std::mem::transmute(EpilogInHeader) };
            EpilogInHeader as u64
        });
        __bindgen_bitfield_unit.set(22usize, 5u8, {
            let EpilogCount: u32 = unsafe { ::std::mem::transmute(EpilogCount) };
            EpilogCount as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let CodeWords: u32 = unsafe { ::std::mem::transmute(CodeWords) };
            CodeWords as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA() {
    const UNINIT: ::std::mem::MaybeUninit<IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HeaderData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA),
            "::",
            stringify!(HeaderData)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
    pub BeginAddress: DWORD,
    pub EndAddress: DWORD,
    pub __bindgen_anon_1: _IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
    pub UnwindInfoAddress: DWORD,
    pub UnwindData: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnwindInfoAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1),
            "::",
            stringify!(UnwindInfoAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnwindData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1),
            "::",
            stringify!(UnwindData)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_RUNTIME_FUNCTION_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_RUNTIME_FUNCTION_ENTRY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RUNTIME_FUNCTION_ENTRY>(),
        12usize,
        concat!("Size of: ", stringify!(_IMAGE_RUNTIME_FUNCTION_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RUNTIME_FUNCTION_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_RUNTIME_FUNCTION_ENTRY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BeginAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(BeginAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndAddress) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(EndAddress)
        )
    );
}
pub type _PIMAGE_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub type IMAGE_IA64_RUNTIME_FUNCTION_ENTRY = _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY = _PIMAGE_RUNTIME_FUNCTION_ENTRY;
pub type IMAGE_RUNTIME_FUNCTION_ENTRY = _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_RUNTIME_FUNCTION_ENTRY = _PIMAGE_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DEBUG_DIRECTORY {
    pub Characteristics: DWORD,
    pub TimeDateStamp: DWORD,
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
    pub Type: DWORD,
    pub SizeOfData: DWORD,
    pub AddressOfRawData: DWORD,
    pub PointerToRawData: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_DEBUG_DIRECTORY() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_DEBUG_DIRECTORY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_DEBUG_DIRECTORY>(),
        28usize,
        concat!("Size of: ", stringify!(_IMAGE_DEBUG_DIRECTORY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_DEBUG_DIRECTORY>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_DEBUG_DIRECTORY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Characteristics) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_DIRECTORY),
            "::",
            stringify!(Characteristics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_DIRECTORY),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MajorVersion) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_DIRECTORY),
            "::",
            stringify!(MajorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinorVersion) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_DIRECTORY),
            "::",
            stringify!(MinorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_DIRECTORY),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_DIRECTORY),
            "::",
            stringify!(SizeOfData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddressOfRawData) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_DIRECTORY),
            "::",
            stringify!(AddressOfRawData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PointerToRawData) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_DIRECTORY),
            "::",
            stringify!(PointerToRawData)
        )
    );
}
pub type IMAGE_DEBUG_DIRECTORY = _IMAGE_DEBUG_DIRECTORY;
pub type PIMAGE_DEBUG_DIRECTORY = *mut _IMAGE_DEBUG_DIRECTORY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_COFF_SYMBOLS_HEADER {
    pub NumberOfSymbols: DWORD,
    pub LvaToFirstSymbol: DWORD,
    pub NumberOfLinenumbers: DWORD,
    pub LvaToFirstLinenumber: DWORD,
    pub RvaToFirstByteOfCode: DWORD,
    pub RvaToLastByteOfCode: DWORD,
    pub RvaToFirstByteOfData: DWORD,
    pub RvaToLastByteOfData: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_COFF_SYMBOLS_HEADER() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_COFF_SYMBOLS_HEADER> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_COFF_SYMBOLS_HEADER>(),
        32usize,
        concat!("Size of: ", stringify!(_IMAGE_COFF_SYMBOLS_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_COFF_SYMBOLS_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_COFF_SYMBOLS_HEADER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfSymbols) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_COFF_SYMBOLS_HEADER),
            "::",
            stringify!(NumberOfSymbols)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LvaToFirstSymbol) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_COFF_SYMBOLS_HEADER),
            "::",
            stringify!(LvaToFirstSymbol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfLinenumbers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_COFF_SYMBOLS_HEADER),
            "::",
            stringify!(NumberOfLinenumbers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LvaToFirstLinenumber) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_COFF_SYMBOLS_HEADER),
            "::",
            stringify!(LvaToFirstLinenumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RvaToFirstByteOfCode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_COFF_SYMBOLS_HEADER),
            "::",
            stringify!(RvaToFirstByteOfCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RvaToLastByteOfCode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_COFF_SYMBOLS_HEADER),
            "::",
            stringify!(RvaToLastByteOfCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RvaToFirstByteOfData) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_COFF_SYMBOLS_HEADER),
            "::",
            stringify!(RvaToFirstByteOfData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RvaToLastByteOfData) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_COFF_SYMBOLS_HEADER),
            "::",
            stringify!(RvaToLastByteOfData)
        )
    );
}
pub type IMAGE_COFF_SYMBOLS_HEADER = _IMAGE_COFF_SYMBOLS_HEADER;
pub type PIMAGE_COFF_SYMBOLS_HEADER = *mut _IMAGE_COFF_SYMBOLS_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FPO_DATA {
    pub ulOffStart: DWORD,
    pub cbProcSize: DWORD,
    pub cdwLocals: DWORD,
    pub cdwParams: WORD,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout__FPO_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<_FPO_DATA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FPO_DATA>(),
        16usize,
        concat!("Size of: ", stringify!(_FPO_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_FPO_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(_FPO_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulOffStart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPO_DATA),
            "::",
            stringify!(ulOffStart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbProcSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPO_DATA),
            "::",
            stringify!(cbProcSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cdwLocals) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPO_DATA),
            "::",
            stringify!(cdwLocals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cdwParams) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPO_DATA),
            "::",
            stringify!(cdwParams)
        )
    );
}
impl _FPO_DATA {
    #[inline]
    pub fn cbProlog(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_cbProlog(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn cbRegs(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_cbRegs(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn fHasSEH(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fHasSEH(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fUseBP(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fUseBP(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cbFrame(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_cbFrame(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cbProlog: WORD,
        cbRegs: WORD,
        fHasSEH: WORD,
        fUseBP: WORD,
        reserved: WORD,
        cbFrame: WORD,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let cbProlog: u16 = unsafe { ::std::mem::transmute(cbProlog) };
            cbProlog as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let cbRegs: u16 = unsafe { ::std::mem::transmute(cbRegs) };
            cbRegs as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let fHasSEH: u16 = unsafe { ::std::mem::transmute(fHasSEH) };
            fHasSEH as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let fUseBP: u16 = unsafe { ::std::mem::transmute(fUseBP) };
            fUseBP as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let cbFrame: u16 = unsafe { ::std::mem::transmute(cbFrame) };
            cbFrame as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type FPO_DATA = _FPO_DATA;
pub type PFPO_DATA = *mut _FPO_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DEBUG_MISC {
    pub DataType: DWORD,
    pub Length: DWORD,
    pub Unicode: BOOLEAN,
    pub Reserved: [BYTE; 3usize],
    pub Data: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__IMAGE_DEBUG_MISC() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_DEBUG_MISC> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_DEBUG_MISC>(),
        16usize,
        concat!("Size of: ", stringify!(_IMAGE_DEBUG_MISC))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_DEBUG_MISC>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_DEBUG_MISC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_MISC),
            "::",
            stringify!(DataType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_MISC),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Unicode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_MISC),
            "::",
            stringify!(Unicode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_MISC),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_MISC),
            "::",
            stringify!(Data)
        )
    );
}
pub type IMAGE_DEBUG_MISC = _IMAGE_DEBUG_MISC;
pub type PIMAGE_DEBUG_MISC = *mut _IMAGE_DEBUG_MISC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_FUNCTION_ENTRY {
    pub StartingAddress: DWORD,
    pub EndingAddress: DWORD,
    pub EndOfPrologue: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_FUNCTION_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_FUNCTION_ENTRY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_FUNCTION_ENTRY>(),
        12usize,
        concat!("Size of: ", stringify!(_IMAGE_FUNCTION_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_FUNCTION_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_FUNCTION_ENTRY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StartingAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FUNCTION_ENTRY),
            "::",
            stringify!(StartingAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndingAddress) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FUNCTION_ENTRY),
            "::",
            stringify!(EndingAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndOfPrologue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FUNCTION_ENTRY),
            "::",
            stringify!(EndOfPrologue)
        )
    );
}
pub type IMAGE_FUNCTION_ENTRY = _IMAGE_FUNCTION_ENTRY;
pub type PIMAGE_FUNCTION_ENTRY = *mut _IMAGE_FUNCTION_ENTRY;
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _IMAGE_FUNCTION_ENTRY64 {
    pub StartingAddress: ULONGLONG,
    pub EndingAddress: ULONGLONG,
    pub __bindgen_anon_1: _IMAGE_FUNCTION_ENTRY64__bindgen_ty_1,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub union _IMAGE_FUNCTION_ENTRY64__bindgen_ty_1 {
    pub EndOfPrologue: ULONGLONG,
    pub UnwindInfoAddress: ULONGLONG,
}
#[test]
fn bindgen_test_layout__IMAGE_FUNCTION_ENTRY64__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_FUNCTION_ENTRY64__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_FUNCTION_ENTRY64__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_FUNCTION_ENTRY64__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_FUNCTION_ENTRY64__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_FUNCTION_ENTRY64__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndOfPrologue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FUNCTION_ENTRY64__bindgen_ty_1),
            "::",
            stringify!(EndOfPrologue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnwindInfoAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FUNCTION_ENTRY64__bindgen_ty_1),
            "::",
            stringify!(UnwindInfoAddress)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_FUNCTION_ENTRY64() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_FUNCTION_ENTRY64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_FUNCTION_ENTRY64>(),
        24usize,
        concat!("Size of: ", stringify!(_IMAGE_FUNCTION_ENTRY64))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_FUNCTION_ENTRY64>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_FUNCTION_ENTRY64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StartingAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FUNCTION_ENTRY64),
            "::",
            stringify!(StartingAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndingAddress) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FUNCTION_ENTRY64),
            "::",
            stringify!(EndingAddress)
        )
    );
}
pub type IMAGE_FUNCTION_ENTRY64 = _IMAGE_FUNCTION_ENTRY64;
pub type PIMAGE_FUNCTION_ENTRY64 = *mut _IMAGE_FUNCTION_ENTRY64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_SEPARATE_DEBUG_HEADER {
    pub Signature: WORD,
    pub Flags: WORD,
    pub Machine: WORD,
    pub Characteristics: WORD,
    pub TimeDateStamp: DWORD,
    pub CheckSum: DWORD,
    pub ImageBase: DWORD,
    pub SizeOfImage: DWORD,
    pub NumberOfSections: DWORD,
    pub ExportedNamesSize: DWORD,
    pub DebugDirectorySize: DWORD,
    pub SectionAlignment: DWORD,
    pub Reserved: [DWORD; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_SEPARATE_DEBUG_HEADER() {
    const UNINIT: ::std::mem::MaybeUninit<_IMAGE_SEPARATE_DEBUG_HEADER> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_SEPARATE_DEBUG_HEADER>(),
        48usize,
        concat!("Size of: ", stringify!(_IMAGE_SEPARATE_DEBUG_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_SEPARATE_DEBUG_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_SEPARATE_DEBUG_HEADER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Signature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(Signature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Machine) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(Machine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Characteristics) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(Characteristics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CheckSum) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(CheckSum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ImageBase) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(ImageBase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfImage) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(SizeOfImage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfSections) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(NumberOfSections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExportedNamesSize) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(ExportedNamesSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DebugDirectorySize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(DebugDirectorySize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SectionAlignment) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(SectionAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type IMAGE_SEPARATE_DEBUG_HEADER = _IMAGE_SEPARATE_DEBUG_HEADER;
pub type PIMAGE_SEPARATE_DEBUG_HEADER = *mut _IMAGE_SEPARATE_DEBUG_HEADER;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct _NON_PAGED_DEBUG_INFO {
    pub Signature: WORD,
    pub Flags: WORD,
    pub Size: DWORD,
    pub Machine: WORD,
    pub Characteristics: WORD,
    pub TimeDateStamp: DWORD,
    pub CheckSum: DWORD,
    pub SizeOfImage: DWORD,
    pub ImageBase: ULONGLONG,
}
#[test]
fn bindgen_test_layout__NON_PAGED_DEBUG_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<_NON_PAGED_DEBUG_INFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_NON_PAGED_DEBUG_INFO>(),
        32usize,
        concat!("Size of: ", stringify!(_NON_PAGED_DEBUG_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_NON_PAGED_DEBUG_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_NON_PAGED_DEBUG_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Signature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NON_PAGED_DEBUG_INFO),
            "::",
            stringify!(Signature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_NON_PAGED_DEBUG_INFO),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NON_PAGED_DEBUG_INFO),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Machine) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NON_PAGED_DEBUG_INFO),
            "::",
            stringify!(Machine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Characteristics) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_NON_PAGED_DEBUG_INFO),
            "::",
            stringify!(Characteristics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NON_PAGED_DEBUG_INFO),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CheckSum) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NON_PAGED_DEBUG_INFO),
            "::",
            stringify!(CheckSum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfImage) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NON_PAGED_DEBUG_INFO),
            "::",
            stringify!(SizeOfImage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ImageBase) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NON_PAGED_DEBUG_INFO),
            "::",
            stringify!(ImageBase)
        )
    );
}
pub type NON_PAGED_DEBUG_INFO = _NON_PAGED_DEBUG_INFO;
pub type PNON_PAGED_DEBUG_INFO = *mut _NON_PAGED_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ImageArchitectureHeader {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub FirstEntryRVA: DWORD,
}
#[test]
fn bindgen_test_layout__ImageArchitectureHeader() {
    const UNINIT: ::std::mem::MaybeUninit<_ImageArchitectureHeader> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ImageArchitectureHeader>(),
        8usize,
        concat!("Size of: ", stringify!(_ImageArchitectureHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<_ImageArchitectureHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(_ImageArchitectureHeader))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FirstEntryRVA) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ImageArchitectureHeader),
            "::",
            stringify!(FirstEntryRVA)
        )
    );
}
impl _ImageArchitectureHeader {
    #[inline]
    pub fn AmaskValue(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AmaskValue(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Adummy1(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_Adummy1(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn AmaskShift(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_AmaskShift(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Adummy2(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Adummy2(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AmaskValue: ::std::os::raw::c_uint,
        Adummy1: ::std::os::raw::c_int,
        AmaskShift: ::std::os::raw::c_uint,
        Adummy2: ::std::os::raw::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AmaskValue: u32 = unsafe { ::std::mem::transmute(AmaskValue) };
            AmaskValue as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let Adummy1: u32 = unsafe { ::std::mem::transmute(Adummy1) };
            Adummy1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let AmaskShift: u32 = unsafe { ::std::mem::transmute(AmaskShift) };
            AmaskShift as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let Adummy2: u32 = unsafe { ::std::mem::transmute(Adummy2) };
            Adummy2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IMAGE_ARCHITECTURE_HEADER = _ImageArchitectureHeader;
pub type PIMAGE_ARCHITECTURE_HEADER = *mut _ImageArchitectureHeader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ImageArchitectureEntry {
    pub FixupInstRVA: DWORD,
    pub NewInst: DWORD,
}
#[test]
fn bindgen_test_layout__ImageArchitectureEntry() {
    const UNINIT: ::std::mem::MaybeUninit<_ImageArchitectureEntry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ImageArchitectureEntry>(),
        8usize,
        concat!("Size of: ", stringify!(_ImageArchitectureEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_ImageArchitectureEntry>(),
        4usize,
        concat!("Alignment of ", stringify!(_ImageArchitectureEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FixupInstRVA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ImageArchitectureEntry),
            "::",
            stringify!(FixupInstRVA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NewInst) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ImageArchitectureEntry),
            "::",
            stringify!(NewInst)
        )
    );
}
pub type IMAGE_ARCHITECTURE_ENTRY = _ImageArchitectureEntry;
pub type PIMAGE_ARCHITECTURE_ENTRY = *mut _ImageArchitectureEntry;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPORT_OBJECT_HEADER {
    pub Sig1: WORD,
    pub Sig2: WORD,
    pub Version: WORD,
    pub Machine: WORD,
    pub TimeDateStamp: DWORD,
    pub SizeOfData: DWORD,
    pub __bindgen_anon_1: IMPORT_OBJECT_HEADER__bindgen_ty_1,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPORT_OBJECT_HEADER__bindgen_ty_1 {
    pub Ordinal: WORD,
    pub Hint: WORD,
}
#[test]
fn bindgen_test_layout_IMPORT_OBJECT_HEADER__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<IMPORT_OBJECT_HEADER__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPORT_OBJECT_HEADER__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(IMPORT_OBJECT_HEADER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPORT_OBJECT_HEADER__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(IMPORT_OBJECT_HEADER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ordinal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPORT_OBJECT_HEADER__bindgen_ty_1),
            "::",
            stringify!(Ordinal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Hint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPORT_OBJECT_HEADER__bindgen_ty_1),
            "::",
            stringify!(Hint)
        )
    );
}
#[test]
fn bindgen_test_layout_IMPORT_OBJECT_HEADER() {
    const UNINIT: ::std::mem::MaybeUninit<IMPORT_OBJECT_HEADER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPORT_OBJECT_HEADER>(),
        20usize,
        concat!("Size of: ", stringify!(IMPORT_OBJECT_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPORT_OBJECT_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPORT_OBJECT_HEADER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sig1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPORT_OBJECT_HEADER),
            "::",
            stringify!(Sig1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sig2) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPORT_OBJECT_HEADER),
            "::",
            stringify!(Sig2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPORT_OBJECT_HEADER),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Machine) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPORT_OBJECT_HEADER),
            "::",
            stringify!(Machine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPORT_OBJECT_HEADER),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SizeOfData) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPORT_OBJECT_HEADER),
            "::",
            stringify!(SizeOfData)
        )
    );
}
impl IMPORT_OBJECT_HEADER {
    #[inline]
    pub fn Type(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn NameType(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_NameType(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Type: WORD,
        NameType: WORD,
        Reserved: WORD,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Type: u16 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let NameType: u16 = unsafe { ::std::mem::transmute(NameType) };
            NameType as u64
        });
        __bindgen_bitfield_unit.set(5usize, 11u8, {
            let Reserved: u16 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const IMPORT_OBJECT_TYPE_IMPORT_OBJECT_CODE: IMPORT_OBJECT_TYPE = 0;
pub const IMPORT_OBJECT_TYPE_IMPORT_OBJECT_DATA: IMPORT_OBJECT_TYPE = 1;
pub const IMPORT_OBJECT_TYPE_IMPORT_OBJECT_CONST: IMPORT_OBJECT_TYPE = 2;
pub type IMPORT_OBJECT_TYPE = ::std::os::raw::c_uint;
pub const IMPORT_OBJECT_NAME_TYPE_IMPORT_OBJECT_ORDINAL: IMPORT_OBJECT_NAME_TYPE = 0;
pub const IMPORT_OBJECT_NAME_TYPE_IMPORT_OBJECT_NAME: IMPORT_OBJECT_NAME_TYPE = 1;
pub const IMPORT_OBJECT_NAME_TYPE_IMPORT_OBJECT_NAME_NO_PREFIX: IMPORT_OBJECT_NAME_TYPE = 2;
pub const IMPORT_OBJECT_NAME_TYPE_IMPORT_OBJECT_NAME_UNDECORATE: IMPORT_OBJECT_NAME_TYPE = 3;
pub type IMPORT_OBJECT_NAME_TYPE = ::std::os::raw::c_uint;
pub const ReplacesCorHdrNumericDefines_COMIMAGE_FLAGS_ILONLY: ReplacesCorHdrNumericDefines = 1;
pub const ReplacesCorHdrNumericDefines_COMIMAGE_FLAGS_32BITREQUIRED: ReplacesCorHdrNumericDefines =
    2;
pub const ReplacesCorHdrNumericDefines_COMIMAGE_FLAGS_IL_LIBRARY: ReplacesCorHdrNumericDefines = 4;
pub const ReplacesCorHdrNumericDefines_COMIMAGE_FLAGS_STRONGNAMESIGNED:
    ReplacesCorHdrNumericDefines = 8;
pub const ReplacesCorHdrNumericDefines_COMIMAGE_FLAGS_TRACKDEBUGDATA: ReplacesCorHdrNumericDefines =
    65536;
pub const ReplacesCorHdrNumericDefines_COR_VERSION_MAJOR_V2: ReplacesCorHdrNumericDefines = 2;
pub const ReplacesCorHdrNumericDefines_COR_VERSION_MAJOR: ReplacesCorHdrNumericDefines = 2;
pub const ReplacesCorHdrNumericDefines_COR_VERSION_MINOR: ReplacesCorHdrNumericDefines = 0;
pub const ReplacesCorHdrNumericDefines_COR_DELETED_NAME_LENGTH: ReplacesCorHdrNumericDefines = 8;
pub const ReplacesCorHdrNumericDefines_COR_VTABLEGAP_NAME_LENGTH: ReplacesCorHdrNumericDefines = 8;
pub const ReplacesCorHdrNumericDefines_NATIVE_TYPE_MAX_CB: ReplacesCorHdrNumericDefines = 1;
pub const ReplacesCorHdrNumericDefines_COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE:
    ReplacesCorHdrNumericDefines = 255;
pub const ReplacesCorHdrNumericDefines_IMAGE_COR_MIH_METHODRVA: ReplacesCorHdrNumericDefines = 1;
pub const ReplacesCorHdrNumericDefines_IMAGE_COR_MIH_EHRVA: ReplacesCorHdrNumericDefines = 2;
pub const ReplacesCorHdrNumericDefines_IMAGE_COR_MIH_BASICBLOCK: ReplacesCorHdrNumericDefines = 8;
pub const ReplacesCorHdrNumericDefines_COR_VTABLE_32BIT: ReplacesCorHdrNumericDefines = 1;
pub const ReplacesCorHdrNumericDefines_COR_VTABLE_64BIT: ReplacesCorHdrNumericDefines = 2;
pub const ReplacesCorHdrNumericDefines_COR_VTABLE_FROM_UNMANAGED: ReplacesCorHdrNumericDefines = 4;
pub const ReplacesCorHdrNumericDefines_COR_VTABLE_CALL_MOST_DERIVED: ReplacesCorHdrNumericDefines =
    16;
pub const ReplacesCorHdrNumericDefines_IMAGE_COR_EATJ_THUNK_SIZE: ReplacesCorHdrNumericDefines = 32;
pub const ReplacesCorHdrNumericDefines_MAX_CLASS_NAME: ReplacesCorHdrNumericDefines = 1024;
pub const ReplacesCorHdrNumericDefines_MAX_PACKAGE_NAME: ReplacesCorHdrNumericDefines = 1024;
pub type ReplacesCorHdrNumericDefines = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMAGE_COR20_HEADER {
    pub cb: DWORD,
    pub MajorRuntimeVersion: WORD,
    pub MinorRuntimeVersion: WORD,
    pub MetaData: IMAGE_DATA_DIRECTORY,
    pub Flags: DWORD,
    pub __bindgen_anon_1: IMAGE_COR20_HEADER__bindgen_ty_1,
    pub Resources: IMAGE_DATA_DIRECTORY,
    pub StrongNameSignature: IMAGE_DATA_DIRECTORY,
    pub CodeManagerTable: IMAGE_DATA_DIRECTORY,
    pub VTableFixups: IMAGE_DATA_DIRECTORY,
    pub ExportAddressTableJumps: IMAGE_DATA_DIRECTORY,
    pub ManagedNativeHeader: IMAGE_DATA_DIRECTORY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMAGE_COR20_HEADER__bindgen_ty_1 {
    pub EntryPointToken: DWORD,
    pub EntryPointRVA: DWORD,
}
#[test]
fn bindgen_test_layout_IMAGE_COR20_HEADER__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<IMAGE_COR20_HEADER__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMAGE_COR20_HEADER__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(IMAGE_COR20_HEADER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<IMAGE_COR20_HEADER__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(IMAGE_COR20_HEADER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntryPointToken) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER__bindgen_ty_1),
            "::",
            stringify!(EntryPointToken)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntryPointRVA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER__bindgen_ty_1),
            "::",
            stringify!(EntryPointRVA)
        )
    );
}
#[test]
fn bindgen_test_layout_IMAGE_COR20_HEADER() {
    const UNINIT: ::std::mem::MaybeUninit<IMAGE_COR20_HEADER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMAGE_COR20_HEADER>(),
        72usize,
        concat!("Size of: ", stringify!(IMAGE_COR20_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<IMAGE_COR20_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(IMAGE_COR20_HEADER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MajorRuntimeVersion) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(MajorRuntimeVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinorRuntimeVersion) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(MinorRuntimeVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MetaData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(MetaData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Resources) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(Resources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StrongNameSignature) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(StrongNameSignature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CodeManagerTable) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(CodeManagerTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VTableFixups) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(VTableFixups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExportAddressTableJumps) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(ExportAddressTableJumps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ManagedNativeHeader) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(ManagedNativeHeader)
        )
    );
}
pub type PIMAGE_COR20_HEADER = *mut IMAGE_COR20_HEADER;
extern "C" {
    pub fn RtlCaptureStackBackTrace(
        FramesToSkip: DWORD,
        FramesToCapture: DWORD,
        BackTrace: *mut PVOID,
        BackTraceHash: PDWORD,
    ) -> WORD;
}
extern "C" {
    pub fn RtlCaptureContext(ContextRecord: PCONTEXT);
}
extern "C" {
    pub fn RtlCompareMemory(
        Source1: *const ::std::os::raw::c_void,
        Source2: *const ::std::os::raw::c_void,
        Length: SIZE_T,
    ) -> SIZE_T;
}
extern "C" {
    pub fn RtlAddGrowableFunctionTable(
        DynamicTable: *mut PVOID,
        FunctionTable: PRUNTIME_FUNCTION,
        EntryCount: DWORD,
        MaximumEntryCount: DWORD,
        RangeBase: ULONG_PTR,
        RangeEnd: ULONG_PTR,
    ) -> DWORD;
}
extern "C" {
    pub fn RtlGrowFunctionTable(DynamicTable: PVOID, NewEntryCount: DWORD);
}
extern "C" {
    pub fn RtlDeleteGrowableFunctionTable(DynamicTable: PVOID);
}
extern "C" {
    pub fn RtlAddFunctionTable(
        FunctionTable: PRUNTIME_FUNCTION,
        EntryCount: DWORD,
        BaseAddress: DWORD64,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn RtlDeleteFunctionTable(FunctionTable: PRUNTIME_FUNCTION) -> BOOLEAN;
}
extern "C" {
    pub fn RtlInstallFunctionTableCallback(
        TableIdentifier: DWORD64,
        BaseAddress: DWORD64,
        Length: DWORD,
        Callback: PGET_RUNTIME_FUNCTION_CALLBACK,
        Context: PVOID,
        OutOfProcessCallbackDll: PCWSTR,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn RtlRestoreContext(ContextRecord: PCONTEXT, ExceptionRecord: *mut _EXCEPTION_RECORD);
}
extern "C" {
    pub fn RtlUnwind(
        TargetFrame: PVOID,
        TargetIp: PVOID,
        ExceptionRecord: PEXCEPTION_RECORD,
        ReturnValue: PVOID,
    );
}
extern "C" {
    pub fn RtlPcToFileHeader(PcValue: PVOID, BaseOfImage: *mut PVOID) -> PVOID;
}
extern "C" {
    pub fn RtlLookupFunctionEntry(
        ControlPc: DWORD64,
        ImageBase: PDWORD64,
        HistoryTable: PUNWIND_HISTORY_TABLE,
    ) -> PRUNTIME_FUNCTION;
}
extern "C" {
    pub fn RtlUnwindEx(
        TargetFrame: PVOID,
        TargetIp: PVOID,
        ExceptionRecord: PEXCEPTION_RECORD,
        ReturnValue: PVOID,
        ContextRecord: PCONTEXT,
        HistoryTable: PUNWIND_HISTORY_TABLE,
    );
}
extern "C" {
    pub fn RtlVirtualUnwind(
        HandlerType: DWORD,
        ImageBase: DWORD64,
        ControlPc: DWORD64,
        FunctionEntry: PRUNTIME_FUNCTION,
        ContextRecord: PCONTEXT,
        HandlerData: *mut PVOID,
        EstablisherFrame: PDWORD64,
        ContextPointers: PKNONVOLATILE_CONTEXT_POINTERS,
    ) -> PEXCEPTION_ROUTINE;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_ENTRY {
    pub Next: *mut _SLIST_ENTRY,
}
#[test]
fn bindgen_test_layout__SLIST_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_SLIST_ENTRY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SLIST_ENTRY>(),
        16usize,
        concat!("Size of: ", stringify!(_SLIST_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SLIST_ENTRY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SLIST_ENTRY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_ENTRY),
            "::",
            stringify!(Next)
        )
    );
}
pub type SLIST_ENTRY = _SLIST_ENTRY;
pub type PSLIST_ENTRY = *mut _SLIST_ENTRY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SLIST_HEADER {
    pub __bindgen_anon_1: _SLIST_HEADER__bindgen_ty_1,
    pub Header8: _SLIST_HEADER__bindgen_ty_2,
    pub HeaderX64: _SLIST_HEADER__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_1 {
    pub Alignment: ULONGLONG,
    pub Region: ULONGLONG,
}
#[test]
fn bindgen_test_layout__SLIST_HEADER__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SLIST_HEADER__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SLIST_HEADER__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_SLIST_HEADER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SLIST_HEADER__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_SLIST_HEADER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Alignment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_HEADER__bindgen_ty_1),
            "::",
            stringify!(Alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Region) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_HEADER__bindgen_ty_1),
            "::",
            stringify!(Region)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_2 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
#[test]
fn bindgen_test_layout__SLIST_HEADER__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_SLIST_HEADER__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(_SLIST_HEADER__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_SLIST_HEADER__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(_SLIST_HEADER__bindgen_ty_2))
    );
}
impl _SLIST_HEADER__bindgen_ty_2 {
    #[inline]
    pub fn Depth(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_Depth(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn Sequence(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_Sequence(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn NextEntry(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 39u8) as u64) }
    }
    #[inline]
    pub fn set_NextEntry(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 39u8, val as u64)
        }
    }
    #[inline]
    pub fn HeaderType(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_HeaderType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Init(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(65usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Init(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(65usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(66usize, 59u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(66usize, 59u8, val as u64)
        }
    }
    #[inline]
    pub fn Region(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(125usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_Region(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(125usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Depth: ULONGLONG,
        Sequence: ULONGLONG,
        NextEntry: ULONGLONG,
        HeaderType: ULONGLONG,
        Init: ULONGLONG,
        Reserved: ULONGLONG,
        Region: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let Depth: u64 = unsafe { ::std::mem::transmute(Depth) };
            Depth as u64
        });
        __bindgen_bitfield_unit.set(16usize, 9u8, {
            let Sequence: u64 = unsafe { ::std::mem::transmute(Sequence) };
            Sequence as u64
        });
        __bindgen_bitfield_unit.set(25usize, 39u8, {
            let NextEntry: u64 = unsafe { ::std::mem::transmute(NextEntry) };
            NextEntry as u64
        });
        __bindgen_bitfield_unit.set(64usize, 1u8, {
            let HeaderType: u64 = unsafe { ::std::mem::transmute(HeaderType) };
            HeaderType as u64
        });
        __bindgen_bitfield_unit.set(65usize, 1u8, {
            let Init: u64 = unsafe { ::std::mem::transmute(Init) };
            Init as u64
        });
        __bindgen_bitfield_unit.set(66usize, 59u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(125usize, 3u8, {
            let Region: u64 = unsafe { ::std::mem::transmute(Region) };
            Region as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_3 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
}
#[test]
fn bindgen_test_layout__SLIST_HEADER__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<_SLIST_HEADER__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(_SLIST_HEADER__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<_SLIST_HEADER__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(_SLIST_HEADER__bindgen_ty_3))
    );
}
impl _SLIST_HEADER__bindgen_ty_3 {
    #[inline]
    pub fn Depth(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_Depth(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn Sequence(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_Sequence(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub fn HeaderType(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_HeaderType(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(65usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(65usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn NextEntry(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(68usize, 60u8) as u64) }
    }
    #[inline]
    pub fn set_NextEntry(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(68usize, 60u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Depth: ULONGLONG,
        Sequence: ULONGLONG,
        HeaderType: ULONGLONG,
        Reserved: ULONGLONG,
        NextEntry: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let Depth: u64 = unsafe { ::std::mem::transmute(Depth) };
            Depth as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let Sequence: u64 = unsafe { ::std::mem::transmute(Sequence) };
            Sequence as u64
        });
        __bindgen_bitfield_unit.set(64usize, 1u8, {
            let HeaderType: u64 = unsafe { ::std::mem::transmute(HeaderType) };
            HeaderType as u64
        });
        __bindgen_bitfield_unit.set(65usize, 3u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(68usize, 60u8, {
            let NextEntry: u64 = unsafe { ::std::mem::transmute(NextEntry) };
            NextEntry as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__SLIST_HEADER() {
    const UNINIT: ::std::mem::MaybeUninit<_SLIST_HEADER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SLIST_HEADER>(),
        16usize,
        concat!("Size of: ", stringify!(_SLIST_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_SLIST_HEADER>(),
        16usize,
        concat!("Alignment of ", stringify!(_SLIST_HEADER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Header8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_HEADER),
            "::",
            stringify!(Header8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HeaderX64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_HEADER),
            "::",
            stringify!(HeaderX64)
        )
    );
}
pub type SLIST_HEADER = _SLIST_HEADER;
pub type PSLIST_HEADER = *mut _SLIST_HEADER;
extern "C" {
    pub fn RtlInitializeSListHead(ListHead: PSLIST_HEADER);
}
extern "C" {
    pub fn RtlFirstEntrySList(ListHead: *const SLIST_HEADER) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn RtlInterlockedPopEntrySList(ListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn RtlInterlockedPushEntrySList(
        ListHead: PSLIST_HEADER,
        ListEntry: PSLIST_ENTRY,
    ) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn RtlInterlockedPushListSListEx(
        ListHead: PSLIST_HEADER,
        List: PSLIST_ENTRY,
        ListEnd: PSLIST_ENTRY,
        Count: DWORD,
    ) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn RtlInterlockedFlushSList(ListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn RtlQueryDepthSList(ListHead: PSLIST_HEADER) -> WORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_RUN_ONCE {
    pub Ptr: PVOID,
}
#[test]
fn bindgen_test_layout__RTL_RUN_ONCE() {
    const UNINIT: ::std::mem::MaybeUninit<_RTL_RUN_ONCE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RTL_RUN_ONCE>(),
        8usize,
        concat!("Size of: ", stringify!(_RTL_RUN_ONCE))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_RUN_ONCE>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_RUN_ONCE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_RUN_ONCE),
            "::",
            stringify!(Ptr)
        )
    );
}
pub type RTL_RUN_ONCE = _RTL_RUN_ONCE;
pub type PRTL_RUN_ONCE = *mut _RTL_RUN_ONCE;
pub type PRTL_RUN_ONCE_INIT_FN = ::std::option::Option<
    unsafe extern "C" fn(arg1: PRTL_RUN_ONCE, arg2: PVOID, arg3: *mut PVOID) -> DWORD,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BARRIER {
    pub Reserved1: DWORD,
    pub Reserved2: DWORD,
    pub Reserved3: [ULONG_PTR; 2usize],
    pub Reserved4: DWORD,
    pub Reserved5: DWORD,
}
#[test]
fn bindgen_test_layout__RTL_BARRIER() {
    const UNINIT: ::std::mem::MaybeUninit<_RTL_BARRIER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RTL_BARRIER>(),
        32usize,
        concat!("Size of: ", stringify!(_RTL_BARRIER))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_BARRIER>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_BARRIER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_BARRIER),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_BARRIER),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_BARRIER),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_BARRIER),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved5) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_BARRIER),
            "::",
            stringify!(Reserved5)
        )
    );
}
pub type RTL_BARRIER = _RTL_BARRIER;
pub type PRTL_BARRIER = *mut _RTL_BARRIER;
extern "C" {
    pub fn RtlSecureZeroMemory(ptr: PVOID, cnt: SIZE_T) -> PVOID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MESSAGE_RESOURCE_ENTRY {
    pub Length: WORD,
    pub Flags: WORD,
    pub Text: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__MESSAGE_RESOURCE_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_MESSAGE_RESOURCE_ENTRY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_MESSAGE_RESOURCE_ENTRY>(),
        6usize,
        concat!("Size of: ", stringify!(_MESSAGE_RESOURCE_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_MESSAGE_RESOURCE_ENTRY>(),
        2usize,
        concat!("Alignment of ", stringify!(_MESSAGE_RESOURCE_ENTRY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MESSAGE_RESOURCE_ENTRY),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_MESSAGE_RESOURCE_ENTRY),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Text) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MESSAGE_RESOURCE_ENTRY),
            "::",
            stringify!(Text)
        )
    );
}
pub type MESSAGE_RESOURCE_ENTRY = _MESSAGE_RESOURCE_ENTRY;
pub type PMESSAGE_RESOURCE_ENTRY = *mut _MESSAGE_RESOURCE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MESSAGE_RESOURCE_BLOCK {
    pub LowId: DWORD,
    pub HighId: DWORD,
    pub OffsetToEntries: DWORD,
}
#[test]
fn bindgen_test_layout__MESSAGE_RESOURCE_BLOCK() {
    const UNINIT: ::std::mem::MaybeUninit<_MESSAGE_RESOURCE_BLOCK> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_MESSAGE_RESOURCE_BLOCK>(),
        12usize,
        concat!("Size of: ", stringify!(_MESSAGE_RESOURCE_BLOCK))
    );
    assert_eq!(
        ::std::mem::align_of::<_MESSAGE_RESOURCE_BLOCK>(),
        4usize,
        concat!("Alignment of ", stringify!(_MESSAGE_RESOURCE_BLOCK))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LowId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MESSAGE_RESOURCE_BLOCK),
            "::",
            stringify!(LowId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MESSAGE_RESOURCE_BLOCK),
            "::",
            stringify!(HighId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OffsetToEntries) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MESSAGE_RESOURCE_BLOCK),
            "::",
            stringify!(OffsetToEntries)
        )
    );
}
pub type MESSAGE_RESOURCE_BLOCK = _MESSAGE_RESOURCE_BLOCK;
pub type PMESSAGE_RESOURCE_BLOCK = *mut _MESSAGE_RESOURCE_BLOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MESSAGE_RESOURCE_DATA {
    pub NumberOfBlocks: DWORD,
    pub Blocks: [MESSAGE_RESOURCE_BLOCK; 1usize],
}
#[test]
fn bindgen_test_layout__MESSAGE_RESOURCE_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<_MESSAGE_RESOURCE_DATA> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_MESSAGE_RESOURCE_DATA>(),
        16usize,
        concat!("Size of: ", stringify!(_MESSAGE_RESOURCE_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_MESSAGE_RESOURCE_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(_MESSAGE_RESOURCE_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfBlocks) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MESSAGE_RESOURCE_DATA),
            "::",
            stringify!(NumberOfBlocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Blocks) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MESSAGE_RESOURCE_DATA),
            "::",
            stringify!(Blocks)
        )
    );
}
pub type MESSAGE_RESOURCE_DATA = _MESSAGE_RESOURCE_DATA;
pub type PMESSAGE_RESOURCE_DATA = *mut _MESSAGE_RESOURCE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OSVERSIONINFOA {
    pub dwOSVersionInfoSize: DWORD,
    pub dwMajorVersion: DWORD,
    pub dwMinorVersion: DWORD,
    pub dwBuildNumber: DWORD,
    pub dwPlatformId: DWORD,
    pub szCSDVersion: [CHAR; 128usize],
}
#[test]
fn bindgen_test_layout__OSVERSIONINFOA() {
    const UNINIT: ::std::mem::MaybeUninit<_OSVERSIONINFOA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSVERSIONINFOA>(),
        148usize,
        concat!("Size of: ", stringify!(_OSVERSIONINFOA))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSVERSIONINFOA>(),
        4usize,
        concat!("Alignment of ", stringify!(_OSVERSIONINFOA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwOSVersionInfoSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOA),
            "::",
            stringify!(dwOSVersionInfoSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwMajorVersion) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOA),
            "::",
            stringify!(dwMajorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwMinorVersion) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOA),
            "::",
            stringify!(dwMinorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwBuildNumber) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOA),
            "::",
            stringify!(dwBuildNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwPlatformId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOA),
            "::",
            stringify!(dwPlatformId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szCSDVersion) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOA),
            "::",
            stringify!(szCSDVersion)
        )
    );
}
pub type OSVERSIONINFOA = _OSVERSIONINFOA;
pub type POSVERSIONINFOA = *mut _OSVERSIONINFOA;
pub type LPOSVERSIONINFOA = *mut _OSVERSIONINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OSVERSIONINFOW {
    pub dwOSVersionInfoSize: DWORD,
    pub dwMajorVersion: DWORD,
    pub dwMinorVersion: DWORD,
    pub dwBuildNumber: DWORD,
    pub dwPlatformId: DWORD,
    pub szCSDVersion: [WCHAR; 128usize],
}
#[test]
fn bindgen_test_layout__OSVERSIONINFOW() {
    const UNINIT: ::std::mem::MaybeUninit<_OSVERSIONINFOW> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSVERSIONINFOW>(),
        276usize,
        concat!("Size of: ", stringify!(_OSVERSIONINFOW))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSVERSIONINFOW>(),
        4usize,
        concat!("Alignment of ", stringify!(_OSVERSIONINFOW))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwOSVersionInfoSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOW),
            "::",
            stringify!(dwOSVersionInfoSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwMajorVersion) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOW),
            "::",
            stringify!(dwMajorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwMinorVersion) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOW),
            "::",
            stringify!(dwMinorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwBuildNumber) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOW),
            "::",
            stringify!(dwBuildNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwPlatformId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOW),
            "::",
            stringify!(dwPlatformId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szCSDVersion) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOW),
            "::",
            stringify!(szCSDVersion)
        )
    );
}
pub type OSVERSIONINFOW = _OSVERSIONINFOW;
pub type POSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub type LPOSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub type RTL_OSVERSIONINFOW = _OSVERSIONINFOW;
pub type PRTL_OSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub type OSVERSIONINFO = OSVERSIONINFOA;
pub type POSVERSIONINFO = POSVERSIONINFOA;
pub type LPOSVERSIONINFO = LPOSVERSIONINFOA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OSVERSIONINFOEXA {
    pub dwOSVersionInfoSize: DWORD,
    pub dwMajorVersion: DWORD,
    pub dwMinorVersion: DWORD,
    pub dwBuildNumber: DWORD,
    pub dwPlatformId: DWORD,
    pub szCSDVersion: [CHAR; 128usize],
    pub wServicePackMajor: WORD,
    pub wServicePackMinor: WORD,
    pub wSuiteMask: WORD,
    pub wProductType: BYTE,
    pub wReserved: BYTE,
}
#[test]
fn bindgen_test_layout__OSVERSIONINFOEXA() {
    const UNINIT: ::std::mem::MaybeUninit<_OSVERSIONINFOEXA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSVERSIONINFOEXA>(),
        156usize,
        concat!("Size of: ", stringify!(_OSVERSIONINFOEXA))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSVERSIONINFOEXA>(),
        4usize,
        concat!("Alignment of ", stringify!(_OSVERSIONINFOEXA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwOSVersionInfoSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(dwOSVersionInfoSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwMajorVersion) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(dwMajorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwMinorVersion) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(dwMinorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwBuildNumber) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(dwBuildNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwPlatformId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(dwPlatformId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szCSDVersion) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(szCSDVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wServicePackMajor) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(wServicePackMajor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wServicePackMinor) as usize - ptr as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(wServicePackMinor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wSuiteMask) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(wSuiteMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wProductType) as usize - ptr as usize },
        154usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(wProductType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wReserved) as usize - ptr as usize },
        155usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(wReserved)
        )
    );
}
pub type OSVERSIONINFOEXA = _OSVERSIONINFOEXA;
pub type POSVERSIONINFOEXA = *mut _OSVERSIONINFOEXA;
pub type LPOSVERSIONINFOEXA = *mut _OSVERSIONINFOEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OSVERSIONINFOEXW {
    pub dwOSVersionInfoSize: DWORD,
    pub dwMajorVersion: DWORD,
    pub dwMinorVersion: DWORD,
    pub dwBuildNumber: DWORD,
    pub dwPlatformId: DWORD,
    pub szCSDVersion: [WCHAR; 128usize],
    pub wServicePackMajor: WORD,
    pub wServicePackMinor: WORD,
    pub wSuiteMask: WORD,
    pub wProductType: BYTE,
    pub wReserved: BYTE,
}
#[test]
fn bindgen_test_layout__OSVERSIONINFOEXW() {
    const UNINIT: ::std::mem::MaybeUninit<_OSVERSIONINFOEXW> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSVERSIONINFOEXW>(),
        284usize,
        concat!("Size of: ", stringify!(_OSVERSIONINFOEXW))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSVERSIONINFOEXW>(),
        4usize,
        concat!("Alignment of ", stringify!(_OSVERSIONINFOEXW))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwOSVersionInfoSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(dwOSVersionInfoSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwMajorVersion) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(dwMajorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwMinorVersion) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(dwMinorVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwBuildNumber) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(dwBuildNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwPlatformId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(dwPlatformId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szCSDVersion) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(szCSDVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wServicePackMajor) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(wServicePackMajor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wServicePackMinor) as usize - ptr as usize },
        278usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(wServicePackMinor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wSuiteMask) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(wSuiteMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wProductType) as usize - ptr as usize },
        282usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(wProductType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wReserved) as usize - ptr as usize },
        283usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(wReserved)
        )
    );
}
pub type OSVERSIONINFOEXW = _OSVERSIONINFOEXW;
pub type POSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub type LPOSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub type RTL_OSVERSIONINFOEXW = _OSVERSIONINFOEXW;
pub type PRTL_OSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub type OSVERSIONINFOEX = OSVERSIONINFOEXA;
pub type POSVERSIONINFOEX = POSVERSIONINFOEXA;
pub type LPOSVERSIONINFOEX = LPOSVERSIONINFOEXA;
extern "C" {
    pub fn VerSetConditionMask(
        ConditionMask: ULONGLONG,
        TypeMask: DWORD,
        Condition: BYTE,
    ) -> ULONGLONG;
}
extern "C" {
    pub fn RtlGetProductInfo(
        OSMajorVersion: DWORD,
        OSMinorVersion: DWORD,
        SpMajorVersion: DWORD,
        SpMinorVersion: DWORD,
        ReturnedProductType: PDWORD,
    ) -> BOOLEAN;
}
pub const _RTL_UMS_THREAD_INFO_CLASS_UmsThreadInvalidInfoClass: _RTL_UMS_THREAD_INFO_CLASS = 0;
pub const _RTL_UMS_THREAD_INFO_CLASS_UmsThreadUserContext: _RTL_UMS_THREAD_INFO_CLASS = 1;
pub const _RTL_UMS_THREAD_INFO_CLASS_UmsThreadPriority: _RTL_UMS_THREAD_INFO_CLASS = 2;
pub const _RTL_UMS_THREAD_INFO_CLASS_UmsThreadAffinity: _RTL_UMS_THREAD_INFO_CLASS = 3;
pub const _RTL_UMS_THREAD_INFO_CLASS_UmsThreadTeb: _RTL_UMS_THREAD_INFO_CLASS = 4;
pub const _RTL_UMS_THREAD_INFO_CLASS_UmsThreadIsSuspended: _RTL_UMS_THREAD_INFO_CLASS = 5;
pub const _RTL_UMS_THREAD_INFO_CLASS_UmsThreadIsTerminated: _RTL_UMS_THREAD_INFO_CLASS = 6;
pub const _RTL_UMS_THREAD_INFO_CLASS_UmsThreadMaxInfoClass: _RTL_UMS_THREAD_INFO_CLASS = 7;
pub type _RTL_UMS_THREAD_INFO_CLASS = ::std::os::raw::c_uint;
pub use self::_RTL_UMS_THREAD_INFO_CLASS as RTL_UMS_THREAD_INFO_CLASS;
pub type PRTL_UMS_THREAD_INFO_CLASS = *mut _RTL_UMS_THREAD_INFO_CLASS;
pub const _RTL_UMS_SCHEDULER_REASON_UmsSchedulerStartup: _RTL_UMS_SCHEDULER_REASON = 0;
pub const _RTL_UMS_SCHEDULER_REASON_UmsSchedulerThreadBlocked: _RTL_UMS_SCHEDULER_REASON = 1;
pub const _RTL_UMS_SCHEDULER_REASON_UmsSchedulerThreadYield: _RTL_UMS_SCHEDULER_REASON = 2;
pub type _RTL_UMS_SCHEDULER_REASON = ::std::os::raw::c_uint;
pub use self::_RTL_UMS_SCHEDULER_REASON as RTL_UMS_SCHEDULER_REASON;
pub type PRTL_UMS_SCHEDULER_REASON = *mut _RTL_UMS_SCHEDULER_REASON;
pub type PRTL_UMS_SCHEDULER_ENTRY_POINT = ::std::option::Option<
    unsafe extern "C" fn(arg1: RTL_UMS_SCHEDULER_REASON, arg2: ULONG_PTR, arg3: PVOID),
>;
extern "C" {
    pub fn RtlCrc32(Buffer: *const ::std::os::raw::c_void, Size: usize, InitialCrc: DWORD)
        -> DWORD;
}
extern "C" {
    pub fn RtlCrc64(
        Buffer: *const ::std::os::raw::c_void,
        Size: usize,
        InitialCrc: ULONGLONG,
    ) -> ULONGLONG;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION_DEBUG {
    pub Type: WORD,
    pub CreatorBackTraceIndex: WORD,
    pub CriticalSection: *mut _RTL_CRITICAL_SECTION,
    pub ProcessLocksList: LIST_ENTRY,
    pub EntryCount: DWORD,
    pub ContentionCount: DWORD,
    pub Flags: DWORD,
    pub CreatorBackTraceIndexHigh: WORD,
    pub SpareWORD: WORD,
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION_DEBUG() {
    const UNINIT: ::std::mem::MaybeUninit<_RTL_CRITICAL_SECTION_DEBUG> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RTL_CRITICAL_SECTION_DEBUG>(),
        48usize,
        concat!("Size of: ", stringify!(_RTL_CRITICAL_SECTION_DEBUG))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_CRITICAL_SECTION_DEBUG>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_CRITICAL_SECTION_DEBUG))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreatorBackTraceIndex) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(CreatorBackTraceIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CriticalSection) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(CriticalSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProcessLocksList) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(ProcessLocksList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntryCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(EntryCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ContentionCount) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(ContentionCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreatorBackTraceIndexHigh) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(CreatorBackTraceIndexHigh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SpareWORD) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(SpareWORD)
        )
    );
}
pub type RTL_CRITICAL_SECTION_DEBUG = _RTL_CRITICAL_SECTION_DEBUG;
pub type PRTL_CRITICAL_SECTION_DEBUG = *mut _RTL_CRITICAL_SECTION_DEBUG;
pub type RTL_RESOURCE_DEBUG = _RTL_CRITICAL_SECTION_DEBUG;
pub type PRTL_RESOURCE_DEBUG = *mut _RTL_CRITICAL_SECTION_DEBUG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION {
    pub DebugInfo: PRTL_CRITICAL_SECTION_DEBUG,
    pub LockCount: LONG,
    pub RecursionCount: LONG,
    pub OwningThread: HANDLE,
    pub LockSemaphore: HANDLE,
    pub SpinCount: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION() {
    const UNINIT: ::std::mem::MaybeUninit<_RTL_CRITICAL_SECTION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RTL_CRITICAL_SECTION>(),
        40usize,
        concat!("Size of: ", stringify!(_RTL_CRITICAL_SECTION))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_CRITICAL_SECTION>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_CRITICAL_SECTION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DebugInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(DebugInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LockCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(LockCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RecursionCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(RecursionCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OwningThread) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(OwningThread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LockSemaphore) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(LockSemaphore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SpinCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(SpinCount)
        )
    );
}
pub type RTL_CRITICAL_SECTION = _RTL_CRITICAL_SECTION;
pub type PRTL_CRITICAL_SECTION = *mut _RTL_CRITICAL_SECTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_SRWLOCK {
    pub Ptr: PVOID,
}
#[test]
fn bindgen_test_layout__RTL_SRWLOCK() {
    const UNINIT: ::std::mem::MaybeUninit<_RTL_SRWLOCK> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RTL_SRWLOCK>(),
        8usize,
        concat!("Size of: ", stringify!(_RTL_SRWLOCK))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_SRWLOCK>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_SRWLOCK))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_SRWLOCK),
            "::",
            stringify!(Ptr)
        )
    );
}
pub type RTL_SRWLOCK = _RTL_SRWLOCK;
pub type PRTL_SRWLOCK = *mut _RTL_SRWLOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CONDITION_VARIABLE {
    pub Ptr: PVOID,
}
#[test]
fn bindgen_test_layout__RTL_CONDITION_VARIABLE() {
    const UNINIT: ::std::mem::MaybeUninit<_RTL_CONDITION_VARIABLE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RTL_CONDITION_VARIABLE>(),
        8usize,
        concat!("Size of: ", stringify!(_RTL_CONDITION_VARIABLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_CONDITION_VARIABLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_CONDITION_VARIABLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CONDITION_VARIABLE),
            "::",
            stringify!(Ptr)
        )
    );
}
pub type RTL_CONDITION_VARIABLE = _RTL_CONDITION_VARIABLE;
pub type PRTL_CONDITION_VARIABLE = *mut _RTL_CONDITION_VARIABLE;
pub type PAPCFUNC = ::std::option::Option<unsafe extern "C" fn(Parameter: ULONG_PTR)>;
pub type PVECTORED_EXCEPTION_HANDLER =
    ::std::option::Option<unsafe extern "C" fn(ExceptionInfo: *mut _EXCEPTION_POINTERS) -> LONG>;
pub const _HEAP_INFORMATION_CLASS_HeapCompatibilityInformation: _HEAP_INFORMATION_CLASS = 0;
pub const _HEAP_INFORMATION_CLASS_HeapEnableTerminationOnCorruption: _HEAP_INFORMATION_CLASS = 1;
pub type _HEAP_INFORMATION_CLASS = ::std::os::raw::c_uint;
pub use self::_HEAP_INFORMATION_CLASS as HEAP_INFORMATION_CLASS;
pub type WORKERCALLBACKFUNC = ::std::option::Option<unsafe extern "C" fn(arg1: PVOID)>;
pub type APC_CALLBACK_FUNCTION =
    ::std::option::Option<unsafe extern "C" fn(arg1: DWORD, arg2: PVOID, arg3: PVOID)>;
pub type WAITORTIMERCALLBACKFUNC =
    ::std::option::Option<unsafe extern "C" fn(arg1: PVOID, arg2: BOOLEAN)>;
pub type WAITORTIMERCALLBACK = WAITORTIMERCALLBACKFUNC;
pub type PFLS_CALLBACK_FUNCTION = ::std::option::Option<unsafe extern "C" fn(lpFlsData: PVOID)>;
pub type PSECURE_MEMORY_CACHE_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(Addr: PVOID, Range: SIZE_T) -> BOOLEAN>;
pub const _ACTIVATION_CONTEXT_INFO_CLASS_ActivationContextBasicInformation:
    _ACTIVATION_CONTEXT_INFO_CLASS = 1;
pub const _ACTIVATION_CONTEXT_INFO_CLASS_ActivationContextDetailedInformation:
    _ACTIVATION_CONTEXT_INFO_CLASS = 2;
pub const _ACTIVATION_CONTEXT_INFO_CLASS_AssemblyDetailedInformationInActivationContext:
    _ACTIVATION_CONTEXT_INFO_CLASS = 3;
pub const _ACTIVATION_CONTEXT_INFO_CLASS_FileInformationInAssemblyOfAssemblyInActivationContext:
    _ACTIVATION_CONTEXT_INFO_CLASS = 4;
pub const _ACTIVATION_CONTEXT_INFO_CLASS_RunlevelInformationInActivationContext:
    _ACTIVATION_CONTEXT_INFO_CLASS = 5;
pub const _ACTIVATION_CONTEXT_INFO_CLASS_CompatibilityInformationInActivationContext:
    _ACTIVATION_CONTEXT_INFO_CLASS = 6;
pub const _ACTIVATION_CONTEXT_INFO_CLASS_ActivationContextManifestResourceName:
    _ACTIVATION_CONTEXT_INFO_CLASS = 7;
pub const _ACTIVATION_CONTEXT_INFO_CLASS_MaxActivationContextInfoClass:
    _ACTIVATION_CONTEXT_INFO_CLASS = 8;
pub const _ACTIVATION_CONTEXT_INFO_CLASS_AssemblyDetailedInformationInActivationContxt:
    _ACTIVATION_CONTEXT_INFO_CLASS = 3;
pub const _ACTIVATION_CONTEXT_INFO_CLASS_FileInformationInAssemblyOfAssemblyInActivationContxt:
    _ACTIVATION_CONTEXT_INFO_CLASS = 4;
pub type _ACTIVATION_CONTEXT_INFO_CLASS = ::std::os::raw::c_uint;
pub use self::_ACTIVATION_CONTEXT_INFO_CLASS as ACTIVATION_CONTEXT_INFO_CLASS;
pub const ACTCTX_REQUESTED_RUN_LEVEL_ACTCTX_RUN_LEVEL_UNSPECIFIED: ACTCTX_REQUESTED_RUN_LEVEL = 0;
pub const ACTCTX_REQUESTED_RUN_LEVEL_ACTCTX_RUN_LEVEL_AS_INVOKER: ACTCTX_REQUESTED_RUN_LEVEL = 1;
pub const ACTCTX_REQUESTED_RUN_LEVEL_ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE:
    ACTCTX_REQUESTED_RUN_LEVEL = 2;
pub const ACTCTX_REQUESTED_RUN_LEVEL_ACTCTX_RUN_LEVEL_REQUIRE_ADMIN: ACTCTX_REQUESTED_RUN_LEVEL = 3;
pub const ACTCTX_REQUESTED_RUN_LEVEL_ACTCTX_RUN_LEVEL_NUMBERS: ACTCTX_REQUESTED_RUN_LEVEL = 4;
pub type ACTCTX_REQUESTED_RUN_LEVEL = ::std::os::raw::c_uint;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN:
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE = 0;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS:
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE = 1;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION:
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE = 2;
pub type ACTCTX_COMPATIBILITY_ELEMENT_TYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_QUERY_INDEX {
    pub ulAssemblyIndex: DWORD,
    pub ulFileIndexInAssembly: DWORD,
}
#[test]
fn bindgen_test_layout__ACTIVATION_CONTEXT_QUERY_INDEX() {
    const UNINIT: ::std::mem::MaybeUninit<_ACTIVATION_CONTEXT_QUERY_INDEX> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ACTIVATION_CONTEXT_QUERY_INDEX>(),
        8usize,
        concat!("Size of: ", stringify!(_ACTIVATION_CONTEXT_QUERY_INDEX))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACTIVATION_CONTEXT_QUERY_INDEX>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACTIVATION_CONTEXT_QUERY_INDEX))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulAssemblyIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_QUERY_INDEX),
            "::",
            stringify!(ulAssemblyIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulFileIndexInAssembly) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_QUERY_INDEX),
            "::",
            stringify!(ulFileIndexInAssembly)
        )
    );
}
pub type ACTIVATION_CONTEXT_QUERY_INDEX = _ACTIVATION_CONTEXT_QUERY_INDEX;
pub type PACTIVATION_CONTEXT_QUERY_INDEX = *mut _ACTIVATION_CONTEXT_QUERY_INDEX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ASSEMBLY_FILE_DETAILED_INFORMATION {
    pub ulFlags: DWORD,
    pub ulFilenameLength: DWORD,
    pub ulPathLength: DWORD,
    pub lpFileName: PCWSTR,
    pub lpFilePath: PCWSTR,
}
#[test]
fn bindgen_test_layout__ASSEMBLY_FILE_DETAILED_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_ASSEMBLY_FILE_DETAILED_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ASSEMBLY_FILE_DETAILED_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_ASSEMBLY_FILE_DETAILED_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION),
            "::",
            stringify!(ulFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulFilenameLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION),
            "::",
            stringify!(ulFilenameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulPathLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION),
            "::",
            stringify!(ulPathLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lpFileName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION),
            "::",
            stringify!(lpFileName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lpFilePath) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION),
            "::",
            stringify!(lpFilePath)
        )
    );
}
pub type ASSEMBLY_FILE_DETAILED_INFORMATION = _ASSEMBLY_FILE_DETAILED_INFORMATION;
pub type PASSEMBLY_FILE_DETAILED_INFORMATION = *mut _ASSEMBLY_FILE_DETAILED_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
    pub ulFlags: DWORD,
    pub ulEncodedAssemblyIdentityLength: DWORD,
    pub ulManifestPathType: DWORD,
    pub ulManifestPathLength: DWORD,
    pub liManifestLastWriteTime: LARGE_INTEGER,
    pub ulPolicyPathType: DWORD,
    pub ulPolicyPathLength: DWORD,
    pub liPolicyLastWriteTime: LARGE_INTEGER,
    pub ulMetadataSatelliteRosterIndex: DWORD,
    pub ulManifestVersionMajor: DWORD,
    pub ulManifestVersionMinor: DWORD,
    pub ulPolicyVersionMajor: DWORD,
    pub ulPolicyVersionMinor: DWORD,
    pub ulAssemblyDirectoryNameLength: DWORD,
    pub lpAssemblyEncodedAssemblyIdentity: PCWSTR,
    pub lpAssemblyManifestPath: PCWSTR,
    pub lpAssemblyPolicyPath: PCWSTR,
    pub lpAssemblyDirectoryName: PCWSTR,
    pub ulFileCount: DWORD,
}
#[test]
fn bindgen_test_layout__ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulFlags)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ulEncodedAssemblyIdentityLength) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulEncodedAssemblyIdentityLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulManifestPathType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulManifestPathType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulManifestPathLength) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulManifestPathLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).liManifestLastWriteTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(liManifestLastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulPolicyPathType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulPolicyPathType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulPolicyPathLength) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulPolicyPathLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).liPolicyLastWriteTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(liPolicyLastWriteTime)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ulMetadataSatelliteRosterIndex) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulMetadataSatelliteRosterIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulManifestVersionMajor) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulManifestVersionMajor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulManifestVersionMinor) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulManifestVersionMinor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulPolicyVersionMajor) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulPolicyVersionMajor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulPolicyVersionMinor) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulPolicyVersionMinor)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ulAssemblyDirectoryNameLength) as usize - ptr as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulAssemblyDirectoryNameLength)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lpAssemblyEncodedAssemblyIdentity) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(lpAssemblyEncodedAssemblyIdentity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lpAssemblyManifestPath) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(lpAssemblyManifestPath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lpAssemblyPolicyPath) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(lpAssemblyPolicyPath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lpAssemblyDirectoryName) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(lpAssemblyDirectoryName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulFileCount) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulFileCount)
        )
    );
}
pub type ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION =
    _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
pub type PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION =
    *mut _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
    pub ulFlags: DWORD,
    pub RunLevel: ACTCTX_REQUESTED_RUN_LEVEL,
    pub UiAccess: DWORD,
}
#[test]
fn bindgen_test_layout__ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION),
            "::",
            stringify!(ulFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RunLevel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION),
            "::",
            stringify!(RunLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UiAccess) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION),
            "::",
            stringify!(UiAccess)
        )
    );
}
pub type ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
pub type PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = *mut _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COMPATIBILITY_CONTEXT_ELEMENT {
    pub Id: GUID,
    pub Type: ACTCTX_COMPATIBILITY_ELEMENT_TYPE,
}
#[test]
fn bindgen_test_layout__COMPATIBILITY_CONTEXT_ELEMENT() {
    const UNINIT: ::std::mem::MaybeUninit<_COMPATIBILITY_CONTEXT_ELEMENT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_COMPATIBILITY_CONTEXT_ELEMENT>(),
        20usize,
        concat!("Size of: ", stringify!(_COMPATIBILITY_CONTEXT_ELEMENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_COMPATIBILITY_CONTEXT_ELEMENT>(),
        4usize,
        concat!("Alignment of ", stringify!(_COMPATIBILITY_CONTEXT_ELEMENT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_COMPATIBILITY_CONTEXT_ELEMENT),
            "::",
            stringify!(Id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_COMPATIBILITY_CONTEXT_ELEMENT),
            "::",
            stringify!(Type)
        )
    );
}
pub type COMPATIBILITY_CONTEXT_ELEMENT = _COMPATIBILITY_CONTEXT_ELEMENT;
pub type PCOMPATIBILITY_CONTEXT_ELEMENT = *mut _COMPATIBILITY_CONTEXT_ELEMENT;
#[repr(C)]
#[derive(Debug)]
pub struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION {
    pub ElementCount: DWORD,
    pub Elements: __IncompleteArrayField<COMPATIBILITY_CONTEXT_ELEMENT>,
}
#[test]
fn bindgen_test_layout__ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ElementCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION),
            "::",
            stringify!(ElementCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Elements) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION),
            "::",
            stringify!(Elements)
        )
    );
}
pub type ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION =
    _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
pub type PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION =
    *mut _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SUPPORTED_OS_INFO {
    pub OsCount: WORD,
    pub MitigationExist: WORD,
    pub OsList: [WORD; 4usize],
}
#[test]
fn bindgen_test_layout__SUPPORTED_OS_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<_SUPPORTED_OS_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SUPPORTED_OS_INFO>(),
        12usize,
        concat!("Size of: ", stringify!(_SUPPORTED_OS_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_SUPPORTED_OS_INFO>(),
        2usize,
        concat!("Alignment of ", stringify!(_SUPPORTED_OS_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OsCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SUPPORTED_OS_INFO),
            "::",
            stringify!(OsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MitigationExist) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SUPPORTED_OS_INFO),
            "::",
            stringify!(MitigationExist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OsList) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SUPPORTED_OS_INFO),
            "::",
            stringify!(OsList)
        )
    );
}
pub type SUPPORTED_OS_INFO = _SUPPORTED_OS_INFO;
pub type PSUPPORTED_OS_INFO = *mut _SUPPORTED_OS_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION {
    pub dwFlags: DWORD,
    pub ulFormatVersion: DWORD,
    pub ulAssemblyCount: DWORD,
    pub ulRootManifestPathType: DWORD,
    pub ulRootManifestPathChars: DWORD,
    pub ulRootConfigurationPathType: DWORD,
    pub ulRootConfigurationPathChars: DWORD,
    pub ulAppDirPathType: DWORD,
    pub ulAppDirPathChars: DWORD,
    pub lpRootManifestPath: PCWSTR,
    pub lpRootConfigurationPath: PCWSTR,
    pub lpAppDirPath: PCWSTR,
}
#[test]
fn bindgen_test_layout__ACTIVATION_CONTEXT_DETAILED_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_ACTIVATION_CONTEXT_DETAILED_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(dwFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulFormatVersion) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(ulFormatVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulAssemblyCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(ulAssemblyCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulRootManifestPathType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(ulRootManifestPathType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulRootManifestPathChars) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(ulRootManifestPathChars)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulRootConfigurationPathType) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(ulRootConfigurationPathType)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ulRootConfigurationPathChars) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(ulRootConfigurationPathChars)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulAppDirPathType) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(ulAppDirPathType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulAppDirPathChars) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(ulAppDirPathChars)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lpRootManifestPath) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(lpRootManifestPath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lpRootConfigurationPath) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(lpRootConfigurationPath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lpAppDirPath) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(lpAppDirPath)
        )
    );
}
pub type ACTIVATION_CONTEXT_DETAILED_INFORMATION = _ACTIVATION_CONTEXT_DETAILED_INFORMATION;
pub type PACTIVATION_CONTEXT_DETAILED_INFORMATION = *mut _ACTIVATION_CONTEXT_DETAILED_INFORMATION;
pub type PCACTIVATION_CONTEXT_QUERY_INDEX = *const _ACTIVATION_CONTEXT_QUERY_INDEX;
pub type PCASSEMBLY_FILE_DETAILED_INFORMATION = *const ASSEMBLY_FILE_DETAILED_INFORMATION;
pub type PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION =
    *const _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
pub type PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION =
    *const _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
pub type PCCOMPATIBILITY_CONTEXT_ELEMENT = *const _COMPATIBILITY_CONTEXT_ELEMENT;
pub type PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION =
    *const _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
pub type PCACTIVATION_CONTEXT_DETAILED_INFORMATION =
    *const _ACTIVATION_CONTEXT_DETAILED_INFORMATION;
pub type RTL_VERIFIER_DLL_LOAD_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(DllName: PWSTR, DllBase: PVOID, DllSize: SIZE_T, Reserved: PVOID),
>;
pub type RTL_VERIFIER_DLL_UNLOAD_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(DllName: PWSTR, DllBase: PVOID, DllSize: SIZE_T, Reserved: PVOID),
>;
pub type RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(AllocationBase: PVOID, AllocationSize: SIZE_T)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_VERIFIER_THUNK_DESCRIPTOR {
    pub ThunkName: PCHAR,
    pub ThunkOldAddress: PVOID,
    pub ThunkNewAddress: PVOID,
}
#[test]
fn bindgen_test_layout__RTL_VERIFIER_THUNK_DESCRIPTOR() {
    const UNINIT: ::std::mem::MaybeUninit<_RTL_VERIFIER_THUNK_DESCRIPTOR> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RTL_VERIFIER_THUNK_DESCRIPTOR>(),
        24usize,
        concat!("Size of: ", stringify!(_RTL_VERIFIER_THUNK_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_VERIFIER_THUNK_DESCRIPTOR>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_VERIFIER_THUNK_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ThunkName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_VERIFIER_THUNK_DESCRIPTOR),
            "::",
            stringify!(ThunkName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ThunkOldAddress) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_VERIFIER_THUNK_DESCRIPTOR),
            "::",
            stringify!(ThunkOldAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ThunkNewAddress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_VERIFIER_THUNK_DESCRIPTOR),
            "::",
            stringify!(ThunkNewAddress)
        )
    );
}
pub type RTL_VERIFIER_THUNK_DESCRIPTOR = _RTL_VERIFIER_THUNK_DESCRIPTOR;
pub type PRTL_VERIFIER_THUNK_DESCRIPTOR = *mut _RTL_VERIFIER_THUNK_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_VERIFIER_DLL_DESCRIPTOR {
    pub DllName: PWCHAR,
    pub DllFlags: DWORD,
    pub DllAddress: PVOID,
    pub DllThunks: PRTL_VERIFIER_THUNK_DESCRIPTOR,
}
#[test]
fn bindgen_test_layout__RTL_VERIFIER_DLL_DESCRIPTOR() {
    const UNINIT: ::std::mem::MaybeUninit<_RTL_VERIFIER_DLL_DESCRIPTOR> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RTL_VERIFIER_DLL_DESCRIPTOR>(),
        32usize,
        concat!("Size of: ", stringify!(_RTL_VERIFIER_DLL_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_VERIFIER_DLL_DESCRIPTOR>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_VERIFIER_DLL_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DllName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_VERIFIER_DLL_DESCRIPTOR),
            "::",
            stringify!(DllName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DllFlags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_VERIFIER_DLL_DESCRIPTOR),
            "::",
            stringify!(DllFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DllAddress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_VERIFIER_DLL_DESCRIPTOR),
            "::",
            stringify!(DllAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DllThunks) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_VERIFIER_DLL_DESCRIPTOR),
            "::",
            stringify!(DllThunks)
        )
    );
}
pub type RTL_VERIFIER_DLL_DESCRIPTOR = _RTL_VERIFIER_DLL_DESCRIPTOR;
pub type PRTL_VERIFIER_DLL_DESCRIPTOR = *mut _RTL_VERIFIER_DLL_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_VERIFIER_PROVIDER_DESCRIPTOR {
    pub Length: DWORD,
    pub ProviderDlls: PRTL_VERIFIER_DLL_DESCRIPTOR,
    pub ProviderDllLoadCallback: RTL_VERIFIER_DLL_LOAD_CALLBACK,
    pub ProviderDllUnloadCallback: RTL_VERIFIER_DLL_UNLOAD_CALLBACK,
    pub VerifierImage: PWSTR,
    pub VerifierFlags: DWORD,
    pub VerifierDebug: DWORD,
    pub RtlpGetStackTraceAddress: PVOID,
    pub RtlpDebugPageHeapCreate: PVOID,
    pub RtlpDebugPageHeapDestroy: PVOID,
    pub ProviderNtdllHeapFreeCallback: RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK,
}
#[test]
fn bindgen_test_layout__RTL_VERIFIER_PROVIDER_DESCRIPTOR() {
    const UNINIT: ::std::mem::MaybeUninit<_RTL_VERIFIER_PROVIDER_DESCRIPTOR> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RTL_VERIFIER_PROVIDER_DESCRIPTOR>(),
        80usize,
        concat!("Size of: ", stringify!(_RTL_VERIFIER_PROVIDER_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_VERIFIER_PROVIDER_DESCRIPTOR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_RTL_VERIFIER_PROVIDER_DESCRIPTOR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_VERIFIER_PROVIDER_DESCRIPTOR),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProviderDlls) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_VERIFIER_PROVIDER_DESCRIPTOR),
            "::",
            stringify!(ProviderDlls)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProviderDllLoadCallback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_VERIFIER_PROVIDER_DESCRIPTOR),
            "::",
            stringify!(ProviderDllLoadCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProviderDllUnloadCallback) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_VERIFIER_PROVIDER_DESCRIPTOR),
            "::",
            stringify!(ProviderDllUnloadCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VerifierImage) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_VERIFIER_PROVIDER_DESCRIPTOR),
            "::",
            stringify!(VerifierImage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VerifierFlags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_VERIFIER_PROVIDER_DESCRIPTOR),
            "::",
            stringify!(VerifierFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VerifierDebug) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_VERIFIER_PROVIDER_DESCRIPTOR),
            "::",
            stringify!(VerifierDebug)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RtlpGetStackTraceAddress) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_VERIFIER_PROVIDER_DESCRIPTOR),
            "::",
            stringify!(RtlpGetStackTraceAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RtlpDebugPageHeapCreate) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_VERIFIER_PROVIDER_DESCRIPTOR),
            "::",
            stringify!(RtlpDebugPageHeapCreate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RtlpDebugPageHeapDestroy) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_VERIFIER_PROVIDER_DESCRIPTOR),
            "::",
            stringify!(RtlpDebugPageHeapDestroy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ProviderNtdllHeapFreeCallback) as usize - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_VERIFIER_PROVIDER_DESCRIPTOR),
            "::",
            stringify!(ProviderNtdllHeapFreeCallback)
        )
    );
}
pub type RTL_VERIFIER_PROVIDER_DESCRIPTOR = _RTL_VERIFIER_PROVIDER_DESCRIPTOR;
pub type PRTL_VERIFIER_PROVIDER_DESCRIPTOR = *mut _RTL_VERIFIER_PROVIDER_DESCRIPTOR;
extern "C" {
    pub fn RtlApplicationVerifierStop(
        Code: ULONG_PTR,
        Message: PSTR,
        Param1: ULONG_PTR,
        Description1: PSTR,
        Param2: ULONG_PTR,
        Description2: PSTR,
        Param3: ULONG_PTR,
        Description3: PSTR,
        Param4: ULONG_PTR,
        Description4: PSTR,
    );
}
extern "C" {
    pub fn RtlSetHeapInformation(
        HeapHandle: PVOID,
        HeapInformationClass: HEAP_INFORMATION_CLASS,
        HeapInformation: PVOID,
        HeapInformationLength: SIZE_T,
    ) -> DWORD;
}
extern "C" {
    pub fn RtlQueryHeapInformation(
        HeapHandle: PVOID,
        HeapInformationClass: HEAP_INFORMATION_CLASS,
        HeapInformation: PVOID,
        HeapInformationLength: SIZE_T,
        ReturnLength: PSIZE_T,
    ) -> DWORD;
}
extern "C" {
    pub fn RtlMultipleAllocateHeap(
        HeapHandle: PVOID,
        Flags: DWORD,
        Size: SIZE_T,
        Count: DWORD,
        Array: *mut PVOID,
    ) -> DWORD;
}
extern "C" {
    pub fn RtlMultipleFreeHeap(
        HeapHandle: PVOID,
        Flags: DWORD,
        Count: DWORD,
        Array: *mut PVOID,
    ) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HARDWARE_COUNTER_DATA {
    pub Type: HARDWARE_COUNTER_TYPE,
    pub Reserved: DWORD,
    pub Value: DWORD64,
}
#[test]
fn bindgen_test_layout__HARDWARE_COUNTER_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<_HARDWARE_COUNTER_DATA> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_HARDWARE_COUNTER_DATA>(),
        16usize,
        concat!("Size of: ", stringify!(_HARDWARE_COUNTER_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_HARDWARE_COUNTER_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(_HARDWARE_COUNTER_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_HARDWARE_COUNTER_DATA),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_HARDWARE_COUNTER_DATA),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_HARDWARE_COUNTER_DATA),
            "::",
            stringify!(Value)
        )
    );
}
pub type HARDWARE_COUNTER_DATA = _HARDWARE_COUNTER_DATA;
pub type PHARDWARE_COUNTER_DATA = *mut _HARDWARE_COUNTER_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFORMANCE_DATA {
    pub Size: WORD,
    pub Version: BYTE,
    pub HwCountersCount: BYTE,
    pub ContextSwitchCount: DWORD,
    pub WaitReasonBitMap: DWORD64,
    pub CycleTime: DWORD64,
    pub RetryCount: DWORD,
    pub Reserved: DWORD,
    pub HwCounters: [HARDWARE_COUNTER_DATA; 16usize],
}
#[test]
fn bindgen_test_layout__PERFORMANCE_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<_PERFORMANCE_DATA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PERFORMANCE_DATA>(),
        288usize,
        concat!("Size of: ", stringify!(_PERFORMANCE_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_PERFORMANCE_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(_PERFORMANCE_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PERFORMANCE_DATA),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_PERFORMANCE_DATA),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HwCountersCount) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_PERFORMANCE_DATA),
            "::",
            stringify!(HwCountersCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ContextSwitchCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PERFORMANCE_DATA),
            "::",
            stringify!(ContextSwitchCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WaitReasonBitMap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PERFORMANCE_DATA),
            "::",
            stringify!(WaitReasonBitMap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CycleTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PERFORMANCE_DATA),
            "::",
            stringify!(CycleTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RetryCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PERFORMANCE_DATA),
            "::",
            stringify!(RetryCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_PERFORMANCE_DATA),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HwCounters) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PERFORMANCE_DATA),
            "::",
            stringify!(HwCounters)
        )
    );
}
pub type PERFORMANCE_DATA = _PERFORMANCE_DATA;
pub type PPERFORMANCE_DATA = *mut _PERFORMANCE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENTLOGRECORD {
    pub Length: DWORD,
    pub Reserved: DWORD,
    pub RecordNumber: DWORD,
    pub TimeGenerated: DWORD,
    pub TimeWritten: DWORD,
    pub EventID: DWORD,
    pub EventType: WORD,
    pub NumStrings: WORD,
    pub EventCategory: WORD,
    pub ReservedFlags: WORD,
    pub ClosingRecordNumber: DWORD,
    pub StringOffset: DWORD,
    pub UserSidLength: DWORD,
    pub UserSidOffset: DWORD,
    pub DataLength: DWORD,
    pub DataOffset: DWORD,
}
#[test]
fn bindgen_test_layout__EVENTLOGRECORD() {
    const UNINIT: ::std::mem::MaybeUninit<_EVENTLOGRECORD> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_EVENTLOGRECORD>(),
        56usize,
        concat!("Size of: ", stringify!(_EVENTLOGRECORD))
    );
    assert_eq!(
        ::std::mem::align_of::<_EVENTLOGRECORD>(),
        4usize,
        concat!("Alignment of ", stringify!(_EVENTLOGRECORD))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RecordNumber) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(RecordNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeGenerated) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(TimeGenerated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeWritten) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(TimeWritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EventID) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(EventID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EventType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(EventType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumStrings) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(NumStrings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EventCategory) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(EventCategory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFlags) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(ReservedFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClosingRecordNumber) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(ClosingRecordNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StringOffset) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(StringOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserSidLength) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(UserSidLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserSidOffset) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(UserSidOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataLength) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(DataLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataOffset) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(DataOffset)
        )
    );
}
pub type EVENTLOGRECORD = _EVENTLOGRECORD;
pub type PEVENTLOGRECORD = *mut _EVENTLOGRECORD;
#[repr(C)]
#[derive(Debug)]
pub struct _EVENTSFORLOGFILE {
    pub ulSize: DWORD,
    pub szLogicalLogFile: [WCHAR; 256usize],
    pub ulNumRecords: DWORD,
    pub pEventLogRecords: __IncompleteArrayField<EVENTLOGRECORD>,
}
#[test]
fn bindgen_test_layout__EVENTSFORLOGFILE() {
    const UNINIT: ::std::mem::MaybeUninit<_EVENTSFORLOGFILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_EVENTSFORLOGFILE>(),
        520usize,
        concat!("Size of: ", stringify!(_EVENTSFORLOGFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_EVENTSFORLOGFILE>(),
        4usize,
        concat!("Alignment of ", stringify!(_EVENTSFORLOGFILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTSFORLOGFILE),
            "::",
            stringify!(ulSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).szLogicalLogFile) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTSFORLOGFILE),
            "::",
            stringify!(szLogicalLogFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulNumRecords) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTSFORLOGFILE),
            "::",
            stringify!(ulNumRecords)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pEventLogRecords) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTSFORLOGFILE),
            "::",
            stringify!(pEventLogRecords)
        )
    );
}
pub type EVENTSFORLOGFILE = _EVENTSFORLOGFILE;
pub type PEVENTSFORLOGFILE = *mut _EVENTSFORLOGFILE;
#[repr(C)]
#[derive(Debug)]
pub struct _PACKEDEVENTINFO {
    pub ulSize: DWORD,
    pub ulNumEventsForLogFile: DWORD,
    pub ulOffsets: __IncompleteArrayField<DWORD>,
}
#[test]
fn bindgen_test_layout__PACKEDEVENTINFO() {
    const UNINIT: ::std::mem::MaybeUninit<_PACKEDEVENTINFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PACKEDEVENTINFO>(),
        8usize,
        concat!("Size of: ", stringify!(_PACKEDEVENTINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_PACKEDEVENTINFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_PACKEDEVENTINFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PACKEDEVENTINFO),
            "::",
            stringify!(ulSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulNumEventsForLogFile) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PACKEDEVENTINFO),
            "::",
            stringify!(ulNumEventsForLogFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulOffsets) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PACKEDEVENTINFO),
            "::",
            stringify!(ulOffsets)
        )
    );
}
pub type PACKEDEVENTINFO = _PACKEDEVENTINFO;
pub type PPACKEDEVENTINFO = *mut _PACKEDEVENTINFO;
pub const _CM_SERVICE_NODE_TYPE_DriverType: _CM_SERVICE_NODE_TYPE = 1;
pub const _CM_SERVICE_NODE_TYPE_FileSystemType: _CM_SERVICE_NODE_TYPE = 2;
pub const _CM_SERVICE_NODE_TYPE_Win32ServiceOwnProcess: _CM_SERVICE_NODE_TYPE = 16;
pub const _CM_SERVICE_NODE_TYPE_Win32ServiceShareProcess: _CM_SERVICE_NODE_TYPE = 32;
pub const _CM_SERVICE_NODE_TYPE_AdapterType: _CM_SERVICE_NODE_TYPE = 4;
pub const _CM_SERVICE_NODE_TYPE_RecognizerType: _CM_SERVICE_NODE_TYPE = 8;
pub type _CM_SERVICE_NODE_TYPE = ::std::os::raw::c_uint;
pub use self::_CM_SERVICE_NODE_TYPE as SERVICE_NODE_TYPE;
pub const _CM_SERVICE_LOAD_TYPE_BootLoad: _CM_SERVICE_LOAD_TYPE = 0;
pub const _CM_SERVICE_LOAD_TYPE_SystemLoad: _CM_SERVICE_LOAD_TYPE = 1;
pub const _CM_SERVICE_LOAD_TYPE_AutoLoad: _CM_SERVICE_LOAD_TYPE = 2;
pub const _CM_SERVICE_LOAD_TYPE_DemandLoad: _CM_SERVICE_LOAD_TYPE = 3;
pub const _CM_SERVICE_LOAD_TYPE_DisableLoad: _CM_SERVICE_LOAD_TYPE = 4;
pub type _CM_SERVICE_LOAD_TYPE = ::std::os::raw::c_uint;
pub use self::_CM_SERVICE_LOAD_TYPE as SERVICE_LOAD_TYPE;
pub const _CM_ERROR_CONTROL_TYPE_IgnoreError: _CM_ERROR_CONTROL_TYPE = 0;
pub const _CM_ERROR_CONTROL_TYPE_NormalError: _CM_ERROR_CONTROL_TYPE = 1;
pub const _CM_ERROR_CONTROL_TYPE_SevereError: _CM_ERROR_CONTROL_TYPE = 2;
pub const _CM_ERROR_CONTROL_TYPE_CriticalError: _CM_ERROR_CONTROL_TYPE = 3;
pub type _CM_ERROR_CONTROL_TYPE = ::std::os::raw::c_uint;
pub use self::_CM_ERROR_CONTROL_TYPE as SERVICE_ERROR_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_ERASE {
    pub Type: DWORD,
    pub Immediate: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TAPE_ERASE() {
    const UNINIT: ::std::mem::MaybeUninit<_TAPE_ERASE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TAPE_ERASE>(),
        8usize,
        concat!("Size of: ", stringify!(_TAPE_ERASE))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_ERASE>(),
        4usize,
        concat!("Alignment of ", stringify!(_TAPE_ERASE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_ERASE),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Immediate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_ERASE),
            "::",
            stringify!(Immediate)
        )
    );
}
pub type TAPE_ERASE = _TAPE_ERASE;
pub type PTAPE_ERASE = *mut _TAPE_ERASE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_PREPARE {
    pub Operation: DWORD,
    pub Immediate: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TAPE_PREPARE() {
    const UNINIT: ::std::mem::MaybeUninit<_TAPE_PREPARE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TAPE_PREPARE>(),
        8usize,
        concat!("Size of: ", stringify!(_TAPE_PREPARE))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_PREPARE>(),
        4usize,
        concat!("Alignment of ", stringify!(_TAPE_PREPARE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_PREPARE),
            "::",
            stringify!(Operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Immediate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_PREPARE),
            "::",
            stringify!(Immediate)
        )
    );
}
pub type TAPE_PREPARE = _TAPE_PREPARE;
pub type PTAPE_PREPARE = *mut _TAPE_PREPARE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_WRITE_MARKS {
    pub Type: DWORD,
    pub Count: DWORD,
    pub Immediate: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TAPE_WRITE_MARKS() {
    const UNINIT: ::std::mem::MaybeUninit<_TAPE_WRITE_MARKS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TAPE_WRITE_MARKS>(),
        12usize,
        concat!("Size of: ", stringify!(_TAPE_WRITE_MARKS))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_WRITE_MARKS>(),
        4usize,
        concat!("Alignment of ", stringify!(_TAPE_WRITE_MARKS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_WRITE_MARKS),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_WRITE_MARKS),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Immediate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_WRITE_MARKS),
            "::",
            stringify!(Immediate)
        )
    );
}
pub type TAPE_WRITE_MARKS = _TAPE_WRITE_MARKS;
pub type PTAPE_WRITE_MARKS = *mut _TAPE_WRITE_MARKS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TAPE_GET_POSITION {
    pub Type: DWORD,
    pub Partition: DWORD,
    pub Offset: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__TAPE_GET_POSITION() {
    const UNINIT: ::std::mem::MaybeUninit<_TAPE_GET_POSITION> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TAPE_GET_POSITION>(),
        16usize,
        concat!("Size of: ", stringify!(_TAPE_GET_POSITION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_GET_POSITION>(),
        8usize,
        concat!("Alignment of ", stringify!(_TAPE_GET_POSITION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_POSITION),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Partition) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_POSITION),
            "::",
            stringify!(Partition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_POSITION),
            "::",
            stringify!(Offset)
        )
    );
}
pub type TAPE_GET_POSITION = _TAPE_GET_POSITION;
pub type PTAPE_GET_POSITION = *mut _TAPE_GET_POSITION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TAPE_SET_POSITION {
    pub Method: DWORD,
    pub Partition: DWORD,
    pub Offset: LARGE_INTEGER,
    pub Immediate: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TAPE_SET_POSITION() {
    const UNINIT: ::std::mem::MaybeUninit<_TAPE_SET_POSITION> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TAPE_SET_POSITION>(),
        24usize,
        concat!("Size of: ", stringify!(_TAPE_SET_POSITION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_SET_POSITION>(),
        8usize,
        concat!("Alignment of ", stringify!(_TAPE_SET_POSITION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Method) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_SET_POSITION),
            "::",
            stringify!(Method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Partition) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_SET_POSITION),
            "::",
            stringify!(Partition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_SET_POSITION),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Immediate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_SET_POSITION),
            "::",
            stringify!(Immediate)
        )
    );
}
pub type TAPE_SET_POSITION = _TAPE_SET_POSITION;
pub type PTAPE_SET_POSITION = *mut _TAPE_SET_POSITION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_GET_DRIVE_PARAMETERS {
    pub ECC: BOOLEAN,
    pub Compression: BOOLEAN,
    pub DataPadding: BOOLEAN,
    pub ReportSetmarks: BOOLEAN,
    pub DefaultBlockSize: DWORD,
    pub MaximumBlockSize: DWORD,
    pub MinimumBlockSize: DWORD,
    pub MaximumPartitionCount: DWORD,
    pub FeaturesLow: DWORD,
    pub FeaturesHigh: DWORD,
    pub EOTWarningZoneSize: DWORD,
}
#[test]
fn bindgen_test_layout__TAPE_GET_DRIVE_PARAMETERS() {
    const UNINIT: ::std::mem::MaybeUninit<_TAPE_GET_DRIVE_PARAMETERS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TAPE_GET_DRIVE_PARAMETERS>(),
        32usize,
        concat!("Size of: ", stringify!(_TAPE_GET_DRIVE_PARAMETERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_GET_DRIVE_PARAMETERS>(),
        4usize,
        concat!("Alignment of ", stringify!(_TAPE_GET_DRIVE_PARAMETERS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ECC) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(ECC)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Compression) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(Compression)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataPadding) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(DataPadding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReportSetmarks) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(ReportSetmarks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DefaultBlockSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(DefaultBlockSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumBlockSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(MaximumBlockSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinimumBlockSize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(MinimumBlockSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumPartitionCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(MaximumPartitionCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FeaturesLow) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(FeaturesLow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FeaturesHigh) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(FeaturesHigh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EOTWarningZoneSize) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(EOTWarningZoneSize)
        )
    );
}
pub type TAPE_GET_DRIVE_PARAMETERS = _TAPE_GET_DRIVE_PARAMETERS;
pub type PTAPE_GET_DRIVE_PARAMETERS = *mut _TAPE_GET_DRIVE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_SET_DRIVE_PARAMETERS {
    pub ECC: BOOLEAN,
    pub Compression: BOOLEAN,
    pub DataPadding: BOOLEAN,
    pub ReportSetmarks: BOOLEAN,
    pub EOTWarningZoneSize: DWORD,
}
#[test]
fn bindgen_test_layout__TAPE_SET_DRIVE_PARAMETERS() {
    const UNINIT: ::std::mem::MaybeUninit<_TAPE_SET_DRIVE_PARAMETERS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TAPE_SET_DRIVE_PARAMETERS>(),
        8usize,
        concat!("Size of: ", stringify!(_TAPE_SET_DRIVE_PARAMETERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_SET_DRIVE_PARAMETERS>(),
        4usize,
        concat!("Alignment of ", stringify!(_TAPE_SET_DRIVE_PARAMETERS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ECC) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_SET_DRIVE_PARAMETERS),
            "::",
            stringify!(ECC)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Compression) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_SET_DRIVE_PARAMETERS),
            "::",
            stringify!(Compression)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataPadding) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_SET_DRIVE_PARAMETERS),
            "::",
            stringify!(DataPadding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReportSetmarks) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_SET_DRIVE_PARAMETERS),
            "::",
            stringify!(ReportSetmarks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EOTWarningZoneSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_SET_DRIVE_PARAMETERS),
            "::",
            stringify!(EOTWarningZoneSize)
        )
    );
}
pub type TAPE_SET_DRIVE_PARAMETERS = _TAPE_SET_DRIVE_PARAMETERS;
pub type PTAPE_SET_DRIVE_PARAMETERS = *mut _TAPE_SET_DRIVE_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TAPE_GET_MEDIA_PARAMETERS {
    pub Capacity: LARGE_INTEGER,
    pub Remaining: LARGE_INTEGER,
    pub BlockSize: DWORD,
    pub PartitionCount: DWORD,
    pub WriteProtected: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TAPE_GET_MEDIA_PARAMETERS() {
    const UNINIT: ::std::mem::MaybeUninit<_TAPE_GET_MEDIA_PARAMETERS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TAPE_GET_MEDIA_PARAMETERS>(),
        32usize,
        concat!("Size of: ", stringify!(_TAPE_GET_MEDIA_PARAMETERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_GET_MEDIA_PARAMETERS>(),
        8usize,
        concat!("Alignment of ", stringify!(_TAPE_GET_MEDIA_PARAMETERS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Capacity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_MEDIA_PARAMETERS),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Remaining) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_MEDIA_PARAMETERS),
            "::",
            stringify!(Remaining)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BlockSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_MEDIA_PARAMETERS),
            "::",
            stringify!(BlockSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PartitionCount) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_MEDIA_PARAMETERS),
            "::",
            stringify!(PartitionCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteProtected) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_MEDIA_PARAMETERS),
            "::",
            stringify!(WriteProtected)
        )
    );
}
pub type TAPE_GET_MEDIA_PARAMETERS = _TAPE_GET_MEDIA_PARAMETERS;
pub type PTAPE_GET_MEDIA_PARAMETERS = *mut _TAPE_GET_MEDIA_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_SET_MEDIA_PARAMETERS {
    pub BlockSize: DWORD,
}
#[test]
fn bindgen_test_layout__TAPE_SET_MEDIA_PARAMETERS() {
    const UNINIT: ::std::mem::MaybeUninit<_TAPE_SET_MEDIA_PARAMETERS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TAPE_SET_MEDIA_PARAMETERS>(),
        4usize,
        concat!("Size of: ", stringify!(_TAPE_SET_MEDIA_PARAMETERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_SET_MEDIA_PARAMETERS>(),
        4usize,
        concat!("Alignment of ", stringify!(_TAPE_SET_MEDIA_PARAMETERS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BlockSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_SET_MEDIA_PARAMETERS),
            "::",
            stringify!(BlockSize)
        )
    );
}
pub type TAPE_SET_MEDIA_PARAMETERS = _TAPE_SET_MEDIA_PARAMETERS;
pub type PTAPE_SET_MEDIA_PARAMETERS = *mut _TAPE_SET_MEDIA_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_CREATE_PARTITION {
    pub Method: DWORD,
    pub Count: DWORD,
    pub Size: DWORD,
}
#[test]
fn bindgen_test_layout__TAPE_CREATE_PARTITION() {
    const UNINIT: ::std::mem::MaybeUninit<_TAPE_CREATE_PARTITION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TAPE_CREATE_PARTITION>(),
        12usize,
        concat!("Size of: ", stringify!(_TAPE_CREATE_PARTITION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_CREATE_PARTITION>(),
        4usize,
        concat!("Alignment of ", stringify!(_TAPE_CREATE_PARTITION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Method) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_CREATE_PARTITION),
            "::",
            stringify!(Method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_CREATE_PARTITION),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_CREATE_PARTITION),
            "::",
            stringify!(Size)
        )
    );
}
pub type TAPE_CREATE_PARTITION = _TAPE_CREATE_PARTITION;
pub type PTAPE_CREATE_PARTITION = *mut _TAPE_CREATE_PARTITION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_WMI_OPERATIONS {
    pub Method: DWORD,
    pub DataBufferSize: DWORD,
    pub DataBuffer: PVOID,
}
#[test]
fn bindgen_test_layout__TAPE_WMI_OPERATIONS() {
    const UNINIT: ::std::mem::MaybeUninit<_TAPE_WMI_OPERATIONS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TAPE_WMI_OPERATIONS>(),
        16usize,
        concat!("Size of: ", stringify!(_TAPE_WMI_OPERATIONS))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_WMI_OPERATIONS>(),
        8usize,
        concat!("Alignment of ", stringify!(_TAPE_WMI_OPERATIONS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Method) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_WMI_OPERATIONS),
            "::",
            stringify!(Method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataBufferSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_WMI_OPERATIONS),
            "::",
            stringify!(DataBufferSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataBuffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_WMI_OPERATIONS),
            "::",
            stringify!(DataBuffer)
        )
    );
}
pub type TAPE_WMI_OPERATIONS = _TAPE_WMI_OPERATIONS;
pub type PTAPE_WMI_OPERATIONS = *mut _TAPE_WMI_OPERATIONS;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveProblemNone: _TAPE_DRIVE_PROBLEM_TYPE = 0;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveReadWriteWarning: _TAPE_DRIVE_PROBLEM_TYPE = 1;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveReadWriteError: _TAPE_DRIVE_PROBLEM_TYPE = 2;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveReadWarning: _TAPE_DRIVE_PROBLEM_TYPE = 3;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveWriteWarning: _TAPE_DRIVE_PROBLEM_TYPE = 4;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveReadError: _TAPE_DRIVE_PROBLEM_TYPE = 5;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveWriteError: _TAPE_DRIVE_PROBLEM_TYPE = 6;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveHardwareError: _TAPE_DRIVE_PROBLEM_TYPE = 7;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveUnsupportedMedia: _TAPE_DRIVE_PROBLEM_TYPE = 8;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveScsiConnectionError: _TAPE_DRIVE_PROBLEM_TYPE = 9;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveTimetoClean: _TAPE_DRIVE_PROBLEM_TYPE = 10;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveCleanDriveNow: _TAPE_DRIVE_PROBLEM_TYPE = 11;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveMediaLifeExpired: _TAPE_DRIVE_PROBLEM_TYPE = 12;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveSnappedTape: _TAPE_DRIVE_PROBLEM_TYPE = 13;
pub type _TAPE_DRIVE_PROBLEM_TYPE = ::std::os::raw::c_uint;
pub use self::_TAPE_DRIVE_PROBLEM_TYPE as TAPE_DRIVE_PROBLEM_TYPE;
pub type TP_VERSION = DWORD;
pub type PTP_VERSION = *mut DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_CALLBACK_INSTANCE {
    _unused: [u8; 0],
}
pub type TP_CALLBACK_INSTANCE = _TP_CALLBACK_INSTANCE;
pub type PTP_CALLBACK_INSTANCE = *mut _TP_CALLBACK_INSTANCE;
pub type PTP_SIMPLE_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(Instance: PTP_CALLBACK_INSTANCE, Context: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_POOL {
    _unused: [u8; 0],
}
pub type TP_POOL = _TP_POOL;
pub type PTP_POOL = *mut _TP_POOL;
pub const _TP_CALLBACK_PRIORITY_TP_CALLBACK_PRIORITY_HIGH: _TP_CALLBACK_PRIORITY = 0;
pub const _TP_CALLBACK_PRIORITY_TP_CALLBACK_PRIORITY_NORMAL: _TP_CALLBACK_PRIORITY = 1;
pub const _TP_CALLBACK_PRIORITY_TP_CALLBACK_PRIORITY_LOW: _TP_CALLBACK_PRIORITY = 2;
pub const _TP_CALLBACK_PRIORITY_TP_CALLBACK_PRIORITY_INVALID: _TP_CALLBACK_PRIORITY = 3;
pub const _TP_CALLBACK_PRIORITY_TP_CALLBACK_PRIORITY_COUNT: _TP_CALLBACK_PRIORITY = 3;
pub type _TP_CALLBACK_PRIORITY = ::std::os::raw::c_uint;
pub use self::_TP_CALLBACK_PRIORITY as TP_CALLBACK_PRIORITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_POOL_STACK_INFORMATION {
    pub StackReserve: SIZE_T,
    pub StackCommit: SIZE_T,
}
#[test]
fn bindgen_test_layout__TP_POOL_STACK_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_TP_POOL_STACK_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TP_POOL_STACK_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_TP_POOL_STACK_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TP_POOL_STACK_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_TP_POOL_STACK_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StackReserve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_POOL_STACK_INFORMATION),
            "::",
            stringify!(StackReserve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StackCommit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_POOL_STACK_INFORMATION),
            "::",
            stringify!(StackCommit)
        )
    );
}
pub type TP_POOL_STACK_INFORMATION = _TP_POOL_STACK_INFORMATION;
pub type PTP_POOL_STACK_INFORMATION = *mut _TP_POOL_STACK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_CLEANUP_GROUP {
    _unused: [u8; 0],
}
pub type TP_CLEANUP_GROUP = _TP_CLEANUP_GROUP;
pub type PTP_CLEANUP_GROUP = *mut _TP_CLEANUP_GROUP;
pub type PTP_CLEANUP_GROUP_CANCEL_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(ObjectContext: PVOID, CleanupContext: PVOID)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TP_CALLBACK_ENVIRON_V3 {
    pub Version: TP_VERSION,
    pub Pool: PTP_POOL,
    pub CleanupGroup: PTP_CLEANUP_GROUP,
    pub CleanupGroupCancelCallback: PTP_CLEANUP_GROUP_CANCEL_CALLBACK,
    pub RaceDll: PVOID,
    pub ActivationContext: *mut _ACTIVATION_CONTEXT,
    pub FinalizationCallback: PTP_SIMPLE_CALLBACK,
    pub u: _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1,
    pub CallbackPriority: TP_CALLBACK_PRIORITY,
    pub Size: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1 {
    pub Flags: DWORD,
    pub s: _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn LongFunction(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LongFunction(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Persistent(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Persistent(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Private(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Private(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LongFunction: DWORD,
        Persistent: DWORD,
        Private: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let LongFunction: u32 = unsafe { ::std::mem::transmute(LongFunction) };
            LongFunction as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Persistent: u32 = unsafe { ::std::mem::transmute(Persistent) };
            Persistent as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Private: u32 = unsafe { ::std::mem::transmute(Private) };
            Private as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__TP_CALLBACK_ENVIRON_V3__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
}
#[test]
fn bindgen_test_layout__TP_CALLBACK_ENVIRON_V3() {
    const UNINIT: ::std::mem::MaybeUninit<_TP_CALLBACK_ENVIRON_V3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TP_CALLBACK_ENVIRON_V3>(),
        72usize,
        concat!("Size of: ", stringify!(_TP_CALLBACK_ENVIRON_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<_TP_CALLBACK_ENVIRON_V3>(),
        8usize,
        concat!("Alignment of ", stringify!(_TP_CALLBACK_ENVIRON_V3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Pool) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3),
            "::",
            stringify!(Pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CleanupGroup) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3),
            "::",
            stringify!(CleanupGroup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CleanupGroupCancelCallback) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3),
            "::",
            stringify!(CleanupGroupCancelCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RaceDll) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3),
            "::",
            stringify!(RaceDll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ActivationContext) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3),
            "::",
            stringify!(ActivationContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FinalizationCallback) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3),
            "::",
            stringify!(FinalizationCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CallbackPriority) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3),
            "::",
            stringify!(CallbackPriority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3),
            "::",
            stringify!(Size)
        )
    );
}
pub type TP_CALLBACK_ENVIRON_V3 = _TP_CALLBACK_ENVIRON_V3;
pub type TP_CALLBACK_ENVIRON = TP_CALLBACK_ENVIRON_V3;
pub type PTP_CALLBACK_ENVIRON = *mut TP_CALLBACK_ENVIRON_V3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_WORK {
    _unused: [u8; 0],
}
pub type TP_WORK = _TP_WORK;
pub type PTP_WORK = *mut _TP_WORK;
pub type PTP_WORK_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(Instance: PTP_CALLBACK_INSTANCE, Context: PVOID, Work: PTP_WORK),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_TIMER {
    _unused: [u8; 0],
}
pub type TP_TIMER = _TP_TIMER;
pub type PTP_TIMER = *mut _TP_TIMER;
pub type PTP_TIMER_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(Instance: PTP_CALLBACK_INSTANCE, Context: PVOID, Timer: PTP_TIMER),
>;
pub type TP_WAIT_RESULT = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_WAIT {
    _unused: [u8; 0],
}
pub type TP_WAIT = _TP_WAIT;
pub type PTP_WAIT = *mut _TP_WAIT;
pub type PTP_WAIT_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        Instance: PTP_CALLBACK_INSTANCE,
        Context: PVOID,
        Wait: PTP_WAIT,
        WaitResult: TP_WAIT_RESULT,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_IO {
    _unused: [u8; 0],
}
pub type TP_IO = _TP_IO;
pub type PTP_IO = *mut _TP_IO;
pub type CRM_PROTOCOL_ID = GUID;
pub type PCRM_PROTOCOL_ID = *mut GUID;
pub type NOTIFICATION_MASK = ULONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION {
    pub TransactionKey: PVOID,
    pub TransactionNotification: ULONG,
    pub TmVirtualClock: LARGE_INTEGER,
    pub ArgumentLength: ULONG,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION() {
    const UNINIT: ::std::mem::MaybeUninit<_TRANSACTION_NOTIFICATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_NOTIFICATION>(),
        32usize,
        concat!("Size of: ", stringify!(_TRANSACTION_NOTIFICATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_NOTIFICATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_TRANSACTION_NOTIFICATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TransactionKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION),
            "::",
            stringify!(TransactionKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TransactionNotification) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION),
            "::",
            stringify!(TransactionNotification)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TmVirtualClock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION),
            "::",
            stringify!(TmVirtualClock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ArgumentLength) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION),
            "::",
            stringify!(ArgumentLength)
        )
    );
}
pub type TRANSACTION_NOTIFICATION = _TRANSACTION_NOTIFICATION;
pub type PTRANSACTION_NOTIFICATION = *mut _TRANSACTION_NOTIFICATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
    pub EnlistmentId: GUID,
    pub UOW: GUID,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT() {
    const UNINIT: ::std::mem::MaybeUninit<_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnlistmentId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT),
            "::",
            stringify!(EnlistmentId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UOW) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT),
            "::",
            stringify!(UOW)
        )
    );
}
pub type TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT =
    *mut _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
    pub TmIdentity: GUID,
    pub Flags: ULONG,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT() {
    const UNINIT: ::std::mem::MaybeUninit<_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TmIdentity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT),
            "::",
            stringify!(TmIdentity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT),
            "::",
            stringify!(Flags)
        )
    );
}
pub type TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT =
    *mut _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;
pub type SAVEPOINT_ID = ULONG;
pub type PSAVEPOINT_ID = *mut ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
    pub SavepointId: SAVEPOINT_ID,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT() {
    const UNINIT: ::std::mem::MaybeUninit<_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SavepointId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT),
            "::",
            stringify!(SavepointId)
        )
    );
}
pub type TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT =
    *mut _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
    pub PropagationCookie: ULONG,
    pub UOW: GUID,
    pub TmIdentity: GUID,
    pub BufferLength: ULONG,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT() {
    const UNINIT: ::std::mem::MaybeUninit<_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PropagationCookie) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT),
            "::",
            stringify!(PropagationCookie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UOW) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT),
            "::",
            stringify!(UOW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TmIdentity) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT),
            "::",
            stringify!(TmIdentity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BufferLength) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT),
            "::",
            stringify!(BufferLength)
        )
    );
}
pub type TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT =
    *mut _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
    pub MarshalCookie: ULONG,
    pub UOW: GUID,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT() {
    const UNINIT: ::std::mem::MaybeUninit<_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MarshalCookie) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT),
            "::",
            stringify!(MarshalCookie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UOW) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT),
            "::",
            stringify!(UOW)
        )
    );
}
pub type TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT =
    *mut _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;
pub type TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT = TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT =
    *mut TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KCRM_MARSHAL_HEADER {
    pub VersionMajor: ULONG,
    pub VersionMinor: ULONG,
    pub NumProtocols: ULONG,
    pub Unused: ULONG,
}
#[test]
fn bindgen_test_layout__KCRM_MARSHAL_HEADER() {
    const UNINIT: ::std::mem::MaybeUninit<_KCRM_MARSHAL_HEADER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_KCRM_MARSHAL_HEADER>(),
        16usize,
        concat!("Size of: ", stringify!(_KCRM_MARSHAL_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_KCRM_MARSHAL_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_KCRM_MARSHAL_HEADER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VersionMajor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_MARSHAL_HEADER),
            "::",
            stringify!(VersionMajor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VersionMinor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_MARSHAL_HEADER),
            "::",
            stringify!(VersionMinor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumProtocols) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_MARSHAL_HEADER),
            "::",
            stringify!(NumProtocols)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Unused) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_MARSHAL_HEADER),
            "::",
            stringify!(Unused)
        )
    );
}
pub type KCRM_MARSHAL_HEADER = _KCRM_MARSHAL_HEADER;
pub type PKCRM_MARSHAL_HEADER = *mut _KCRM_MARSHAL_HEADER;
pub type PRKCRM_MARSHAL_HEADER = *mut _KCRM_MARSHAL_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KCRM_TRANSACTION_BLOB {
    pub UOW: GUID,
    pub TmIdentity: GUID,
    pub IsolationLevel: ULONG,
    pub IsolationFlags: ULONG,
    pub Timeout: ULONG,
    pub Description: [WCHAR; 64usize],
}
#[test]
fn bindgen_test_layout__KCRM_TRANSACTION_BLOB() {
    const UNINIT: ::std::mem::MaybeUninit<_KCRM_TRANSACTION_BLOB> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_KCRM_TRANSACTION_BLOB>(),
        172usize,
        concat!("Size of: ", stringify!(_KCRM_TRANSACTION_BLOB))
    );
    assert_eq!(
        ::std::mem::align_of::<_KCRM_TRANSACTION_BLOB>(),
        4usize,
        concat!("Alignment of ", stringify!(_KCRM_TRANSACTION_BLOB))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UOW) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_TRANSACTION_BLOB),
            "::",
            stringify!(UOW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TmIdentity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_TRANSACTION_BLOB),
            "::",
            stringify!(TmIdentity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsolationLevel) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_TRANSACTION_BLOB),
            "::",
            stringify!(IsolationLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsolationFlags) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_TRANSACTION_BLOB),
            "::",
            stringify!(IsolationFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Timeout) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_TRANSACTION_BLOB),
            "::",
            stringify!(Timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Description) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_TRANSACTION_BLOB),
            "::",
            stringify!(Description)
        )
    );
}
pub type KCRM_TRANSACTION_BLOB = _KCRM_TRANSACTION_BLOB;
pub type PKCRM_TRANSACTION_BLOB = *mut _KCRM_TRANSACTION_BLOB;
pub type PRKCRM_TRANSACTION_BLOB = *mut _KCRM_TRANSACTION_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KCRM_PROTOCOL_BLOB {
    pub ProtocolId: CRM_PROTOCOL_ID,
    pub StaticInfoLength: ULONG,
    pub TransactionIdInfoLength: ULONG,
    pub Unused1: ULONG,
    pub Unused2: ULONG,
}
#[test]
fn bindgen_test_layout__KCRM_PROTOCOL_BLOB() {
    const UNINIT: ::std::mem::MaybeUninit<_KCRM_PROTOCOL_BLOB> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_KCRM_PROTOCOL_BLOB>(),
        32usize,
        concat!("Size of: ", stringify!(_KCRM_PROTOCOL_BLOB))
    );
    assert_eq!(
        ::std::mem::align_of::<_KCRM_PROTOCOL_BLOB>(),
        4usize,
        concat!("Alignment of ", stringify!(_KCRM_PROTOCOL_BLOB))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProtocolId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_PROTOCOL_BLOB),
            "::",
            stringify!(ProtocolId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StaticInfoLength) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_PROTOCOL_BLOB),
            "::",
            stringify!(StaticInfoLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TransactionIdInfoLength) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_PROTOCOL_BLOB),
            "::",
            stringify!(TransactionIdInfoLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Unused1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_PROTOCOL_BLOB),
            "::",
            stringify!(Unused1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Unused2) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_PROTOCOL_BLOB),
            "::",
            stringify!(Unused2)
        )
    );
}
pub type KCRM_PROTOCOL_BLOB = _KCRM_PROTOCOL_BLOB;
pub type PKCRM_PROTOCOL_BLOB = *mut _KCRM_PROTOCOL_BLOB;
pub type PRKCRM_PROTOCOL_BLOB = *mut _KCRM_PROTOCOL_BLOB;
pub const _TRANSACTION_OUTCOME_TransactionOutcomeUndetermined: _TRANSACTION_OUTCOME = 1;
pub const _TRANSACTION_OUTCOME_TransactionOutcomeCommitted: _TRANSACTION_OUTCOME = 2;
pub const _TRANSACTION_OUTCOME_TransactionOutcomeAborted: _TRANSACTION_OUTCOME = 3;
pub type _TRANSACTION_OUTCOME = ::std::os::raw::c_uint;
pub use self::_TRANSACTION_OUTCOME as TRANSACTION_OUTCOME;
pub const _TRANSACTION_STATE_TransactionStateNormal: _TRANSACTION_STATE = 1;
pub const _TRANSACTION_STATE_TransactionStateIndoubt: _TRANSACTION_STATE = 2;
pub const _TRANSACTION_STATE_TransactionStateCommittedNotify: _TRANSACTION_STATE = 3;
pub type _TRANSACTION_STATE = ::std::os::raw::c_uint;
pub use self::_TRANSACTION_STATE as TRANSACTION_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_BASIC_INFORMATION {
    pub TransactionId: GUID,
    pub State: DWORD,
    pub Outcome: DWORD,
}
#[test]
fn bindgen_test_layout__TRANSACTION_BASIC_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_TRANSACTION_BASIC_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_BASIC_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_TRANSACTION_BASIC_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_BASIC_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_TRANSACTION_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TransactionId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_BASIC_INFORMATION),
            "::",
            stringify!(TransactionId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_BASIC_INFORMATION),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Outcome) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_BASIC_INFORMATION),
            "::",
            stringify!(Outcome)
        )
    );
}
pub type TRANSACTION_BASIC_INFORMATION = _TRANSACTION_BASIC_INFORMATION;
pub type PTRANSACTION_BASIC_INFORMATION = *mut _TRANSACTION_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
    pub TmIdentity: GUID,
    pub VirtualClock: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__TRANSACTIONMANAGER_BASIC_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_TRANSACTIONMANAGER_BASIC_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTIONMANAGER_BASIC_INFORMATION>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTIONMANAGER_BASIC_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTIONMANAGER_BASIC_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTIONMANAGER_BASIC_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TmIdentity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTIONMANAGER_BASIC_INFORMATION),
            "::",
            stringify!(TmIdentity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VirtualClock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTIONMANAGER_BASIC_INFORMATION),
            "::",
            stringify!(VirtualClock)
        )
    );
}
pub type TRANSACTIONMANAGER_BASIC_INFORMATION = _TRANSACTIONMANAGER_BASIC_INFORMATION;
pub type PTRANSACTIONMANAGER_BASIC_INFORMATION = *mut _TRANSACTIONMANAGER_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTIONMANAGER_LOG_INFORMATION {
    pub LogIdentity: GUID,
}
#[test]
fn bindgen_test_layout__TRANSACTIONMANAGER_LOG_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_TRANSACTIONMANAGER_LOG_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTIONMANAGER_LOG_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_TRANSACTIONMANAGER_LOG_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTIONMANAGER_LOG_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTIONMANAGER_LOG_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LogIdentity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTIONMANAGER_LOG_INFORMATION),
            "::",
            stringify!(LogIdentity)
        )
    );
}
pub type TRANSACTIONMANAGER_LOG_INFORMATION = _TRANSACTIONMANAGER_LOG_INFORMATION;
pub type PTRANSACTIONMANAGER_LOG_INFORMATION = *mut _TRANSACTIONMANAGER_LOG_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    pub LogPathLength: DWORD,
    pub LogPath: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__TRANSACTIONMANAGER_LOGPATH_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_TRANSACTIONMANAGER_LOGPATH_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTIONMANAGER_LOGPATH_INFORMATION>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTIONMANAGER_LOGPATH_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTIONMANAGER_LOGPATH_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTIONMANAGER_LOGPATH_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LogPathLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTIONMANAGER_LOGPATH_INFORMATION),
            "::",
            stringify!(LogPathLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LogPath) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTIONMANAGER_LOGPATH_INFORMATION),
            "::",
            stringify!(LogPath)
        )
    );
}
pub type TRANSACTIONMANAGER_LOGPATH_INFORMATION = _TRANSACTIONMANAGER_LOGPATH_INFORMATION;
pub type PTRANSACTIONMANAGER_LOGPATH_INFORMATION = *mut _TRANSACTIONMANAGER_LOGPATH_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    pub LastRecoveredLsn: ULONGLONG,
}
#[test]
fn bindgen_test_layout__TRANSACTIONMANAGER_RECOVERY_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_TRANSACTIONMANAGER_RECOVERY_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTIONMANAGER_RECOVERY_INFORMATION>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTIONMANAGER_RECOVERY_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTIONMANAGER_RECOVERY_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTIONMANAGER_RECOVERY_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastRecoveredLsn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTIONMANAGER_RECOVERY_INFORMATION),
            "::",
            stringify!(LastRecoveredLsn)
        )
    );
}
pub type TRANSACTIONMANAGER_RECOVERY_INFORMATION = _TRANSACTIONMANAGER_RECOVERY_INFORMATION;
pub type PTRANSACTIONMANAGER_RECOVERY_INFORMATION = *mut _TRANSACTIONMANAGER_RECOVERY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTIONMANAGER_OLDEST_INFORMATION {
    pub OldestTransactionGuid: GUID,
}
#[test]
fn bindgen_test_layout__TRANSACTIONMANAGER_OLDEST_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_TRANSACTIONMANAGER_OLDEST_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTIONMANAGER_OLDEST_INFORMATION>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTIONMANAGER_OLDEST_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTIONMANAGER_OLDEST_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTIONMANAGER_OLDEST_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OldestTransactionGuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTIONMANAGER_OLDEST_INFORMATION),
            "::",
            stringify!(OldestTransactionGuid)
        )
    );
}
pub type TRANSACTIONMANAGER_OLDEST_INFORMATION = _TRANSACTIONMANAGER_OLDEST_INFORMATION;
pub type PTRANSACTIONMANAGER_OLDEST_INFORMATION = *mut _TRANSACTIONMANAGER_OLDEST_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRANSACTION_PROPERTIES_INFORMATION {
    pub IsolationLevel: DWORD,
    pub IsolationFlags: DWORD,
    pub Timeout: LARGE_INTEGER,
    pub Outcome: DWORD,
    pub DescriptionLength: DWORD,
    pub Description: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__TRANSACTION_PROPERTIES_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_TRANSACTION_PROPERTIES_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_PROPERTIES_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_TRANSACTION_PROPERTIES_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_PROPERTIES_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTION_PROPERTIES_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsolationLevel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_PROPERTIES_INFORMATION),
            "::",
            stringify!(IsolationLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsolationFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_PROPERTIES_INFORMATION),
            "::",
            stringify!(IsolationFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Timeout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_PROPERTIES_INFORMATION),
            "::",
            stringify!(Timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Outcome) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_PROPERTIES_INFORMATION),
            "::",
            stringify!(Outcome)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DescriptionLength) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_PROPERTIES_INFORMATION),
            "::",
            stringify!(DescriptionLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Description) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_PROPERTIES_INFORMATION),
            "::",
            stringify!(Description)
        )
    );
}
pub type TRANSACTION_PROPERTIES_INFORMATION = _TRANSACTION_PROPERTIES_INFORMATION;
pub type PTRANSACTION_PROPERTIES_INFORMATION = *mut _TRANSACTION_PROPERTIES_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_BIND_INFORMATION {
    pub TmHandle: HANDLE,
}
#[test]
fn bindgen_test_layout__TRANSACTION_BIND_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_TRANSACTION_BIND_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_BIND_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_TRANSACTION_BIND_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_BIND_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_TRANSACTION_BIND_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TmHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_BIND_INFORMATION),
            "::",
            stringify!(TmHandle)
        )
    );
}
pub type TRANSACTION_BIND_INFORMATION = _TRANSACTION_BIND_INFORMATION;
pub type PTRANSACTION_BIND_INFORMATION = *mut _TRANSACTION_BIND_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_ENLISTMENT_PAIR {
    pub EnlistmentId: GUID,
    pub ResourceManagerId: GUID,
}
#[test]
fn bindgen_test_layout__TRANSACTION_ENLISTMENT_PAIR() {
    const UNINIT: ::std::mem::MaybeUninit<_TRANSACTION_ENLISTMENT_PAIR> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_ENLISTMENT_PAIR>(),
        32usize,
        concat!("Size of: ", stringify!(_TRANSACTION_ENLISTMENT_PAIR))
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_ENLISTMENT_PAIR>(),
        4usize,
        concat!("Alignment of ", stringify!(_TRANSACTION_ENLISTMENT_PAIR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnlistmentId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_ENLISTMENT_PAIR),
            "::",
            stringify!(EnlistmentId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResourceManagerId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_ENLISTMENT_PAIR),
            "::",
            stringify!(ResourceManagerId)
        )
    );
}
pub type TRANSACTION_ENLISTMENT_PAIR = _TRANSACTION_ENLISTMENT_PAIR;
pub type PTRANSACTION_ENLISTMENT_PAIR = *mut _TRANSACTION_ENLISTMENT_PAIR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_ENLISTMENTS_INFORMATION {
    pub NumberOfEnlistments: DWORD,
    pub EnlistmentPair: [TRANSACTION_ENLISTMENT_PAIR; 1usize],
}
#[test]
fn bindgen_test_layout__TRANSACTION_ENLISTMENTS_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_TRANSACTION_ENLISTMENTS_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_ENLISTMENTS_INFORMATION>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTION_ENLISTMENTS_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_ENLISTMENTS_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTION_ENLISTMENTS_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfEnlistments) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_ENLISTMENTS_INFORMATION),
            "::",
            stringify!(NumberOfEnlistments)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnlistmentPair) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_ENLISTMENTS_INFORMATION),
            "::",
            stringify!(EnlistmentPair)
        )
    );
}
pub type TRANSACTION_ENLISTMENTS_INFORMATION = _TRANSACTION_ENLISTMENTS_INFORMATION;
pub type PTRANSACTION_ENLISTMENTS_INFORMATION = *mut _TRANSACTION_ENLISTMENTS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    pub SuperiorEnlistmentPair: TRANSACTION_ENLISTMENT_PAIR,
}
#[test]
fn bindgen_test_layout__TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SuperiorEnlistmentPair) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION),
            "::",
            stringify!(SuperiorEnlistmentPair)
        )
    );
}
pub type TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
pub type PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION =
    *mut _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RESOURCEMANAGER_BASIC_INFORMATION {
    pub ResourceManagerId: GUID,
    pub DescriptionLength: DWORD,
    pub Description: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__RESOURCEMANAGER_BASIC_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_RESOURCEMANAGER_BASIC_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RESOURCEMANAGER_BASIC_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_RESOURCEMANAGER_BASIC_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_RESOURCEMANAGER_BASIC_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_RESOURCEMANAGER_BASIC_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResourceManagerId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RESOURCEMANAGER_BASIC_INFORMATION),
            "::",
            stringify!(ResourceManagerId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DescriptionLength) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RESOURCEMANAGER_BASIC_INFORMATION),
            "::",
            stringify!(DescriptionLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Description) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_RESOURCEMANAGER_BASIC_INFORMATION),
            "::",
            stringify!(Description)
        )
    );
}
pub type RESOURCEMANAGER_BASIC_INFORMATION = _RESOURCEMANAGER_BASIC_INFORMATION;
pub type PRESOURCEMANAGER_BASIC_INFORMATION = *mut _RESOURCEMANAGER_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
    pub IoCompletionPortHandle: HANDLE,
    pub CompletionKey: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__RESOURCEMANAGER_COMPLETION_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_RESOURCEMANAGER_COMPLETION_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RESOURCEMANAGER_COMPLETION_INFORMATION>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_RESOURCEMANAGER_COMPLETION_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_RESOURCEMANAGER_COMPLETION_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_RESOURCEMANAGER_COMPLETION_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoCompletionPortHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RESOURCEMANAGER_COMPLETION_INFORMATION),
            "::",
            stringify!(IoCompletionPortHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CompletionKey) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RESOURCEMANAGER_COMPLETION_INFORMATION),
            "::",
            stringify!(CompletionKey)
        )
    );
}
pub type RESOURCEMANAGER_COMPLETION_INFORMATION = _RESOURCEMANAGER_COMPLETION_INFORMATION;
pub type PRESOURCEMANAGER_COMPLETION_INFORMATION = *mut _RESOURCEMANAGER_COMPLETION_INFORMATION;
pub const _TRANSACTION_INFORMATION_CLASS_TransactionBasicInformation:
    _TRANSACTION_INFORMATION_CLASS = 0;
pub const _TRANSACTION_INFORMATION_CLASS_TransactionPropertiesInformation:
    _TRANSACTION_INFORMATION_CLASS = 1;
pub const _TRANSACTION_INFORMATION_CLASS_TransactionEnlistmentInformation:
    _TRANSACTION_INFORMATION_CLASS = 2;
pub const _TRANSACTION_INFORMATION_CLASS_TransactionSuperiorEnlistmentInformation:
    _TRANSACTION_INFORMATION_CLASS = 3;
pub const _TRANSACTION_INFORMATION_CLASS_TransactionBindInformation:
    _TRANSACTION_INFORMATION_CLASS = 4;
pub const _TRANSACTION_INFORMATION_CLASS_TransactionDTCPrivateInformation:
    _TRANSACTION_INFORMATION_CLASS = 5;
pub type _TRANSACTION_INFORMATION_CLASS = ::std::os::raw::c_uint;
pub use self::_TRANSACTION_INFORMATION_CLASS as TRANSACTION_INFORMATION_CLASS;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerBasicInformation:
    _TRANSACTIONMANAGER_INFORMATION_CLASS = 0;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerLogInformation:
    _TRANSACTIONMANAGER_INFORMATION_CLASS = 1;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerLogPathInformation:
    _TRANSACTIONMANAGER_INFORMATION_CLASS = 2;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerOnlineProbeInformation:
    _TRANSACTIONMANAGER_INFORMATION_CLASS = 3;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerRecoveryInformation:
    _TRANSACTIONMANAGER_INFORMATION_CLASS = 4;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerOldestTransactionInformation:
    _TRANSACTIONMANAGER_INFORMATION_CLASS = 5;
pub type _TRANSACTIONMANAGER_INFORMATION_CLASS = ::std::os::raw::c_uint;
pub use self::_TRANSACTIONMANAGER_INFORMATION_CLASS as TRANSACTIONMANAGER_INFORMATION_CLASS;
pub const _RESOURCEMANAGER_INFORMATION_CLASS_ResourceManagerBasicInformation:
    _RESOURCEMANAGER_INFORMATION_CLASS = 0;
pub const _RESOURCEMANAGER_INFORMATION_CLASS_ResourceManagerCompletionInformation:
    _RESOURCEMANAGER_INFORMATION_CLASS = 1;
pub type _RESOURCEMANAGER_INFORMATION_CLASS = ::std::os::raw::c_uint;
pub use self::_RESOURCEMANAGER_INFORMATION_CLASS as RESOURCEMANAGER_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENLISTMENT_BASIC_INFORMATION {
    pub EnlistmentId: GUID,
    pub TransactionId: GUID,
    pub ResourceManagerId: GUID,
}
#[test]
fn bindgen_test_layout__ENLISTMENT_BASIC_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_ENLISTMENT_BASIC_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ENLISTMENT_BASIC_INFORMATION>(),
        48usize,
        concat!("Size of: ", stringify!(_ENLISTMENT_BASIC_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_ENLISTMENT_BASIC_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_ENLISTMENT_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnlistmentId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENLISTMENT_BASIC_INFORMATION),
            "::",
            stringify!(EnlistmentId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TransactionId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENLISTMENT_BASIC_INFORMATION),
            "::",
            stringify!(TransactionId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResourceManagerId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENLISTMENT_BASIC_INFORMATION),
            "::",
            stringify!(ResourceManagerId)
        )
    );
}
pub type ENLISTMENT_BASIC_INFORMATION = _ENLISTMENT_BASIC_INFORMATION;
pub type PENLISTMENT_BASIC_INFORMATION = *mut _ENLISTMENT_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENLISTMENT_CRM_INFORMATION {
    pub CrmTransactionManagerId: GUID,
    pub CrmResourceManagerId: GUID,
    pub CrmEnlistmentId: GUID,
}
#[test]
fn bindgen_test_layout__ENLISTMENT_CRM_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_ENLISTMENT_CRM_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ENLISTMENT_CRM_INFORMATION>(),
        48usize,
        concat!("Size of: ", stringify!(_ENLISTMENT_CRM_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_ENLISTMENT_CRM_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_ENLISTMENT_CRM_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CrmTransactionManagerId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENLISTMENT_CRM_INFORMATION),
            "::",
            stringify!(CrmTransactionManagerId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CrmResourceManagerId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENLISTMENT_CRM_INFORMATION),
            "::",
            stringify!(CrmResourceManagerId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CrmEnlistmentId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENLISTMENT_CRM_INFORMATION),
            "::",
            stringify!(CrmEnlistmentId)
        )
    );
}
pub type ENLISTMENT_CRM_INFORMATION = _ENLISTMENT_CRM_INFORMATION;
pub type PENLISTMENT_CRM_INFORMATION = *mut _ENLISTMENT_CRM_INFORMATION;
pub const _ENLISTMENT_INFORMATION_CLASS_EnlistmentBasicInformation: _ENLISTMENT_INFORMATION_CLASS =
    0;
pub const _ENLISTMENT_INFORMATION_CLASS_EnlistmentRecoveryInformation:
    _ENLISTMENT_INFORMATION_CLASS = 1;
pub const _ENLISTMENT_INFORMATION_CLASS_EnlistmentCrmInformation: _ENLISTMENT_INFORMATION_CLASS = 2;
pub type _ENLISTMENT_INFORMATION_CLASS = ::std::os::raw::c_uint;
pub use self::_ENLISTMENT_INFORMATION_CLASS as ENLISTMENT_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_LIST_ENTRY {
    pub UOW: GUID,
}
#[test]
fn bindgen_test_layout__TRANSACTION_LIST_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_TRANSACTION_LIST_ENTRY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_LIST_ENTRY>(),
        16usize,
        concat!("Size of: ", stringify!(_TRANSACTION_LIST_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_LIST_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_TRANSACTION_LIST_ENTRY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UOW) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_LIST_ENTRY),
            "::",
            stringify!(UOW)
        )
    );
}
pub type TRANSACTION_LIST_ENTRY = _TRANSACTION_LIST_ENTRY;
pub type PTRANSACTION_LIST_ENTRY = *mut _TRANSACTION_LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_LIST_INFORMATION {
    pub NumberOfTransactions: DWORD,
    pub TransactionInformation: [TRANSACTION_LIST_ENTRY; 1usize],
}
#[test]
fn bindgen_test_layout__TRANSACTION_LIST_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_TRANSACTION_LIST_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_LIST_INFORMATION>(),
        20usize,
        concat!("Size of: ", stringify!(_TRANSACTION_LIST_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_LIST_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_TRANSACTION_LIST_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfTransactions) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_LIST_INFORMATION),
            "::",
            stringify!(NumberOfTransactions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TransactionInformation) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_LIST_INFORMATION),
            "::",
            stringify!(TransactionInformation)
        )
    );
}
pub type TRANSACTION_LIST_INFORMATION = _TRANSACTION_LIST_INFORMATION;
pub type PTRANSACTION_LIST_INFORMATION = *mut _TRANSACTION_LIST_INFORMATION;
pub const _KTMOBJECT_TYPE_KTMOBJECT_TRANSACTION: _KTMOBJECT_TYPE = 0;
pub const _KTMOBJECT_TYPE_KTMOBJECT_TRANSACTION_MANAGER: _KTMOBJECT_TYPE = 1;
pub const _KTMOBJECT_TYPE_KTMOBJECT_RESOURCE_MANAGER: _KTMOBJECT_TYPE = 2;
pub const _KTMOBJECT_TYPE_KTMOBJECT_ENLISTMENT: _KTMOBJECT_TYPE = 3;
pub const _KTMOBJECT_TYPE_KTMOBJECT_INVALID: _KTMOBJECT_TYPE = 4;
pub type _KTMOBJECT_TYPE = ::std::os::raw::c_uint;
pub use self::_KTMOBJECT_TYPE as KTMOBJECT_TYPE;
pub type PKTMOBJECT_TYPE = *mut _KTMOBJECT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTMOBJECT_CURSOR {
    pub LastQuery: GUID,
    pub ObjectIdCount: DWORD,
    pub ObjectIds: [GUID; 1usize],
}
#[test]
fn bindgen_test_layout__KTMOBJECT_CURSOR() {
    const UNINIT: ::std::mem::MaybeUninit<_KTMOBJECT_CURSOR> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_KTMOBJECT_CURSOR>(),
        36usize,
        concat!("Size of: ", stringify!(_KTMOBJECT_CURSOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_KTMOBJECT_CURSOR>(),
        4usize,
        concat!("Alignment of ", stringify!(_KTMOBJECT_CURSOR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastQuery) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTMOBJECT_CURSOR),
            "::",
            stringify!(LastQuery)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectIdCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTMOBJECT_CURSOR),
            "::",
            stringify!(ObjectIdCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectIds) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTMOBJECT_CURSOR),
            "::",
            stringify!(ObjectIds)
        )
    );
}
pub type KTMOBJECT_CURSOR = _KTMOBJECT_CURSOR;
pub type PKTMOBJECT_CURSOR = *mut _KTMOBJECT_CURSOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WOW64_FLOATING_SAVE_AREA {
    pub ControlWord: DWORD,
    pub StatusWord: DWORD,
    pub TagWord: DWORD,
    pub ErrorOffset: DWORD,
    pub ErrorSelector: DWORD,
    pub DataOffset: DWORD,
    pub DataSelector: DWORD,
    pub RegisterArea: [BYTE; 80usize],
    pub Cr0NpxState: DWORD,
}
#[test]
fn bindgen_test_layout__WOW64_FLOATING_SAVE_AREA() {
    const UNINIT: ::std::mem::MaybeUninit<_WOW64_FLOATING_SAVE_AREA> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_WOW64_FLOATING_SAVE_AREA>(),
        112usize,
        concat!("Size of: ", stringify!(_WOW64_FLOATING_SAVE_AREA))
    );
    assert_eq!(
        ::std::mem::align_of::<_WOW64_FLOATING_SAVE_AREA>(),
        4usize,
        concat!("Alignment of ", stringify!(_WOW64_FLOATING_SAVE_AREA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ControlWord) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_FLOATING_SAVE_AREA),
            "::",
            stringify!(ControlWord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatusWord) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_FLOATING_SAVE_AREA),
            "::",
            stringify!(StatusWord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TagWord) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_FLOATING_SAVE_AREA),
            "::",
            stringify!(TagWord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ErrorOffset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_FLOATING_SAVE_AREA),
            "::",
            stringify!(ErrorOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ErrorSelector) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_FLOATING_SAVE_AREA),
            "::",
            stringify!(ErrorSelector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataOffset) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_FLOATING_SAVE_AREA),
            "::",
            stringify!(DataOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataSelector) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_FLOATING_SAVE_AREA),
            "::",
            stringify!(DataSelector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RegisterArea) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_FLOATING_SAVE_AREA),
            "::",
            stringify!(RegisterArea)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Cr0NpxState) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_FLOATING_SAVE_AREA),
            "::",
            stringify!(Cr0NpxState)
        )
    );
}
pub type WOW64_FLOATING_SAVE_AREA = _WOW64_FLOATING_SAVE_AREA;
pub type PWOW64_FLOATING_SAVE_AREA = *mut _WOW64_FLOATING_SAVE_AREA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WOW64_CONTEXT {
    pub ContextFlags: DWORD,
    pub Dr0: DWORD,
    pub Dr1: DWORD,
    pub Dr2: DWORD,
    pub Dr3: DWORD,
    pub Dr6: DWORD,
    pub Dr7: DWORD,
    pub FloatSave: WOW64_FLOATING_SAVE_AREA,
    pub SegGs: DWORD,
    pub SegFs: DWORD,
    pub SegEs: DWORD,
    pub SegDs: DWORD,
    pub Edi: DWORD,
    pub Esi: DWORD,
    pub Ebx: DWORD,
    pub Edx: DWORD,
    pub Ecx: DWORD,
    pub Eax: DWORD,
    pub Ebp: DWORD,
    pub Eip: DWORD,
    pub SegCs: DWORD,
    pub EFlags: DWORD,
    pub Esp: DWORD,
    pub SegSs: DWORD,
    pub ExtendedRegisters: [BYTE; 512usize],
}
#[test]
fn bindgen_test_layout__WOW64_CONTEXT() {
    const UNINIT: ::std::mem::MaybeUninit<_WOW64_CONTEXT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_WOW64_CONTEXT>(),
        716usize,
        concat!("Size of: ", stringify!(_WOW64_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<_WOW64_CONTEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(_WOW64_CONTEXT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ContextFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(ContextFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Dr0) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Dr0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Dr1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Dr1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Dr2) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Dr2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Dr3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Dr3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Dr6) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Dr6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Dr7) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Dr7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FloatSave) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(FloatSave)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SegGs) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(SegGs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SegFs) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(SegFs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SegEs) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(SegEs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SegDs) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(SegDs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Edi) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Edi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Esi) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Esi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ebx) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Ebx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Edx) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Edx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ecx) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Ecx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Eax) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Eax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ebp) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Ebp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Eip) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Eip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SegCs) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(SegCs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EFlags) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(EFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Esp) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Esp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SegSs) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(SegSs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExtendedRegisters) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(ExtendedRegisters)
        )
    );
}
pub type WOW64_CONTEXT = _WOW64_CONTEXT;
pub type PWOW64_CONTEXT = *mut _WOW64_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WOW64_LDT_ENTRY {
    pub LimitLow: WORD,
    pub BaseLow: WORD,
    pub HighWord: _WOW64_LDT_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WOW64_LDT_ENTRY__bindgen_ty_1 {
    pub Bytes: _WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1,
    pub Bits: _WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub BaseMid: BYTE,
    pub Flags1: BYTE,
    pub Flags2: BYTE,
    pub BaseHi: BYTE,
}
#[test]
fn bindgen_test_layout__WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BaseMid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(BaseMid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags1) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Flags1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags2) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BaseHi) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(BaseHi)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2)
        )
    );
}
impl _WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn BaseMid(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BaseMid(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Type(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Dpl(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Dpl(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Pres(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Pres(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LimitHi(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LimitHi(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Sys(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Sys(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved_0(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved_0(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Default_Big(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Default_Big(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Granularity(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Granularity(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BaseHi(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BaseHi(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BaseMid: DWORD,
        Type: DWORD,
        Dpl: DWORD,
        Pres: DWORD,
        LimitHi: DWORD,
        Sys: DWORD,
        Reserved_0: DWORD,
        Default_Big: DWORD,
        Granularity: DWORD,
        BaseHi: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let BaseMid: u32 = unsafe { ::std::mem::transmute(BaseMid) };
            BaseMid as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let Type: u32 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let Dpl: u32 = unsafe { ::std::mem::transmute(Dpl) };
            Dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Pres: u32 = unsafe { ::std::mem::transmute(Pres) };
            Pres as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let LimitHi: u32 = unsafe { ::std::mem::transmute(LimitHi) };
            LimitHi as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let Sys: u32 = unsafe { ::std::mem::transmute(Sys) };
            Sys as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let Reserved_0: u32 = unsafe { ::std::mem::transmute(Reserved_0) };
            Reserved_0 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let Default_Big: u32 = unsafe { ::std::mem::transmute(Default_Big) };
            Default_Big as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let Granularity: u32 = unsafe { ::std::mem::transmute(Granularity) };
            Granularity as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let BaseHi: u32 = unsafe { ::std::mem::transmute(BaseHi) };
            BaseHi as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__WOW64_LDT_ENTRY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_WOW64_LDT_ENTRY__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_WOW64_LDT_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_WOW64_LDT_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1),
            "::",
            stringify!(Bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1),
            "::",
            stringify!(Bits)
        )
    );
}
#[test]
fn bindgen_test_layout__WOW64_LDT_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_WOW64_LDT_ENTRY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_WOW64_LDT_ENTRY>(),
        8usize,
        concat!("Size of: ", stringify!(_WOW64_LDT_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_WOW64_LDT_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_WOW64_LDT_ENTRY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LimitLow) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_LDT_ENTRY),
            "::",
            stringify!(LimitLow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BaseLow) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_LDT_ENTRY),
            "::",
            stringify!(BaseLow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighWord) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_LDT_ENTRY),
            "::",
            stringify!(HighWord)
        )
    );
}
pub type WOW64_LDT_ENTRY = _WOW64_LDT_ENTRY;
pub type PWOW64_LDT_ENTRY = *mut _WOW64_LDT_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WOW64_DESCRIPTOR_TABLE_ENTRY {
    pub Selector: DWORD,
    pub Descriptor: WOW64_LDT_ENTRY,
}
#[test]
fn bindgen_test_layout__WOW64_DESCRIPTOR_TABLE_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_WOW64_DESCRIPTOR_TABLE_ENTRY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_WOW64_DESCRIPTOR_TABLE_ENTRY>(),
        12usize,
        concat!("Size of: ", stringify!(_WOW64_DESCRIPTOR_TABLE_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_WOW64_DESCRIPTOR_TABLE_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_WOW64_DESCRIPTOR_TABLE_ENTRY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Selector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_DESCRIPTOR_TABLE_ENTRY),
            "::",
            stringify!(Selector)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Descriptor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_DESCRIPTOR_TABLE_ENTRY),
            "::",
            stringify!(Descriptor)
        )
    );
}
pub type WOW64_DESCRIPTOR_TABLE_ENTRY = _WOW64_DESCRIPTOR_TABLE_ENTRY;
pub type PWOW64_DESCRIPTOR_TABLE_ENTRY = *mut _WOW64_DESCRIPTOR_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_NUMBER {
    pub Group: WORD,
    pub Number: BYTE,
    pub Reserved: BYTE,
}
#[test]
fn bindgen_test_layout__PROCESSOR_NUMBER() {
    const UNINIT: ::std::mem::MaybeUninit<_PROCESSOR_NUMBER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESSOR_NUMBER>(),
        4usize,
        concat!("Size of: ", stringify!(_PROCESSOR_NUMBER))
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESSOR_NUMBER>(),
        2usize,
        concat!("Alignment of ", stringify!(_PROCESSOR_NUMBER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Group) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_NUMBER),
            "::",
            stringify!(Group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Number) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_NUMBER),
            "::",
            stringify!(Number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_NUMBER),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type PROCESSOR_NUMBER = _PROCESSOR_NUMBER;
pub type PPROCESSOR_NUMBER = *mut _PROCESSOR_NUMBER;
pub type WPARAM = UINT_PTR;
pub type LPARAM = LONG_PTR;
pub type LRESULT = LONG_PTR;
pub type SPHANDLE = *mut HANDLE;
pub type LPHANDLE = *mut HANDLE;
pub type HGLOBAL = HANDLE;
pub type HLOCAL = HANDLE;
pub type GLOBALHANDLE = HANDLE;
pub type LOCALHANDLE = HANDLE;
pub type FARPROC = ::std::option::Option<unsafe extern "C" fn() -> INT_PTR>;
pub type NEARPROC = ::std::option::Option<unsafe extern "C" fn() -> INT_PTR>;
pub type PROC = ::std::option::Option<unsafe extern "C" fn() -> INT_PTR>;
pub type ATOM = WORD;
pub type HFILE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HINSTANCE__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HINSTANCE__() {
    const UNINIT: ::std::mem::MaybeUninit<HINSTANCE__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HINSTANCE__>(),
        4usize,
        concat!("Size of: ", stringify!(HINSTANCE__))
    );
    assert_eq!(
        ::std::mem::align_of::<HINSTANCE__>(),
        4usize,
        concat!("Alignment of ", stringify!(HINSTANCE__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HINSTANCE__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HINSTANCE = *mut HINSTANCE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HKEY__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HKEY__() {
    const UNINIT: ::std::mem::MaybeUninit<HKEY__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HKEY__>(),
        4usize,
        concat!("Size of: ", stringify!(HKEY__))
    );
    assert_eq!(
        ::std::mem::align_of::<HKEY__>(),
        4usize,
        concat!("Alignment of ", stringify!(HKEY__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HKEY__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HKEY = *mut HKEY__;
pub type PHKEY = *mut HKEY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HKL__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HKL__() {
    const UNINIT: ::std::mem::MaybeUninit<HKL__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HKL__>(),
        4usize,
        concat!("Size of: ", stringify!(HKL__))
    );
    assert_eq!(
        ::std::mem::align_of::<HKL__>(),
        4usize,
        concat!("Alignment of ", stringify!(HKL__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HKL__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HKL = *mut HKL__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HLSURF__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HLSURF__() {
    const UNINIT: ::std::mem::MaybeUninit<HLSURF__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HLSURF__>(),
        4usize,
        concat!("Size of: ", stringify!(HLSURF__))
    );
    assert_eq!(
        ::std::mem::align_of::<HLSURF__>(),
        4usize,
        concat!("Alignment of ", stringify!(HLSURF__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HLSURF__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HLSURF = *mut HLSURF__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HMETAFILE__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HMETAFILE__() {
    const UNINIT: ::std::mem::MaybeUninit<HMETAFILE__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HMETAFILE__>(),
        4usize,
        concat!("Size of: ", stringify!(HMETAFILE__))
    );
    assert_eq!(
        ::std::mem::align_of::<HMETAFILE__>(),
        4usize,
        concat!("Alignment of ", stringify!(HMETAFILE__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HMETAFILE__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HMETAFILE = *mut HMETAFILE__;
pub type HMODULE = HINSTANCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HRGN__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HRGN__() {
    const UNINIT: ::std::mem::MaybeUninit<HRGN__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HRGN__>(),
        4usize,
        concat!("Size of: ", stringify!(HRGN__))
    );
    assert_eq!(
        ::std::mem::align_of::<HRGN__>(),
        4usize,
        concat!("Alignment of ", stringify!(HRGN__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HRGN__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HRGN = *mut HRGN__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HRSRC__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HRSRC__() {
    const UNINIT: ::std::mem::MaybeUninit<HRSRC__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HRSRC__>(),
        4usize,
        concat!("Size of: ", stringify!(HRSRC__))
    );
    assert_eq!(
        ::std::mem::align_of::<HRSRC__>(),
        4usize,
        concat!("Alignment of ", stringify!(HRSRC__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HRSRC__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HRSRC = *mut HRSRC__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HSPRITE__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HSPRITE__() {
    const UNINIT: ::std::mem::MaybeUninit<HSPRITE__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HSPRITE__>(),
        4usize,
        concat!("Size of: ", stringify!(HSPRITE__))
    );
    assert_eq!(
        ::std::mem::align_of::<HSPRITE__>(),
        4usize,
        concat!("Alignment of ", stringify!(HSPRITE__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HSPRITE__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HSPRITE = *mut HSPRITE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HSTR__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HSTR__() {
    const UNINIT: ::std::mem::MaybeUninit<HSTR__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HSTR__>(),
        4usize,
        concat!("Size of: ", stringify!(HSTR__))
    );
    assert_eq!(
        ::std::mem::align_of::<HSTR__>(),
        4usize,
        concat!("Alignment of ", stringify!(HSTR__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HSTR__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HSTR = *mut HSTR__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTASK__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HTASK__() {
    const UNINIT: ::std::mem::MaybeUninit<HTASK__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HTASK__>(),
        4usize,
        concat!("Size of: ", stringify!(HTASK__))
    );
    assert_eq!(
        ::std::mem::align_of::<HTASK__>(),
        4usize,
        concat!("Alignment of ", stringify!(HTASK__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTASK__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HTASK = *mut HTASK__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HWINSTA__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HWINSTA__() {
    const UNINIT: ::std::mem::MaybeUninit<HWINSTA__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HWINSTA__>(),
        4usize,
        concat!("Size of: ", stringify!(HWINSTA__))
    );
    assert_eq!(
        ::std::mem::align_of::<HWINSTA__>(),
        4usize,
        concat!("Alignment of ", stringify!(HWINSTA__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HWINSTA__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HWINSTA = *mut HWINSTA__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILETIME {
    pub dwLowDateTime: DWORD,
    pub dwHighDateTime: DWORD,
}
#[test]
fn bindgen_test_layout__FILETIME() {
    const UNINIT: ::std::mem::MaybeUninit<_FILETIME> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILETIME>(),
        8usize,
        concat!("Size of: ", stringify!(_FILETIME))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILETIME>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILETIME))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwLowDateTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILETIME),
            "::",
            stringify!(dwLowDateTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwHighDateTime) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILETIME),
            "::",
            stringify!(dwHighDateTime)
        )
    );
}
pub type FILETIME = _FILETIME;
pub type PFILETIME = *mut _FILETIME;
pub type LPFILETIME = *mut _FILETIME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HWND__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HWND__() {
    const UNINIT: ::std::mem::MaybeUninit<HWND__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HWND__>(),
        4usize,
        concat!("Size of: ", stringify!(HWND__))
    );
    assert_eq!(
        ::std::mem::align_of::<HWND__>(),
        4usize,
        concat!("Alignment of ", stringify!(HWND__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HWND__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HWND = *mut HWND__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HHOOK__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HHOOK__() {
    const UNINIT: ::std::mem::MaybeUninit<HHOOK__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HHOOK__>(),
        4usize,
        concat!("Size of: ", stringify!(HHOOK__))
    );
    assert_eq!(
        ::std::mem::align_of::<HHOOK__>(),
        4usize,
        concat!("Alignment of ", stringify!(HHOOK__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HHOOK__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HHOOK = *mut HHOOK__;
pub type HGDIOBJ = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HACCEL__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HACCEL__() {
    const UNINIT: ::std::mem::MaybeUninit<HACCEL__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HACCEL__>(),
        4usize,
        concat!("Size of: ", stringify!(HACCEL__))
    );
    assert_eq!(
        ::std::mem::align_of::<HACCEL__>(),
        4usize,
        concat!("Alignment of ", stringify!(HACCEL__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HACCEL__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HACCEL = *mut HACCEL__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HBITMAP__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HBITMAP__() {
    const UNINIT: ::std::mem::MaybeUninit<HBITMAP__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HBITMAP__>(),
        4usize,
        concat!("Size of: ", stringify!(HBITMAP__))
    );
    assert_eq!(
        ::std::mem::align_of::<HBITMAP__>(),
        4usize,
        concat!("Alignment of ", stringify!(HBITMAP__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HBITMAP__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HBITMAP = *mut HBITMAP__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HBRUSH__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HBRUSH__() {
    const UNINIT: ::std::mem::MaybeUninit<HBRUSH__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HBRUSH__>(),
        4usize,
        concat!("Size of: ", stringify!(HBRUSH__))
    );
    assert_eq!(
        ::std::mem::align_of::<HBRUSH__>(),
        4usize,
        concat!("Alignment of ", stringify!(HBRUSH__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HBRUSH__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HBRUSH = *mut HBRUSH__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HCOLORSPACE__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HCOLORSPACE__() {
    const UNINIT: ::std::mem::MaybeUninit<HCOLORSPACE__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HCOLORSPACE__>(),
        4usize,
        concat!("Size of: ", stringify!(HCOLORSPACE__))
    );
    assert_eq!(
        ::std::mem::align_of::<HCOLORSPACE__>(),
        4usize,
        concat!("Alignment of ", stringify!(HCOLORSPACE__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HCOLORSPACE__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HCOLORSPACE = *mut HCOLORSPACE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HDC__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HDC__() {
    const UNINIT: ::std::mem::MaybeUninit<HDC__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HDC__>(),
        4usize,
        concat!("Size of: ", stringify!(HDC__))
    );
    assert_eq!(
        ::std::mem::align_of::<HDC__>(),
        4usize,
        concat!("Alignment of ", stringify!(HDC__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HDC__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HDC = *mut HDC__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HGLRC__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HGLRC__() {
    const UNINIT: ::std::mem::MaybeUninit<HGLRC__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HGLRC__>(),
        4usize,
        concat!("Size of: ", stringify!(HGLRC__))
    );
    assert_eq!(
        ::std::mem::align_of::<HGLRC__>(),
        4usize,
        concat!("Alignment of ", stringify!(HGLRC__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HGLRC__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HGLRC = *mut HGLRC__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HDESK__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HDESK__() {
    const UNINIT: ::std::mem::MaybeUninit<HDESK__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HDESK__>(),
        4usize,
        concat!("Size of: ", stringify!(HDESK__))
    );
    assert_eq!(
        ::std::mem::align_of::<HDESK__>(),
        4usize,
        concat!("Alignment of ", stringify!(HDESK__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HDESK__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HDESK = *mut HDESK__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HENHMETAFILE__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HENHMETAFILE__() {
    const UNINIT: ::std::mem::MaybeUninit<HENHMETAFILE__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HENHMETAFILE__>(),
        4usize,
        concat!("Size of: ", stringify!(HENHMETAFILE__))
    );
    assert_eq!(
        ::std::mem::align_of::<HENHMETAFILE__>(),
        4usize,
        concat!("Alignment of ", stringify!(HENHMETAFILE__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HENHMETAFILE__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HENHMETAFILE = *mut HENHMETAFILE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HFONT__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HFONT__() {
    const UNINIT: ::std::mem::MaybeUninit<HFONT__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HFONT__>(),
        4usize,
        concat!("Size of: ", stringify!(HFONT__))
    );
    assert_eq!(
        ::std::mem::align_of::<HFONT__>(),
        4usize,
        concat!("Alignment of ", stringify!(HFONT__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HFONT__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HFONT = *mut HFONT__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HICON__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HICON__() {
    const UNINIT: ::std::mem::MaybeUninit<HICON__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HICON__>(),
        4usize,
        concat!("Size of: ", stringify!(HICON__))
    );
    assert_eq!(
        ::std::mem::align_of::<HICON__>(),
        4usize,
        concat!("Alignment of ", stringify!(HICON__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HICON__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HICON = *mut HICON__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HMENU__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HMENU__() {
    const UNINIT: ::std::mem::MaybeUninit<HMENU__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HMENU__>(),
        4usize,
        concat!("Size of: ", stringify!(HMENU__))
    );
    assert_eq!(
        ::std::mem::align_of::<HMENU__>(),
        4usize,
        concat!("Alignment of ", stringify!(HMENU__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HMENU__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HMENU = *mut HMENU__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HPALETTE__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HPALETTE__() {
    const UNINIT: ::std::mem::MaybeUninit<HPALETTE__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HPALETTE__>(),
        4usize,
        concat!("Size of: ", stringify!(HPALETTE__))
    );
    assert_eq!(
        ::std::mem::align_of::<HPALETTE__>(),
        4usize,
        concat!("Alignment of ", stringify!(HPALETTE__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HPALETTE__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HPALETTE = *mut HPALETTE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HPEN__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HPEN__() {
    const UNINIT: ::std::mem::MaybeUninit<HPEN__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HPEN__>(),
        4usize,
        concat!("Size of: ", stringify!(HPEN__))
    );
    assert_eq!(
        ::std::mem::align_of::<HPEN__>(),
        4usize,
        concat!("Alignment of ", stringify!(HPEN__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HPEN__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HPEN = *mut HPEN__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HMONITOR__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HMONITOR__() {
    const UNINIT: ::std::mem::MaybeUninit<HMONITOR__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HMONITOR__>(),
        4usize,
        concat!("Size of: ", stringify!(HMONITOR__))
    );
    assert_eq!(
        ::std::mem::align_of::<HMONITOR__>(),
        4usize,
        concat!("Alignment of ", stringify!(HMONITOR__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HMONITOR__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HMONITOR = *mut HMONITOR__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HWINEVENTHOOK__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HWINEVENTHOOK__() {
    const UNINIT: ::std::mem::MaybeUninit<HWINEVENTHOOK__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HWINEVENTHOOK__>(),
        4usize,
        concat!("Size of: ", stringify!(HWINEVENTHOOK__))
    );
    assert_eq!(
        ::std::mem::align_of::<HWINEVENTHOOK__>(),
        4usize,
        concat!("Alignment of ", stringify!(HWINEVENTHOOK__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HWINEVENTHOOK__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HWINEVENTHOOK = *mut HWINEVENTHOOK__;
pub type HCURSOR = HICON;
pub type COLORREF = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HUMPD__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HUMPD__() {
    const UNINIT: ::std::mem::MaybeUninit<HUMPD__> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HUMPD__>(),
        4usize,
        concat!("Size of: ", stringify!(HUMPD__))
    );
    assert_eq!(
        ::std::mem::align_of::<HUMPD__>(),
        4usize,
        concat!("Alignment of ", stringify!(HUMPD__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HUMPD__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HUMPD = *mut HUMPD__;
pub type LPCOLORREF = *mut DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRECT {
    pub left: LONG,
    pub top: LONG,
    pub right: LONG,
    pub bottom: LONG,
}
#[test]
fn bindgen_test_layout_tagRECT() {
    const UNINIT: ::std::mem::MaybeUninit<tagRECT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tagRECT>(),
        16usize,
        concat!("Size of: ", stringify!(tagRECT))
    );
    assert_eq!(
        ::std::mem::align_of::<tagRECT>(),
        4usize,
        concat!("Alignment of ", stringify!(tagRECT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagRECT),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagRECT),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tagRECT),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tagRECT),
            "::",
            stringify!(bottom)
        )
    );
}
pub type RECT = tagRECT;
pub type PRECT = *mut tagRECT;
pub type NPRECT = *mut tagRECT;
pub type LPRECT = *mut tagRECT;
pub type LPCRECT = *const RECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RECTL {
    pub left: LONG,
    pub top: LONG,
    pub right: LONG,
    pub bottom: LONG,
}
#[test]
fn bindgen_test_layout__RECTL() {
    const UNINIT: ::std::mem::MaybeUninit<_RECTL> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RECTL>(),
        16usize,
        concat!("Size of: ", stringify!(_RECTL))
    );
    assert_eq!(
        ::std::mem::align_of::<_RECTL>(),
        4usize,
        concat!("Alignment of ", stringify!(_RECTL))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RECTL),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_RECTL),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RECTL),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_RECTL),
            "::",
            stringify!(bottom)
        )
    );
}
pub type RECTL = _RECTL;
pub type PRECTL = *mut _RECTL;
pub type LPRECTL = *mut _RECTL;
pub type LPCRECTL = *const RECTL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPOINT {
    pub x: LONG,
    pub y: LONG,
}
#[test]
fn bindgen_test_layout_tagPOINT() {
    const UNINIT: ::std::mem::MaybeUninit<tagPOINT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tagPOINT>(),
        8usize,
        concat!("Size of: ", stringify!(tagPOINT))
    );
    assert_eq!(
        ::std::mem::align_of::<tagPOINT>(),
        4usize,
        concat!("Alignment of ", stringify!(tagPOINT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagPOINT),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagPOINT),
            "::",
            stringify!(y)
        )
    );
}
pub type POINT = tagPOINT;
pub type PPOINT = *mut tagPOINT;
pub type NPPOINT = *mut tagPOINT;
pub type LPPOINT = *mut tagPOINT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POINTL {
    pub x: LONG,
    pub y: LONG,
}
#[test]
fn bindgen_test_layout__POINTL() {
    const UNINIT: ::std::mem::MaybeUninit<_POINTL> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_POINTL>(),
        8usize,
        concat!("Size of: ", stringify!(_POINTL))
    );
    assert_eq!(
        ::std::mem::align_of::<_POINTL>(),
        4usize,
        concat!("Alignment of ", stringify!(_POINTL))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POINTL),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_POINTL),
            "::",
            stringify!(y)
        )
    );
}
pub type POINTL = _POINTL;
pub type PPOINTL = *mut _POINTL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSIZE {
    pub cx: LONG,
    pub cy: LONG,
}
#[test]
fn bindgen_test_layout_tagSIZE() {
    const UNINIT: ::std::mem::MaybeUninit<tagSIZE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tagSIZE>(),
        8usize,
        concat!("Size of: ", stringify!(tagSIZE))
    );
    assert_eq!(
        ::std::mem::align_of::<tagSIZE>(),
        4usize,
        concat!("Alignment of ", stringify!(tagSIZE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagSIZE),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cy) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagSIZE),
            "::",
            stringify!(cy)
        )
    );
}
pub type SIZE = tagSIZE;
pub type PSIZE = *mut tagSIZE;
pub type LPSIZE = *mut tagSIZE;
pub type SIZEL = SIZE;
pub type PSIZEL = *mut SIZE;
pub type LPSIZEL = *mut SIZE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPOINTS {
    pub x: SHORT,
    pub y: SHORT,
}
#[test]
fn bindgen_test_layout_tagPOINTS() {
    const UNINIT: ::std::mem::MaybeUninit<tagPOINTS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tagPOINTS>(),
        4usize,
        concat!("Size of: ", stringify!(tagPOINTS))
    );
    assert_eq!(
        ::std::mem::align_of::<tagPOINTS>(),
        2usize,
        concat!("Alignment of ", stringify!(tagPOINTS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagPOINTS),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tagPOINTS),
            "::",
            stringify!(y)
        )
    );
}
pub type POINTS = tagPOINTS;
pub type PPOINTS = *mut tagPOINTS;
pub type LPPOINTS = *mut tagPOINTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct APP_LOCAL_DEVICE_ID {
    pub value: [BYTE; 32usize],
}
#[test]
fn bindgen_test_layout_APP_LOCAL_DEVICE_ID() {
    const UNINIT: ::std::mem::MaybeUninit<APP_LOCAL_DEVICE_ID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<APP_LOCAL_DEVICE_ID>(),
        32usize,
        concat!("Size of: ", stringify!(APP_LOCAL_DEVICE_ID))
    );
    assert_eq!(
        ::std::mem::align_of::<APP_LOCAL_DEVICE_ID>(),
        1usize,
        concat!("Alignment of ", stringify!(APP_LOCAL_DEVICE_ID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(APP_LOCAL_DEVICE_ID),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DPI_AWARENESS_CONTEXT__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_DPI_AWARENESS_CONTEXT__() {
    const UNINIT: ::std::mem::MaybeUninit<DPI_AWARENESS_CONTEXT__> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DPI_AWARENESS_CONTEXT__>(),
        4usize,
        concat!("Size of: ", stringify!(DPI_AWARENESS_CONTEXT__))
    );
    assert_eq!(
        ::std::mem::align_of::<DPI_AWARENESS_CONTEXT__>(),
        4usize,
        concat!("Alignment of ", stringify!(DPI_AWARENESS_CONTEXT__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DPI_AWARENESS_CONTEXT__),
            "::",
            stringify!(unused)
        )
    );
}
pub type DPI_AWARENESS_CONTEXT = *mut DPI_AWARENESS_CONTEXT__;
pub const DPI_AWARENESS_DPI_AWARENESS_INVALID: DPI_AWARENESS = -1;
pub const DPI_AWARENESS_DPI_AWARENESS_UNAWARE: DPI_AWARENESS = 0;
pub const DPI_AWARENESS_DPI_AWARENESS_SYSTEM_AWARE: DPI_AWARENESS = 1;
pub const DPI_AWARENESS_DPI_AWARENESS_PER_MONITOR_AWARE: DPI_AWARENESS = 2;
pub type DPI_AWARENESS = ::std::os::raw::c_int;
pub const DPI_HOSTING_BEHAVIOR_DPI_HOSTING_BEHAVIOR_INVALID: DPI_HOSTING_BEHAVIOR = -1;
pub const DPI_HOSTING_BEHAVIOR_DPI_HOSTING_BEHAVIOR_DEFAULT: DPI_HOSTING_BEHAVIOR = 0;
pub const DPI_HOSTING_BEHAVIOR_DPI_HOSTING_BEHAVIOR_MIXED: DPI_HOSTING_BEHAVIOR = 1;
pub type DPI_HOSTING_BEHAVIOR = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNICODE_STRING {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: PWSTR,
}
#[test]
fn bindgen_test_layout__UNICODE_STRING() {
    const UNINIT: ::std::mem::MaybeUninit<_UNICODE_STRING> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_UNICODE_STRING>(),
        16usize,
        concat!("Size of: ", stringify!(_UNICODE_STRING))
    );
    assert_eq!(
        ::std::mem::align_of::<_UNICODE_STRING>(),
        8usize,
        concat!("Alignment of ", stringify!(_UNICODE_STRING))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNICODE_STRING),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumLength) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNICODE_STRING),
            "::",
            stringify!(MaximumLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNICODE_STRING),
            "::",
            stringify!(Buffer)
        )
    );
}
pub type UNICODE_STRING = _UNICODE_STRING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PEB_LDR_DATA {
    pub Reserved1: [BYTE; 8usize],
    pub Reserved2: [PVOID; 3usize],
    pub InMemoryOrderModuleList: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__PEB_LDR_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<_PEB_LDR_DATA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PEB_LDR_DATA>(),
        48usize,
        concat!("Size of: ", stringify!(_PEB_LDR_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_PEB_LDR_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(_PEB_LDR_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB_LDR_DATA),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB_LDR_DATA),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InMemoryOrderModuleList) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB_LDR_DATA),
            "::",
            stringify!(InMemoryOrderModuleList)
        )
    );
}
pub type PEB_LDR_DATA = _PEB_LDR_DATA;
pub type PPEB_LDR_DATA = *mut _PEB_LDR_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LDR_DATA_TABLE_ENTRY {
    pub Reserved1: [PVOID; 2usize],
    pub InMemoryOrderLinks: LIST_ENTRY,
    pub Reserved2: [PVOID; 2usize],
    pub DllBase: PVOID,
    pub Reserved3: [PVOID; 2usize],
    pub FullDllName: UNICODE_STRING,
    pub Reserved4: [BYTE; 8usize],
    pub Reserved5: [PVOID; 3usize],
    pub __bindgen_anon_1: _LDR_DATA_TABLE_ENTRY__bindgen_ty_1,
    pub TimeDateStamp: ULONG,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDR_DATA_TABLE_ENTRY__bindgen_ty_1 {
    pub CheckSum: ULONG,
    pub Reserved6: PVOID,
}
#[test]
fn bindgen_test_layout__LDR_DATA_TABLE_ENTRY__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_LDR_DATA_TABLE_ENTRY__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDR_DATA_TABLE_ENTRY__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_LDR_DATA_TABLE_ENTRY__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDR_DATA_TABLE_ENTRY__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_LDR_DATA_TABLE_ENTRY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CheckSum) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY__bindgen_ty_1),
            "::",
            stringify!(CheckSum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY__bindgen_ty_1),
            "::",
            stringify!(Reserved6)
        )
    );
}
#[test]
fn bindgen_test_layout__LDR_DATA_TABLE_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_LDR_DATA_TABLE_ENTRY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDR_DATA_TABLE_ENTRY>(),
        136usize,
        concat!("Size of: ", stringify!(_LDR_DATA_TABLE_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDR_DATA_TABLE_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_LDR_DATA_TABLE_ENTRY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InMemoryOrderLinks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(InMemoryOrderLinks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DllBase) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(DllBase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FullDllName) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(FullDllName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved5) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDR_DATA_TABLE_ENTRY),
            "::",
            stringify!(TimeDateStamp)
        )
    );
}
pub type LDR_DATA_TABLE_ENTRY = _LDR_DATA_TABLE_ENTRY;
pub type PLDR_DATA_TABLE_ENTRY = *mut _LDR_DATA_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_USER_PROCESS_PARAMETERS {
    pub Reserved1: [BYTE; 16usize],
    pub Reserved2: [PVOID; 10usize],
    pub ImagePathName: UNICODE_STRING,
    pub CommandLine: UNICODE_STRING,
}
#[test]
fn bindgen_test_layout__RTL_USER_PROCESS_PARAMETERS() {
    const UNINIT: ::std::mem::MaybeUninit<_RTL_USER_PROCESS_PARAMETERS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RTL_USER_PROCESS_PARAMETERS>(),
        128usize,
        concat!("Size of: ", stringify!(_RTL_USER_PROCESS_PARAMETERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_USER_PROCESS_PARAMETERS>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_USER_PROCESS_PARAMETERS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_USER_PROCESS_PARAMETERS),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_USER_PROCESS_PARAMETERS),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ImagePathName) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_USER_PROCESS_PARAMETERS),
            "::",
            stringify!(ImagePathName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CommandLine) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_USER_PROCESS_PARAMETERS),
            "::",
            stringify!(CommandLine)
        )
    );
}
pub type RTL_USER_PROCESS_PARAMETERS = _RTL_USER_PROCESS_PARAMETERS;
pub type PRTL_USER_PROCESS_PARAMETERS = *mut _RTL_USER_PROCESS_PARAMETERS;
pub type PPS_POST_PROCESS_INIT_ROUTINE = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PEB {
    pub Reserved1: [BYTE; 2usize],
    pub BeingDebugged: BYTE,
    pub Reserved2: [BYTE; 1usize],
    pub Reserved3: [PVOID; 2usize],
    pub Ldr: PPEB_LDR_DATA,
    pub ProcessParameters: PRTL_USER_PROCESS_PARAMETERS,
    pub Reserved4: [PVOID; 3usize],
    pub AtlThunkSListPtr: PVOID,
    pub Reserved5: PVOID,
    pub Reserved6: ULONG,
    pub Reserved7: PVOID,
    pub Reserved8: ULONG,
    pub AtlThunkSListPtr32: ULONG,
    pub Reserved9: [PVOID; 45usize],
    pub Reserved10: [BYTE; 96usize],
    pub PostProcessInitRoutine: PPS_POST_PROCESS_INIT_ROUTINE,
    pub Reserved11: [BYTE; 128usize],
    pub Reserved12: [PVOID; 1usize],
    pub SessionId: ULONG,
}
#[test]
fn bindgen_test_layout__PEB() {
    const UNINIT: ::std::mem::MaybeUninit<_PEB> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PEB>(),
        712usize,
        concat!("Size of: ", stringify!(_PEB))
    );
    assert_eq!(
        ::std::mem::align_of::<_PEB>(),
        8usize,
        concat!("Alignment of ", stringify!(_PEB))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BeingDebugged) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(BeingDebugged)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ldr) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(_PEB), "::", stringify!(Ldr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProcessParameters) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(ProcessParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AtlThunkSListPtr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(AtlThunkSListPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved5) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved6) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved7) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(Reserved7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved8) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(Reserved8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AtlThunkSListPtr32) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(AtlThunkSListPtr32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved9) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(Reserved9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved10) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(Reserved10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PostProcessInitRoutine) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(PostProcessInitRoutine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved11) as usize - ptr as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(Reserved11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved12) as usize - ptr as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(Reserved12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionId) as usize - ptr as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(_PEB),
            "::",
            stringify!(SessionId)
        )
    );
}
pub type PEB = _PEB;
pub type PPEB = *mut _PEB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TEB {
    pub Reserved1: [PVOID; 12usize],
    pub ProcessEnvironmentBlock: PPEB,
    pub Reserved2: [PVOID; 399usize],
    pub Reserved3: [BYTE; 1952usize],
    pub TlsSlots: [PVOID; 64usize],
    pub Reserved4: [BYTE; 8usize],
    pub Reserved5: [PVOID; 26usize],
    pub ReservedForOle: PVOID,
    pub Reserved6: [PVOID; 4usize],
    pub TlsExpansionSlots: PVOID,
}
#[test]
fn bindgen_test_layout__TEB() {
    const UNINIT: ::std::mem::MaybeUninit<_TEB> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_TEB>(),
        6024usize,
        concat!("Size of: ", stringify!(_TEB))
    );
    assert_eq!(
        ::std::mem::align_of::<_TEB>(),
        8usize,
        concat!("Alignment of ", stringify!(_TEB))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TEB),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProcessEnvironmentBlock) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_TEB),
            "::",
            stringify!(ProcessEnvironmentBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_TEB),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        3296usize,
        concat!(
            "Offset of field: ",
            stringify!(_TEB),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TlsSlots) as usize - ptr as usize },
        5248usize,
        concat!(
            "Offset of field: ",
            stringify!(_TEB),
            "::",
            stringify!(TlsSlots)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        5760usize,
        concat!(
            "Offset of field: ",
            stringify!(_TEB),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved5) as usize - ptr as usize },
        5768usize,
        concat!(
            "Offset of field: ",
            stringify!(_TEB),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedForOle) as usize - ptr as usize },
        5976usize,
        concat!(
            "Offset of field: ",
            stringify!(_TEB),
            "::",
            stringify!(ReservedForOle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved6) as usize - ptr as usize },
        5984usize,
        concat!(
            "Offset of field: ",
            stringify!(_TEB),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TlsExpansionSlots) as usize - ptr as usize },
        6016usize,
        concat!(
            "Offset of field: ",
            stringify!(_TEB),
            "::",
            stringify!(TlsExpansionSlots)
        )
    );
}
pub type TEB = _TEB;
pub type PTEB = *mut TEB;
pub type NTSTATUS = LONG;
pub type PNTSTATUS = *mut LONG;
pub type PCSZ = *const ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STRING {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: PCHAR,
}
#[test]
fn bindgen_test_layout__STRING() {
    const UNINIT: ::std::mem::MaybeUninit<_STRING> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_STRING>(),
        16usize,
        concat!("Size of: ", stringify!(_STRING))
    );
    assert_eq!(
        ::std::mem::align_of::<_STRING>(),
        8usize,
        concat!("Alignment of ", stringify!(_STRING))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_STRING),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumLength) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_STRING),
            "::",
            stringify!(MaximumLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_STRING),
            "::",
            stringify!(Buffer)
        )
    );
}
pub type STRING = _STRING;
pub type PSTRING = *mut STRING;
pub type ANSI_STRING = STRING;
pub type PANSI_STRING = PSTRING;
pub type PCANSI_STRING = PSTRING;
pub type OEM_STRING = STRING;
pub type POEM_STRING = PSTRING;
pub type PCOEM_STRING = *const STRING;
pub type PUNICODE_STRING = *mut UNICODE_STRING;
pub type PCUNICODE_STRING = *const UNICODE_STRING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_ATTRIBUTES {
    pub Length: ULONG,
    pub pad1: ULONG,
    pub RootDirectory: HANDLE,
    pub ObjectName: PUNICODE_STRING,
    pub Attributes: ULONG,
    pub pad2: ULONG,
    pub SecurityDescriptor: PVOID,
    pub SecurityQualityOfService: PVOID,
}
#[test]
fn bindgen_test_layout__OBJECT_ATTRIBUTES() {
    const UNINIT: ::std::mem::MaybeUninit<_OBJECT_ATTRIBUTES> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OBJECT_ATTRIBUTES>(),
        48usize,
        concat!("Size of: ", stringify!(_OBJECT_ATTRIBUTES))
    );
    assert_eq!(
        ::std::mem::align_of::<_OBJECT_ATTRIBUTES>(),
        8usize,
        concat!("Alignment of ", stringify!(_OBJECT_ATTRIBUTES))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RootDirectory) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(RootDirectory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(ObjectName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Attributes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(Attributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad2) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SecurityDescriptor) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(SecurityDescriptor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SecurityQualityOfService) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(SecurityQualityOfService)
        )
    );
}
pub type OBJECT_ATTRIBUTES = _OBJECT_ATTRIBUTES;
pub type POBJECT_ATTRIBUTES = *mut _OBJECT_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_DATA_INFORMATION {
    pub InheritHandle: BOOLEAN,
    pub ProtectFromClose: BOOLEAN,
}
#[test]
fn bindgen_test_layout__OBJECT_DATA_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_OBJECT_DATA_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OBJECT_DATA_INFORMATION>(),
        2usize,
        concat!("Size of: ", stringify!(_OBJECT_DATA_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_OBJECT_DATA_INFORMATION>(),
        1usize,
        concat!("Alignment of ", stringify!(_OBJECT_DATA_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InheritHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_DATA_INFORMATION),
            "::",
            stringify!(InheritHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProtectFromClose) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_DATA_INFORMATION),
            "::",
            stringify!(ProtectFromClose)
        )
    );
}
pub type OBJECT_DATA_INFORMATION = _OBJECT_DATA_INFORMATION;
pub type POBJECT_DATA_INFORMATION = *mut _OBJECT_DATA_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OBJECT_BASIC_INFORMATION {
    pub Attributes: ULONG,
    pub GrantedAccess: ACCESS_MASK,
    pub HandleCount: ULONG,
    pub PointerCount: ULONG,
    pub PagedPoolUsage: ULONG,
    pub NonPagedPoolUsage: ULONG,
    pub Reserved: [ULONG; 3usize],
    pub NameInformationLength: ULONG,
    pub TypeInformationLength: ULONG,
    pub SecurityDescriptorLength: ULONG,
    pub CreateTime: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__OBJECT_BASIC_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_OBJECT_BASIC_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OBJECT_BASIC_INFORMATION>(),
        56usize,
        concat!("Size of: ", stringify!(_OBJECT_BASIC_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_OBJECT_BASIC_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_OBJECT_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Attributes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_BASIC_INFORMATION),
            "::",
            stringify!(Attributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GrantedAccess) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_BASIC_INFORMATION),
            "::",
            stringify!(GrantedAccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HandleCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_BASIC_INFORMATION),
            "::",
            stringify!(HandleCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PointerCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_BASIC_INFORMATION),
            "::",
            stringify!(PointerCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PagedPoolUsage) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_BASIC_INFORMATION),
            "::",
            stringify!(PagedPoolUsage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NonPagedPoolUsage) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_BASIC_INFORMATION),
            "::",
            stringify!(NonPagedPoolUsage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_BASIC_INFORMATION),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NameInformationLength) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_BASIC_INFORMATION),
            "::",
            stringify!(NameInformationLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TypeInformationLength) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_BASIC_INFORMATION),
            "::",
            stringify!(TypeInformationLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SecurityDescriptorLength) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_BASIC_INFORMATION),
            "::",
            stringify!(SecurityDescriptorLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateTime) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_BASIC_INFORMATION),
            "::",
            stringify!(CreateTime)
        )
    );
}
pub type OBJECT_BASIC_INFORMATION = _OBJECT_BASIC_INFORMATION;
pub type POBJECT_BASIC_INFORMATION = *mut _OBJECT_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_NAME_INFORMATION {
    pub Name: UNICODE_STRING,
}
#[test]
fn bindgen_test_layout__OBJECT_NAME_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_OBJECT_NAME_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OBJECT_NAME_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_OBJECT_NAME_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_OBJECT_NAME_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_OBJECT_NAME_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_NAME_INFORMATION),
            "::",
            stringify!(Name)
        )
    );
}
pub type OBJECT_NAME_INFORMATION = _OBJECT_NAME_INFORMATION;
pub type POBJECT_NAME_INFORMATION = *mut _OBJECT_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_TYPE_INFORMATION {
    pub TypeName: UNICODE_STRING,
    pub TotalNumberOfObjects: ULONG,
    pub TotalNumberOfHandles: ULONG,
    pub TotalPagedPoolUsage: ULONG,
    pub TotalNonPagedPoolUsage: ULONG,
    pub TotalNamePoolUsage: ULONG,
    pub TotalHandleTableUsage: ULONG,
    pub HighWaterNumberOfObjects: ULONG,
    pub HighWaterNumberOfHandles: ULONG,
    pub HighWaterPagedPoolUsage: ULONG,
    pub HighWaterNonPagedPoolUsage: ULONG,
    pub HighWaterNamePoolUsage: ULONG,
    pub HighWaterHandleTableUsage: ULONG,
    pub InvalidAttributes: ULONG,
    pub GenericMapping: GENERIC_MAPPING,
    pub ValidAccessMask: ULONG,
    pub SecurityRequired: BOOLEAN,
    pub MaintainHandleCount: BOOLEAN,
    pub PoolType: ULONG,
    pub DefaultPagedPoolCharge: ULONG,
    pub DefaultNonPagedPoolCharge: ULONG,
}
#[test]
fn bindgen_test_layout__OBJECT_TYPE_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_OBJECT_TYPE_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OBJECT_TYPE_INFORMATION>(),
        104usize,
        concat!("Size of: ", stringify!(_OBJECT_TYPE_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_OBJECT_TYPE_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_OBJECT_TYPE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TypeName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(TypeName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalNumberOfObjects) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(TotalNumberOfObjects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalNumberOfHandles) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(TotalNumberOfHandles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalPagedPoolUsage) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(TotalPagedPoolUsage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalNonPagedPoolUsage) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(TotalNonPagedPoolUsage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalNamePoolUsage) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(TotalNamePoolUsage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalHandleTableUsage) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(TotalHandleTableUsage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighWaterNumberOfObjects) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(HighWaterNumberOfObjects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighWaterNumberOfHandles) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(HighWaterNumberOfHandles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighWaterPagedPoolUsage) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(HighWaterPagedPoolUsage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighWaterNonPagedPoolUsage) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(HighWaterNonPagedPoolUsage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighWaterNamePoolUsage) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(HighWaterNamePoolUsage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighWaterHandleTableUsage) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(HighWaterHandleTableUsage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InvalidAttributes) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(InvalidAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GenericMapping) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(GenericMapping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ValidAccessMask) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(ValidAccessMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SecurityRequired) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(SecurityRequired)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaintainHandleCount) as usize - ptr as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(MaintainHandleCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PoolType) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(PoolType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DefaultPagedPoolCharge) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(DefaultPagedPoolCharge)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DefaultNonPagedPoolCharge) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(DefaultNonPagedPoolCharge)
        )
    );
}
pub type OBJECT_TYPE_INFORMATION = _OBJECT_TYPE_INFORMATION;
pub type POBJECT_TYPE_INFORMATION = *mut _OBJECT_TYPE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_ALL_INFORMATION {
    pub NumberOfObjects: ULONG,
    pub ObjectTypeInformation: [OBJECT_TYPE_INFORMATION; 1usize],
}
#[test]
fn bindgen_test_layout__OBJECT_ALL_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_OBJECT_ALL_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OBJECT_ALL_INFORMATION>(),
        112usize,
        concat!("Size of: ", stringify!(_OBJECT_ALL_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_OBJECT_ALL_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_OBJECT_ALL_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfObjects) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ALL_INFORMATION),
            "::",
            stringify!(NumberOfObjects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectTypeInformation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ALL_INFORMATION),
            "::",
            stringify!(ObjectTypeInformation)
        )
    );
}
pub type OBJECT_ALL_INFORMATION = _OBJECT_ALL_INFORMATION;
pub type POBJECT_ALL_INFORMATION = *mut _OBJECT_ALL_INFORMATION;
pub const _FILE_INFORMATION_CLASS_FileDirectoryInformation: _FILE_INFORMATION_CLASS = 1;
pub const _FILE_INFORMATION_CLASS_FileFullDirectoryInformation: _FILE_INFORMATION_CLASS = 2;
pub const _FILE_INFORMATION_CLASS_FileBothDirectoryInformation: _FILE_INFORMATION_CLASS = 3;
pub const _FILE_INFORMATION_CLASS_FileBasicInformation: _FILE_INFORMATION_CLASS = 4;
pub const _FILE_INFORMATION_CLASS_FileStandardInformation: _FILE_INFORMATION_CLASS = 5;
pub const _FILE_INFORMATION_CLASS_FileInternalInformation: _FILE_INFORMATION_CLASS = 6;
pub const _FILE_INFORMATION_CLASS_FileEaInformation: _FILE_INFORMATION_CLASS = 7;
pub const _FILE_INFORMATION_CLASS_FileAccessInformation: _FILE_INFORMATION_CLASS = 8;
pub const _FILE_INFORMATION_CLASS_FileNameInformation: _FILE_INFORMATION_CLASS = 9;
pub const _FILE_INFORMATION_CLASS_FileRenameInformation: _FILE_INFORMATION_CLASS = 10;
pub const _FILE_INFORMATION_CLASS_FileLinkInformation: _FILE_INFORMATION_CLASS = 11;
pub const _FILE_INFORMATION_CLASS_FileNamesInformation: _FILE_INFORMATION_CLASS = 12;
pub const _FILE_INFORMATION_CLASS_FileDispositionInformation: _FILE_INFORMATION_CLASS = 13;
pub const _FILE_INFORMATION_CLASS_FilePositionInformation: _FILE_INFORMATION_CLASS = 14;
pub const _FILE_INFORMATION_CLASS_FileFullEaInformation: _FILE_INFORMATION_CLASS = 15;
pub const _FILE_INFORMATION_CLASS_FileModeInformation: _FILE_INFORMATION_CLASS = 16;
pub const _FILE_INFORMATION_CLASS_FileAlignmentInformation: _FILE_INFORMATION_CLASS = 17;
pub const _FILE_INFORMATION_CLASS_FileAllInformation: _FILE_INFORMATION_CLASS = 18;
pub const _FILE_INFORMATION_CLASS_FileAllocationInformation: _FILE_INFORMATION_CLASS = 19;
pub const _FILE_INFORMATION_CLASS_FileEndOfFileInformation: _FILE_INFORMATION_CLASS = 20;
pub const _FILE_INFORMATION_CLASS_FileAlternateNameInformation: _FILE_INFORMATION_CLASS = 21;
pub const _FILE_INFORMATION_CLASS_FileStreamInformation: _FILE_INFORMATION_CLASS = 22;
pub const _FILE_INFORMATION_CLASS_FilePipeInformation: _FILE_INFORMATION_CLASS = 23;
pub const _FILE_INFORMATION_CLASS_FilePipeLocalInformation: _FILE_INFORMATION_CLASS = 24;
pub const _FILE_INFORMATION_CLASS_FilePipeRemoteInformation: _FILE_INFORMATION_CLASS = 25;
pub const _FILE_INFORMATION_CLASS_FileMailslotQueryInformation: _FILE_INFORMATION_CLASS = 26;
pub const _FILE_INFORMATION_CLASS_FileMailslotSetInformation: _FILE_INFORMATION_CLASS = 27;
pub const _FILE_INFORMATION_CLASS_FileCompressionInformation: _FILE_INFORMATION_CLASS = 28;
pub const _FILE_INFORMATION_CLASS_FileObjectIdInformation: _FILE_INFORMATION_CLASS = 29;
pub const _FILE_INFORMATION_CLASS_FileCompletionInformation: _FILE_INFORMATION_CLASS = 30;
pub const _FILE_INFORMATION_CLASS_FileMoveClusterInformation: _FILE_INFORMATION_CLASS = 31;
pub const _FILE_INFORMATION_CLASS_FileQuotaInformation: _FILE_INFORMATION_CLASS = 32;
pub const _FILE_INFORMATION_CLASS_FileReparsePointInformation: _FILE_INFORMATION_CLASS = 33;
pub const _FILE_INFORMATION_CLASS_FileNetworkOpenInformation: _FILE_INFORMATION_CLASS = 34;
pub const _FILE_INFORMATION_CLASS_FileAttributeTagInformation: _FILE_INFORMATION_CLASS = 35;
pub const _FILE_INFORMATION_CLASS_FileTrackingInformation: _FILE_INFORMATION_CLASS = 36;
pub const _FILE_INFORMATION_CLASS_FileIdBothDirectoryInformation: _FILE_INFORMATION_CLASS = 37;
pub const _FILE_INFORMATION_CLASS_FileIdFullDirectoryInformation: _FILE_INFORMATION_CLASS = 38;
pub const _FILE_INFORMATION_CLASS_FileValidDataLengthInformation: _FILE_INFORMATION_CLASS = 39;
pub const _FILE_INFORMATION_CLASS_FileShortNameInformation: _FILE_INFORMATION_CLASS = 40;
pub const _FILE_INFORMATION_CLASS_FileSfioReserveInformation: _FILE_INFORMATION_CLASS = 44;
pub const _FILE_INFORMATION_CLASS_FileSfioVolumeInformation: _FILE_INFORMATION_CLASS = 45;
pub const _FILE_INFORMATION_CLASS_FileHardLinkInformation: _FILE_INFORMATION_CLASS = 46;
pub const _FILE_INFORMATION_CLASS_FileNormalizedNameInformation: _FILE_INFORMATION_CLASS = 48;
pub const _FILE_INFORMATION_CLASS_FileIdGlobalTxDirectoryInformation: _FILE_INFORMATION_CLASS = 50;
pub const _FILE_INFORMATION_CLASS_FileStandardLinkInformation: _FILE_INFORMATION_CLASS = 54;
pub const _FILE_INFORMATION_CLASS_FileMaximumInformation: _FILE_INFORMATION_CLASS = 55;
pub type _FILE_INFORMATION_CLASS = ::std::os::raw::c_uint;
pub use self::_FILE_INFORMATION_CLASS as FILE_INFORMATION_CLASS;
pub type PFILE_INFORMATION_CLASS = *mut _FILE_INFORMATION_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_DIRECTORY_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_DIRECTORY_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_DIRECTORY_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_DIRECTORY_INFORMATION>(),
        72usize,
        concat!("Size of: ", stringify!(_FILE_DIRECTORY_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_DIRECTORY_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_DIRECTORY_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(FileIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_DIRECTORY_INFORMATION = _FILE_DIRECTORY_INFORMATION;
pub type PFILE_DIRECTORY_INFORMATION = *mut _FILE_DIRECTORY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FULL_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FULL_DIR_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_FULL_DIR_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_FULL_DIR_INFORMATION>(),
        72usize,
        concat!("Size of: ", stringify!(_FILE_FULL_DIR_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_FULL_DIR_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_FULL_DIR_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EaSize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(EaSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_FULL_DIR_INFORMATION = _FILE_FULL_DIR_INFORMATION;
pub type PFILE_FULL_DIR_INFORMATION = *mut _FILE_FULL_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_FULL_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub FileId: LARGE_INTEGER,
    pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_ID_FULL_DIR_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_ID_FULL_DIR_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_ID_FULL_DIR_INFORMATION>(),
        88usize,
        concat!("Size of: ", stringify!(_FILE_ID_FULL_DIR_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_ID_FULL_DIR_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_ID_FULL_DIR_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_FULL_DIR_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_FULL_DIR_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_FULL_DIR_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_FULL_DIR_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_FULL_DIR_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_FULL_DIR_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_FULL_DIR_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EaSize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_FULL_DIR_INFORMATION),
            "::",
            stringify!(EaSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileId) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_ID_FULL_DIR_INFORMATION = _FILE_ID_FULL_DIR_INFORMATION;
pub type PFILE_ID_FULL_DIR_INFORMATION = *mut _FILE_ID_FULL_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BOTH_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub ShortNameLength: CHAR,
    pub ShortName: [WCHAR; 12usize],
    pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_BOTH_DIR_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_BOTH_DIR_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_BOTH_DIR_INFORMATION>(),
        96usize,
        concat!("Size of: ", stringify!(_FILE_BOTH_DIR_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_BOTH_DIR_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_BOTH_DIR_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EaSize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(EaSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ShortNameLength) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(ShortNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ShortName) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(ShortName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_BOTH_DIR_INFORMATION = _FILE_BOTH_DIR_INFORMATION;
pub type PFILE_BOTH_DIR_INFORMATION = *mut _FILE_BOTH_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_BOTH_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub ShortNameLength: CHAR,
    pub ShortName: [WCHAR; 12usize],
    pub FileId: LARGE_INTEGER,
    pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_ID_BOTH_DIR_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_ID_BOTH_DIR_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_ID_BOTH_DIR_INFORMATION>(),
        112usize,
        concat!("Size of: ", stringify!(_FILE_ID_BOTH_DIR_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_ID_BOTH_DIR_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_ID_BOTH_DIR_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_BOTH_DIR_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_BOTH_DIR_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_BOTH_DIR_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_BOTH_DIR_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_BOTH_DIR_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_BOTH_DIR_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_BOTH_DIR_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EaSize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_BOTH_DIR_INFORMATION),
            "::",
            stringify!(EaSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ShortNameLength) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_BOTH_DIR_INFORMATION),
            "::",
            stringify!(ShortNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ShortName) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_BOTH_DIR_INFORMATION),
            "::",
            stringify!(ShortName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileId) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_ID_BOTH_DIR_INFORMATION = _FILE_ID_BOTH_DIR_INFORMATION;
pub type PFILE_ID_BOTH_DIR_INFORMATION = *mut _FILE_ID_BOTH_DIR_INFORMATION;
pub type FILE_FULL_DIRECTORY_INFORMATION = _FILE_FULL_DIR_INFORMATION;
pub type PFILE_FULL_DIRECTORY_INFORMATION = *mut _FILE_FULL_DIR_INFORMATION;
pub type FILE_ID_FULL_DIRECTORY_INFORMATION = _FILE_ID_FULL_DIR_INFORMATION;
pub type PFILE_ID_FULL_DIRECTORY_INFORMATION = *mut _FILE_ID_FULL_DIR_INFORMATION;
pub type FILE_BOTH_DIRECTORY_INFORMATION = _FILE_BOTH_DIR_INFORMATION;
pub type PFILE_BOTH_DIRECTORY_INFORMATION = *mut _FILE_BOTH_DIR_INFORMATION;
pub type FILE_ID_BOTH_DIRECTORY_INFORMATION = _FILE_ID_BOTH_DIR_INFORMATION;
pub type PFILE_ID_BOTH_DIRECTORY_INFORMATION = *mut _FILE_ID_BOTH_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BASIC_INFORMATION {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_BASIC_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_BASIC_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_BASIC_INFORMATION>(),
        40usize,
        concat!("Size of: ", stringify!(_FILE_BASIC_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_BASIC_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
}
pub type FILE_BASIC_INFORMATION = _FILE_BASIC_INFORMATION;
pub type PFILE_BASIC_INFORMATION = *mut _FILE_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STANDARD_INFORMATION {
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub NumberOfLinks: ULONG,
    pub DeletePending: BOOLEAN,
    pub Directory: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FILE_STANDARD_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_STANDARD_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_STANDARD_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_FILE_STANDARD_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_STANDARD_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_STANDARD_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfLinks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(NumberOfLinks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeletePending) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(DeletePending)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Directory) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(Directory)
        )
    );
}
pub type FILE_STANDARD_INFORMATION = _FILE_STANDARD_INFORMATION;
pub type PFILE_STANDARD_INFORMATION = *mut _FILE_STANDARD_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_INTERNAL_INFORMATION {
    pub IndexNumber: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_INTERNAL_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_INTERNAL_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_INTERNAL_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_INTERNAL_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_INTERNAL_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_INTERNAL_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IndexNumber) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_INTERNAL_INFORMATION),
            "::",
            stringify!(IndexNumber)
        )
    );
}
pub type FILE_INTERNAL_INFORMATION = _FILE_INTERNAL_INFORMATION;
pub type PFILE_INTERNAL_INFORMATION = *mut _FILE_INTERNAL_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_EA_INFORMATION {
    pub EaSize: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_EA_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_EA_INFORMATION> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_EA_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_EA_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_EA_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_EA_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EaSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_EA_INFORMATION),
            "::",
            stringify!(EaSize)
        )
    );
}
pub type FILE_EA_INFORMATION = _FILE_EA_INFORMATION;
pub type PFILE_EA_INFORMATION = *mut _FILE_EA_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ACCESS_INFORMATION {
    pub AccessFlags: ACCESS_MASK,
}
#[test]
fn bindgen_test_layout__FILE_ACCESS_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_ACCESS_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_ACCESS_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_ACCESS_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_ACCESS_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_ACCESS_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccessFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ACCESS_INFORMATION),
            "::",
            stringify!(AccessFlags)
        )
    );
}
pub type FILE_ACCESS_INFORMATION = _FILE_ACCESS_INFORMATION;
pub type PFILE_ACCESS_INFORMATION = *mut _FILE_ACCESS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LINK_INFORMATION {
    pub ReplaceIfExists: BOOLEAN,
    pub RootDirectory: HANDLE,
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_LINK_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_LINK_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_LINK_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_FILE_LINK_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_LINK_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_LINK_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReplaceIfExists) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LINK_INFORMATION),
            "::",
            stringify!(ReplaceIfExists)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RootDirectory) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LINK_INFORMATION),
            "::",
            stringify!(RootDirectory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LINK_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LINK_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_LINK_INFORMATION = _FILE_LINK_INFORMATION;
pub type PFILE_LINK_INFORMATION = *mut _FILE_LINK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_NAME_INFORMATION {
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_NAME_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_NAME_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_NAME_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_NAME_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_NAME_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_NAME_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAME_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAME_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_NAME_INFORMATION = _FILE_NAME_INFORMATION;
pub type PFILE_NAME_INFORMATION = *mut _FILE_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_RENAME_INFORMATION {
    pub ReplaceIfExists: BOOLEAN,
    pub RootDirectory: HANDLE,
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_RENAME_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_RENAME_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_RENAME_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_FILE_RENAME_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_RENAME_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_RENAME_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReplaceIfExists) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_RENAME_INFORMATION),
            "::",
            stringify!(ReplaceIfExists)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RootDirectory) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_RENAME_INFORMATION),
            "::",
            stringify!(RootDirectory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_RENAME_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_RENAME_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_RENAME_INFORMATION = _FILE_RENAME_INFORMATION;
pub type PFILE_RENAME_INFORMATION = *mut _FILE_RENAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_NAMES_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_NAMES_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_NAMES_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_NAMES_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_NAMES_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_NAMES_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_NAMES_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAMES_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAMES_INFORMATION),
            "::",
            stringify!(FileIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAMES_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAMES_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_NAMES_INFORMATION = _FILE_NAMES_INFORMATION;
pub type PFILE_NAMES_INFORMATION = *mut _FILE_NAMES_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_DISPOSITION_INFORMATION {
    pub DoDeleteFile: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FILE_DISPOSITION_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_DISPOSITION_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_DISPOSITION_INFORMATION>(),
        1usize,
        concat!("Size of: ", stringify!(_FILE_DISPOSITION_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_DISPOSITION_INFORMATION>(),
        1usize,
        concat!("Alignment of ", stringify!(_FILE_DISPOSITION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DoDeleteFile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DISPOSITION_INFORMATION),
            "::",
            stringify!(DoDeleteFile)
        )
    );
}
pub type FILE_DISPOSITION_INFORMATION = _FILE_DISPOSITION_INFORMATION;
pub type PFILE_DISPOSITION_INFORMATION = *mut _FILE_DISPOSITION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_POSITION_INFORMATION {
    pub CurrentByteOffset: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_POSITION_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_POSITION_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_POSITION_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_POSITION_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_POSITION_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_POSITION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentByteOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_POSITION_INFORMATION),
            "::",
            stringify!(CurrentByteOffset)
        )
    );
}
pub type FILE_POSITION_INFORMATION = _FILE_POSITION_INFORMATION;
pub type PFILE_POSITION_INFORMATION = *mut _FILE_POSITION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ALIGNMENT_INFORMATION {
    pub AlignmentRequirement: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_ALIGNMENT_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_ALIGNMENT_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_ALIGNMENT_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_ALIGNMENT_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_ALIGNMENT_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_ALIGNMENT_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AlignmentRequirement) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALIGNMENT_INFORMATION),
            "::",
            stringify!(AlignmentRequirement)
        )
    );
}
pub type FILE_ALIGNMENT_INFORMATION = _FILE_ALIGNMENT_INFORMATION;
pub type PFILE_ALIGNMENT_INFORMATION = *mut _FILE_ALIGNMENT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ALLOCATION_INFORMATION {
    pub AllocationSize: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_ALLOCATION_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_ALLOCATION_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_ALLOCATION_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_ALLOCATION_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_ALLOCATION_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_ALLOCATION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALLOCATION_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
}
pub type FILE_ALLOCATION_INFORMATION = _FILE_ALLOCATION_INFORMATION;
pub type PFILE_ALLOCATION_INFORMATION = *mut _FILE_ALLOCATION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_END_OF_FILE_INFORMATION {
    pub EndOfFile: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_END_OF_FILE_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_END_OF_FILE_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_END_OF_FILE_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_END_OF_FILE_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_END_OF_FILE_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_END_OF_FILE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_END_OF_FILE_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
}
pub type FILE_END_OF_FILE_INFORMATION = _FILE_END_OF_FILE_INFORMATION;
pub type PFILE_END_OF_FILE_INFORMATION = *mut _FILE_END_OF_FILE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NETWORK_OPEN_INFORMATION {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_NETWORK_OPEN_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_NETWORK_OPEN_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_NETWORK_OPEN_INFORMATION>(),
        56usize,
        concat!("Size of: ", stringify!(_FILE_NETWORK_OPEN_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_NETWORK_OPEN_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_NETWORK_OPEN_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
}
pub type FILE_NETWORK_OPEN_INFORMATION = _FILE_NETWORK_OPEN_INFORMATION;
pub type PFILE_NETWORK_OPEN_INFORMATION = *mut _FILE_NETWORK_OPEN_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FULL_EA_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub Flags: UCHAR,
    pub EaNameLength: UCHAR,
    pub EaValueLength: USHORT,
    pub EaName: [CHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FULL_EA_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_FULL_EA_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_FULL_EA_INFORMATION>(),
        12usize,
        concat!("Size of: ", stringify!(_FILE_FULL_EA_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_FULL_EA_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_FULL_EA_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EaNameLength) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(EaNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EaValueLength) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(EaValueLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EaName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(EaName)
        )
    );
}
pub type FILE_FULL_EA_INFORMATION = _FILE_FULL_EA_INFORMATION;
pub type PFILE_FULL_EA_INFORMATION = *mut _FILE_FULL_EA_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MODE_INFORMATION {
    pub Mode: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_MODE_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_MODE_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_MODE_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_MODE_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_MODE_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_MODE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MODE_INFORMATION),
            "::",
            stringify!(Mode)
        )
    );
}
pub type FILE_MODE_INFORMATION = _FILE_MODE_INFORMATION;
pub type PFILE_MODE_INFORMATION = *mut _FILE_MODE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STREAM_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub StreamNameLength: ULONG,
    pub StreamSize: LARGE_INTEGER,
    pub StreamAllocationSize: LARGE_INTEGER,
    pub StreamName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_STREAM_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_STREAM_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_STREAM_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_FILE_STREAM_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_STREAM_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_STREAM_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STREAM_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StreamNameLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STREAM_INFORMATION),
            "::",
            stringify!(StreamNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StreamSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STREAM_INFORMATION),
            "::",
            stringify!(StreamSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StreamAllocationSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STREAM_INFORMATION),
            "::",
            stringify!(StreamAllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StreamName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STREAM_INFORMATION),
            "::",
            stringify!(StreamName)
        )
    );
}
pub type FILE_STREAM_INFORMATION = _FILE_STREAM_INFORMATION;
pub type PFILE_STREAM_INFORMATION = *mut _FILE_STREAM_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ATTRIBUTE_TAG_INFORMATION {
    pub FileAttributes: ULONG,
    pub ReparseTag: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_ATTRIBUTE_TAG_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_ATTRIBUTE_TAG_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_ATTRIBUTE_TAG_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_ATTRIBUTE_TAG_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_ATTRIBUTE_TAG_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_ATTRIBUTE_TAG_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ATTRIBUTE_TAG_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReparseTag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ATTRIBUTE_TAG_INFORMATION),
            "::",
            stringify!(ReparseTag)
        )
    );
}
pub type FILE_ATTRIBUTE_TAG_INFORMATION = _FILE_ATTRIBUTE_TAG_INFORMATION;
pub type PFILE_ATTRIBUTE_TAG_INFORMATION = *mut _FILE_ATTRIBUTE_TAG_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_MAILSLOT_QUERY_INFORMATION {
    pub MaximumMessageSize: ULONG,
    pub MailslotQuota: ULONG,
    pub NextMessageSize: ULONG,
    pub MessagesAvailable: ULONG,
    pub ReadTimeout: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_MAILSLOT_QUERY_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_MAILSLOT_QUERY_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_MAILSLOT_QUERY_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_FILE_MAILSLOT_QUERY_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_MAILSLOT_QUERY_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumMessageSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION),
            "::",
            stringify!(MaximumMessageSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MailslotQuota) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION),
            "::",
            stringify!(MailslotQuota)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NextMessageSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION),
            "::",
            stringify!(NextMessageSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MessagesAvailable) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION),
            "::",
            stringify!(MessagesAvailable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadTimeout) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION),
            "::",
            stringify!(ReadTimeout)
        )
    );
}
pub type FILE_MAILSLOT_QUERY_INFORMATION = _FILE_MAILSLOT_QUERY_INFORMATION;
pub type PFILE_MAILSLOT_QUERY_INFORMATION = *mut _FILE_MAILSLOT_QUERY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_MAILSLOT_SET_INFORMATION {
    pub ReadTimeout: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_MAILSLOT_SET_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_MAILSLOT_SET_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_MAILSLOT_SET_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_MAILSLOT_SET_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_MAILSLOT_SET_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_MAILSLOT_SET_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadTimeout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_SET_INFORMATION),
            "::",
            stringify!(ReadTimeout)
        )
    );
}
pub type FILE_MAILSLOT_SET_INFORMATION = _FILE_MAILSLOT_SET_INFORMATION;
pub type PFILE_MAILSLOT_SET_INFORMATION = *mut _FILE_MAILSLOT_SET_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_LOCAL_INFORMATION {
    pub NamedPipeType: ULONG,
    pub NamedPipeConfiguration: ULONG,
    pub MaximumInstances: ULONG,
    pub CurrentInstances: ULONG,
    pub InboundQuota: ULONG,
    pub ReadDataAvailable: ULONG,
    pub OutboundQuota: ULONG,
    pub WriteQuotaAvailable: ULONG,
    pub NamedPipeState: ULONG,
    pub NamedPipeEnd: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_PIPE_LOCAL_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_PIPE_LOCAL_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_PIPE_LOCAL_INFORMATION>(),
        40usize,
        concat!("Size of: ", stringify!(_FILE_PIPE_LOCAL_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_PIPE_LOCAL_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_PIPE_LOCAL_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NamedPipeType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(NamedPipeType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NamedPipeConfiguration) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(NamedPipeConfiguration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumInstances) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(MaximumInstances)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentInstances) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(CurrentInstances)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InboundQuota) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(InboundQuota)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadDataAvailable) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(ReadDataAvailable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OutboundQuota) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(OutboundQuota)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteQuotaAvailable) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(WriteQuotaAvailable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NamedPipeState) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(NamedPipeState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NamedPipeEnd) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(NamedPipeEnd)
        )
    );
}
pub type FILE_PIPE_LOCAL_INFORMATION = _FILE_PIPE_LOCAL_INFORMATION;
pub type PFILE_PIPE_LOCAL_INFORMATION = *mut _FILE_PIPE_LOCAL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ALL_INFORMATION {
    pub BasicInformation: FILE_BASIC_INFORMATION,
    pub StandardInformation: FILE_STANDARD_INFORMATION,
    pub InternalInformation: FILE_INTERNAL_INFORMATION,
    pub EaInformation: FILE_EA_INFORMATION,
    pub AccessInformation: FILE_ACCESS_INFORMATION,
    pub PositionInformation: FILE_POSITION_INFORMATION,
    pub ModeInformation: FILE_MODE_INFORMATION,
    pub AlignmentInformation: FILE_ALIGNMENT_INFORMATION,
    pub NameInformation: FILE_NAME_INFORMATION,
}
#[test]
fn bindgen_test_layout__FILE_ALL_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_ALL_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_ALL_INFORMATION>(),
        104usize,
        concat!("Size of: ", stringify!(_FILE_ALL_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_ALL_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_ALL_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BasicInformation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(BasicInformation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StandardInformation) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(StandardInformation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InternalInformation) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(InternalInformation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EaInformation) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(EaInformation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccessInformation) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(AccessInformation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PositionInformation) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(PositionInformation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ModeInformation) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(ModeInformation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AlignmentInformation) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(AlignmentInformation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NameInformation) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(NameInformation)
        )
    );
}
pub type FILE_ALL_INFORMATION = _FILE_ALL_INFORMATION;
pub type PFILE_ALL_INFORMATION = *mut _FILE_ALL_INFORMATION;
pub const _FSINFOCLASS_FileFsVolumeInformation: _FSINFOCLASS = 1;
pub const _FSINFOCLASS_FileFsLabelInformation: _FSINFOCLASS = 2;
pub const _FSINFOCLASS_FileFsSizeInformation: _FSINFOCLASS = 3;
pub const _FSINFOCLASS_FileFsDeviceInformation: _FSINFOCLASS = 4;
pub const _FSINFOCLASS_FileFsAttributeInformation: _FSINFOCLASS = 5;
pub const _FSINFOCLASS_FileFsControlInformation: _FSINFOCLASS = 6;
pub const _FSINFOCLASS_FileFsFullSizeInformation: _FSINFOCLASS = 7;
pub const _FSINFOCLASS_FileFsObjectIdInformation: _FSINFOCLASS = 8;
pub const _FSINFOCLASS_FileFsDriverPathInformation: _FSINFOCLASS = 9;
pub const _FSINFOCLASS_FileFsVolumeFlagsInformation: _FSINFOCLASS = 10;
pub const _FSINFOCLASS_FileFsMaximumInformation: _FSINFOCLASS = 11;
pub type _FSINFOCLASS = ::std::os::raw::c_uint;
pub use self::_FSINFOCLASS as FS_INFORMATION_CLASS;
pub type PFS_INFORMATION_CLASS = *mut _FSINFOCLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_VOLUME_INFORMATION {
    pub VolumeCreationTime: LARGE_INTEGER,
    pub VolumeSerialNumber: ULONG,
    pub VolumeLabelLength: ULONG,
    pub SupportsObjects: BOOLEAN,
    pub VolumeLabel: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FS_VOLUME_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_FS_VOLUME_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_FS_VOLUME_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_FILE_FS_VOLUME_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_FS_VOLUME_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_FS_VOLUME_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeCreationTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_VOLUME_INFORMATION),
            "::",
            stringify!(VolumeCreationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeSerialNumber) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_VOLUME_INFORMATION),
            "::",
            stringify!(VolumeSerialNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeLabelLength) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_VOLUME_INFORMATION),
            "::",
            stringify!(VolumeLabelLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SupportsObjects) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_VOLUME_INFORMATION),
            "::",
            stringify!(SupportsObjects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeLabel) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_VOLUME_INFORMATION),
            "::",
            stringify!(VolumeLabel)
        )
    );
}
pub type FILE_FS_VOLUME_INFORMATION = _FILE_FS_VOLUME_INFORMATION;
pub type PFILE_FS_VOLUME_INFORMATION = *mut _FILE_FS_VOLUME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_LABEL_INFORMATION {
    pub VolumeLabelLength: ULONG,
    pub VolumeLabel: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FS_LABEL_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_FS_LABEL_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_FS_LABEL_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_FS_LABEL_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_FS_LABEL_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_FS_LABEL_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeLabelLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_LABEL_INFORMATION),
            "::",
            stringify!(VolumeLabelLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeLabel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_LABEL_INFORMATION),
            "::",
            stringify!(VolumeLabel)
        )
    );
}
pub type FILE_FS_LABEL_INFORMATION = _FILE_FS_LABEL_INFORMATION;
pub type PFILE_FS_LABEL_INFORMATION = *mut _FILE_FS_LABEL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_SIZE_INFORMATION {
    pub TotalAllocationUnits: LARGE_INTEGER,
    pub AvailableAllocationUnits: LARGE_INTEGER,
    pub SectorsPerAllocationUnit: ULONG,
    pub BytesPerSector: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_FS_SIZE_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_FS_SIZE_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_FS_SIZE_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_FILE_FS_SIZE_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_FS_SIZE_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_FS_SIZE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalAllocationUnits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_SIZE_INFORMATION),
            "::",
            stringify!(TotalAllocationUnits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AvailableAllocationUnits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_SIZE_INFORMATION),
            "::",
            stringify!(AvailableAllocationUnits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SectorsPerAllocationUnit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_SIZE_INFORMATION),
            "::",
            stringify!(SectorsPerAllocationUnit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BytesPerSector) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_SIZE_INFORMATION),
            "::",
            stringify!(BytesPerSector)
        )
    );
}
pub type FILE_FS_SIZE_INFORMATION = _FILE_FS_SIZE_INFORMATION;
pub type PFILE_FS_SIZE_INFORMATION = *mut _FILE_FS_SIZE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_DEVICE_INFORMATION {
    pub DeviceType: ULONG,
    pub Characteristics: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_FS_DEVICE_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_FS_DEVICE_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_FS_DEVICE_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_FS_DEVICE_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_FS_DEVICE_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_FS_DEVICE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeviceType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_DEVICE_INFORMATION),
            "::",
            stringify!(DeviceType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Characteristics) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_DEVICE_INFORMATION),
            "::",
            stringify!(Characteristics)
        )
    );
}
pub type FILE_FS_DEVICE_INFORMATION = _FILE_FS_DEVICE_INFORMATION;
pub type PFILE_FS_DEVICE_INFORMATION = *mut _FILE_FS_DEVICE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_ATTRIBUTE_INFORMATION {
    pub FileSystemAttributes: ULONG,
    pub MaximumComponentNameLength: ULONG,
    pub FileSystemNameLength: ULONG,
    pub FileSystemName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FS_ATTRIBUTE_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_FS_ATTRIBUTE_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_FS_ATTRIBUTE_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_FS_ATTRIBUTE_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_FS_ATTRIBUTE_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_FS_ATTRIBUTE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileSystemAttributes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_ATTRIBUTE_INFORMATION),
            "::",
            stringify!(FileSystemAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumComponentNameLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_ATTRIBUTE_INFORMATION),
            "::",
            stringify!(MaximumComponentNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileSystemNameLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_ATTRIBUTE_INFORMATION),
            "::",
            stringify!(FileSystemNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileSystemName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_ATTRIBUTE_INFORMATION),
            "::",
            stringify!(FileSystemName)
        )
    );
}
pub type FILE_FS_ATTRIBUTE_INFORMATION = _FILE_FS_ATTRIBUTE_INFORMATION;
pub type PFILE_FS_ATTRIBUTE_INFORMATION = *mut _FILE_FS_ATTRIBUTE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_FULL_SIZE_INFORMATION {
    pub TotalAllocationUnits: LARGE_INTEGER,
    pub CallerAvailableAllocationUnits: LARGE_INTEGER,
    pub ActualAvailableAllocationUnits: LARGE_INTEGER,
    pub SectorsPerAllocationUnit: ULONG,
    pub BytesPerSector: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_FS_FULL_SIZE_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_FS_FULL_SIZE_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_FS_FULL_SIZE_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_FILE_FS_FULL_SIZE_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_FS_FULL_SIZE_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_FS_FULL_SIZE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalAllocationUnits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_FULL_SIZE_INFORMATION),
            "::",
            stringify!(TotalAllocationUnits)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CallerAvailableAllocationUnits) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_FULL_SIZE_INFORMATION),
            "::",
            stringify!(CallerAvailableAllocationUnits)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ActualAvailableAllocationUnits) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_FULL_SIZE_INFORMATION),
            "::",
            stringify!(ActualAvailableAllocationUnits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SectorsPerAllocationUnit) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_FULL_SIZE_INFORMATION),
            "::",
            stringify!(SectorsPerAllocationUnit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BytesPerSector) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_FULL_SIZE_INFORMATION),
            "::",
            stringify!(BytesPerSector)
        )
    );
}
pub type FILE_FS_FULL_SIZE_INFORMATION = _FILE_FS_FULL_SIZE_INFORMATION;
pub type PFILE_FS_FULL_SIZE_INFORMATION = *mut _FILE_FS_FULL_SIZE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_OBJECTID_INFORMATION {
    pub ObjectId: [UCHAR; 16usize],
    pub ExtendedInfo: [UCHAR; 48usize],
}
#[test]
fn bindgen_test_layout__FILE_FS_OBJECTID_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_FS_OBJECTID_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_FS_OBJECTID_INFORMATION>(),
        64usize,
        concat!("Size of: ", stringify!(_FILE_FS_OBJECTID_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_FS_OBJECTID_INFORMATION>(),
        1usize,
        concat!("Alignment of ", stringify!(_FILE_FS_OBJECTID_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_OBJECTID_INFORMATION),
            "::",
            stringify!(ObjectId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExtendedInfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_OBJECTID_INFORMATION),
            "::",
            stringify!(ExtendedInfo)
        )
    );
}
pub type FILE_FS_OBJECTID_INFORMATION = _FILE_FS_OBJECTID_INFORMATION;
pub type PFILE_FS_OBJECTID_INFORMATION = *mut _FILE_FS_OBJECTID_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STATUS_BLOCK {
    pub __bindgen_anon_1: _IO_STATUS_BLOCK__bindgen_ty_1,
    pub Information: ULONG_PTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STATUS_BLOCK__bindgen_ty_1 {
    pub Status: NTSTATUS,
    pub Pointer: PVOID,
}
#[test]
fn bindgen_test_layout__IO_STATUS_BLOCK__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_STATUS_BLOCK__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_STATUS_BLOCK__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IO_STATUS_BLOCK__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_STATUS_BLOCK__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_STATUS_BLOCK__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK__bindgen_ty_1),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK__bindgen_ty_1),
            "::",
            stringify!(Pointer)
        )
    );
}
#[test]
fn bindgen_test_layout__IO_STATUS_BLOCK() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_STATUS_BLOCK> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_STATUS_BLOCK>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STATUS_BLOCK))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_STATUS_BLOCK>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_STATUS_BLOCK))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Information) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK),
            "::",
            stringify!(Information)
        )
    );
}
pub type IO_STATUS_BLOCK = _IO_STATUS_BLOCK;
pub type PIO_STATUS_BLOCK = *mut _IO_STATUS_BLOCK;
pub type PIO_APC_ROUTINE = ::std::option::Option<
    unsafe extern "C" fn(ApcContext: PVOID, IoStatusBlock: PIO_STATUS_BLOCK, Reserved: ULONG),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VM_COUNTERS {
    pub PeakVirtualSize: SIZE_T,
    pub VirtualSize: SIZE_T,
    pub PageFaultCount: ULONG,
    pub PeakWorkingSetSize: SIZE_T,
    pub WorkingSetSize: SIZE_T,
    pub QuotaPeakPagedPoolUsage: SIZE_T,
    pub QuotaPagedPoolUsage: SIZE_T,
    pub QuotaPeakNonPagedPoolUsage: SIZE_T,
    pub QuotaNonPagedPoolUsage: SIZE_T,
    pub PagefileUsage: SIZE_T,
    pub PeakPagefileUsage: SIZE_T,
}
#[test]
fn bindgen_test_layout__VM_COUNTERS() {
    const UNINIT: ::std::mem::MaybeUninit<_VM_COUNTERS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_VM_COUNTERS>(),
        88usize,
        concat!("Size of: ", stringify!(_VM_COUNTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_VM_COUNTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(_VM_COUNTERS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PeakVirtualSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_VM_COUNTERS),
            "::",
            stringify!(PeakVirtualSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VirtualSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_VM_COUNTERS),
            "::",
            stringify!(VirtualSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PageFaultCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_VM_COUNTERS),
            "::",
            stringify!(PageFaultCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PeakWorkingSetSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_VM_COUNTERS),
            "::",
            stringify!(PeakWorkingSetSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WorkingSetSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_VM_COUNTERS),
            "::",
            stringify!(WorkingSetSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QuotaPeakPagedPoolUsage) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_VM_COUNTERS),
            "::",
            stringify!(QuotaPeakPagedPoolUsage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QuotaPagedPoolUsage) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_VM_COUNTERS),
            "::",
            stringify!(QuotaPagedPoolUsage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QuotaPeakNonPagedPoolUsage) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_VM_COUNTERS),
            "::",
            stringify!(QuotaPeakNonPagedPoolUsage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QuotaNonPagedPoolUsage) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_VM_COUNTERS),
            "::",
            stringify!(QuotaNonPagedPoolUsage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PagefileUsage) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_VM_COUNTERS),
            "::",
            stringify!(PagefileUsage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PeakPagefileUsage) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_VM_COUNTERS),
            "::",
            stringify!(PeakPagefileUsage)
        )
    );
}
pub type VM_COUNTERS = _VM_COUNTERS;
pub type PVM_COUNTERS = *mut _VM_COUNTERS;
pub const _THREAD_STATE_StateInitialized: _THREAD_STATE = 0;
pub const _THREAD_STATE_StateReady: _THREAD_STATE = 1;
pub const _THREAD_STATE_StateRunning: _THREAD_STATE = 2;
pub const _THREAD_STATE_StateStandby: _THREAD_STATE = 3;
pub const _THREAD_STATE_StateTerminated: _THREAD_STATE = 4;
pub const _THREAD_STATE_StateWait: _THREAD_STATE = 5;
pub const _THREAD_STATE_StateTransition: _THREAD_STATE = 6;
pub const _THREAD_STATE_StateUnknown: _THREAD_STATE = 7;
pub type _THREAD_STATE = ::std::os::raw::c_uint;
pub use self::_THREAD_STATE as THREAD_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLIENT_ID {
    pub UniqueProcess: HANDLE,
    pub UniqueThread: HANDLE,
}
#[test]
fn bindgen_test_layout__CLIENT_ID() {
    const UNINIT: ::std::mem::MaybeUninit<_CLIENT_ID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CLIENT_ID>(),
        16usize,
        concat!("Size of: ", stringify!(_CLIENT_ID))
    );
    assert_eq!(
        ::std::mem::align_of::<_CLIENT_ID>(),
        8usize,
        concat!("Alignment of ", stringify!(_CLIENT_ID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UniqueProcess) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLIENT_ID),
            "::",
            stringify!(UniqueProcess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UniqueThread) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLIENT_ID),
            "::",
            stringify!(UniqueThread)
        )
    );
}
pub type CLIENT_ID = _CLIENT_ID;
pub type PCLIENT_ID = *mut _CLIENT_ID;
pub type KPRIORITY = LONG;
pub const _KWAIT_REASON_Executive: _KWAIT_REASON = 0;
pub const _KWAIT_REASON_FreePage: _KWAIT_REASON = 1;
pub const _KWAIT_REASON_PageIn: _KWAIT_REASON = 2;
pub const _KWAIT_REASON_PoolAllocation: _KWAIT_REASON = 3;
pub const _KWAIT_REASON_DelayExecution: _KWAIT_REASON = 4;
pub const _KWAIT_REASON_Suspended: _KWAIT_REASON = 5;
pub const _KWAIT_REASON_UserRequest: _KWAIT_REASON = 6;
pub const _KWAIT_REASON_WrExecutive: _KWAIT_REASON = 7;
pub const _KWAIT_REASON_WrFreePage: _KWAIT_REASON = 8;
pub const _KWAIT_REASON_WrPageIn: _KWAIT_REASON = 9;
pub const _KWAIT_REASON_WrPoolAllocation: _KWAIT_REASON = 10;
pub const _KWAIT_REASON_WrDelayExecution: _KWAIT_REASON = 11;
pub const _KWAIT_REASON_WrSuspended: _KWAIT_REASON = 12;
pub const _KWAIT_REASON_WrUserRequest: _KWAIT_REASON = 13;
pub const _KWAIT_REASON_WrEventPair: _KWAIT_REASON = 14;
pub const _KWAIT_REASON_WrQueue: _KWAIT_REASON = 15;
pub const _KWAIT_REASON_WrLpcReceive: _KWAIT_REASON = 16;
pub const _KWAIT_REASON_WrLpcReply: _KWAIT_REASON = 17;
pub const _KWAIT_REASON_WrVirtualMemory: _KWAIT_REASON = 18;
pub const _KWAIT_REASON_WrPageOut: _KWAIT_REASON = 19;
pub const _KWAIT_REASON_WrRendezvous: _KWAIT_REASON = 20;
pub const _KWAIT_REASON_Spare2: _KWAIT_REASON = 21;
pub const _KWAIT_REASON_Spare3: _KWAIT_REASON = 22;
pub const _KWAIT_REASON_Spare4: _KWAIT_REASON = 23;
pub const _KWAIT_REASON_Spare5: _KWAIT_REASON = 24;
pub const _KWAIT_REASON_Spare6: _KWAIT_REASON = 25;
pub const _KWAIT_REASON_WrKernel: _KWAIT_REASON = 26;
pub const _KWAIT_REASON_MaximumWaitReason: _KWAIT_REASON = 27;
pub type _KWAIT_REASON = ::std::os::raw::c_uint;
pub use self::_KWAIT_REASON as KWAIT_REASON;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_THREADS {
    pub KernelTime: LARGE_INTEGER,
    pub UserTime: LARGE_INTEGER,
    pub CreateTime: LARGE_INTEGER,
    pub WaitTime: ULONG,
    pub StartAddress: PVOID,
    pub ClientId: CLIENT_ID,
    pub Priority: KPRIORITY,
    pub BasePriority: KPRIORITY,
    pub ContextSwitchCount: ULONG,
    pub State: THREAD_STATE,
    pub WaitReason: KWAIT_REASON,
}
#[test]
fn bindgen_test_layout__SYSTEM_THREADS() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_THREADS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_THREADS>(),
        80usize,
        concat!("Size of: ", stringify!(_SYSTEM_THREADS))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_THREADS>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYSTEM_THREADS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_THREADS),
            "::",
            stringify!(KernelTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_THREADS),
            "::",
            stringify!(UserTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_THREADS),
            "::",
            stringify!(CreateTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WaitTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_THREADS),
            "::",
            stringify!(WaitTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StartAddress) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_THREADS),
            "::",
            stringify!(StartAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientId) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_THREADS),
            "::",
            stringify!(ClientId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Priority) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_THREADS),
            "::",
            stringify!(Priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BasePriority) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_THREADS),
            "::",
            stringify!(BasePriority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ContextSwitchCount) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_THREADS),
            "::",
            stringify!(ContextSwitchCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_THREADS),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WaitReason) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_THREADS),
            "::",
            stringify!(WaitReason)
        )
    );
}
pub type SYSTEM_THREADS = _SYSTEM_THREADS;
pub type PSYSTEM_THREADS = *mut _SYSTEM_THREADS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_BASIC_INFORMATION {
    pub ExitStatus: NTSTATUS,
    pub PebBaseAddress: PPEB,
    pub AffinityMask: KAFFINITY,
    pub BasePriority: KPRIORITY,
    pub UniqueProcessId: ULONG_PTR,
    pub InheritedFromUniqueProcessId: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__PROCESS_BASIC_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_PROCESS_BASIC_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_BASIC_INFORMATION>(),
        48usize,
        concat!("Size of: ", stringify!(_PROCESS_BASIC_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_BASIC_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_PROCESS_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExitStatus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_BASIC_INFORMATION),
            "::",
            stringify!(ExitStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PebBaseAddress) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_BASIC_INFORMATION),
            "::",
            stringify!(PebBaseAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AffinityMask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_BASIC_INFORMATION),
            "::",
            stringify!(AffinityMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BasePriority) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_BASIC_INFORMATION),
            "::",
            stringify!(BasePriority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UniqueProcessId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_BASIC_INFORMATION),
            "::",
            stringify!(UniqueProcessId)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).InheritedFromUniqueProcessId) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_BASIC_INFORMATION),
            "::",
            stringify!(InheritedFromUniqueProcessId)
        )
    );
}
pub type PROCESS_BASIC_INFORMATION = _PROCESS_BASIC_INFORMATION;
pub type PPROCESS_BASIC_INFORMATION = *mut _PROCESS_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KERNEL_USER_TIMES {
    pub CreateTime: FILETIME,
    pub ExitTime: FILETIME,
    pub KernelTime: LARGE_INTEGER,
    pub UserTime: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__KERNEL_USER_TIMES() {
    const UNINIT: ::std::mem::MaybeUninit<_KERNEL_USER_TIMES> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_KERNEL_USER_TIMES>(),
        32usize,
        concat!("Size of: ", stringify!(_KERNEL_USER_TIMES))
    );
    assert_eq!(
        ::std::mem::align_of::<_KERNEL_USER_TIMES>(),
        8usize,
        concat!("Alignment of ", stringify!(_KERNEL_USER_TIMES))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KERNEL_USER_TIMES),
            "::",
            stringify!(CreateTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExitTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KERNEL_USER_TIMES),
            "::",
            stringify!(ExitTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KERNEL_USER_TIMES),
            "::",
            stringify!(KernelTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KERNEL_USER_TIMES),
            "::",
            stringify!(UserTime)
        )
    );
}
pub type KERNEL_USER_TIMES = _KERNEL_USER_TIMES;
pub type PKERNEL_USER_TIMES = *mut _KERNEL_USER_TIMES;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
    pub IdleTime: LARGE_INTEGER,
    pub KernelTime: LARGE_INTEGER,
    pub UserTime: LARGE_INTEGER,
    pub Reserved1: [LARGE_INTEGER; 2usize],
    pub Reserved2: ULONG,
}
#[test]
fn bindgen_test_layout__SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IdleTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION),
            "::",
            stringify!(IdleTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION),
            "::",
            stringify!(KernelTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION),
            "::",
            stringify!(UserTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION),
            "::",
            stringify!(Reserved2)
        )
    );
}
pub type SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION = _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;
pub type PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION = *mut _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_PROCESS_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub NumberOfThreads: ULONG,
    pub Reserved: [LARGE_INTEGER; 3usize],
    pub CreateTime: LARGE_INTEGER,
    pub UserTime: LARGE_INTEGER,
    pub KernelTime: LARGE_INTEGER,
    pub ImageName: UNICODE_STRING,
    pub BasePriority: KPRIORITY,
    pub UniqueProcessId: HANDLE,
    pub InheritedFromUniqueProcessId: HANDLE,
    pub HandleCount: ULONG,
    pub SessionId: ULONG,
    pub PageDirectoryBase: ULONG,
    pub VirtualMemoryCounters: VM_COUNTERS,
    pub PrivatePageCount: SIZE_T,
    pub IoCounters: IO_COUNTERS,
}
#[test]
fn bindgen_test_layout__SYSTEM_PROCESS_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_PROCESS_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_PROCESS_INFORMATION>(),
        256usize,
        concat!("Size of: ", stringify!(_SYSTEM_PROCESS_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_PROCESS_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYSTEM_PROCESS_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfThreads) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_INFORMATION),
            "::",
            stringify!(NumberOfThreads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_INFORMATION),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_INFORMATION),
            "::",
            stringify!(CreateTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserTime) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_INFORMATION),
            "::",
            stringify!(UserTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).KernelTime) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_INFORMATION),
            "::",
            stringify!(KernelTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ImageName) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_INFORMATION),
            "::",
            stringify!(ImageName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BasePriority) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_INFORMATION),
            "::",
            stringify!(BasePriority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UniqueProcessId) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_INFORMATION),
            "::",
            stringify!(UniqueProcessId)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).InheritedFromUniqueProcessId) as usize - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_INFORMATION),
            "::",
            stringify!(InheritedFromUniqueProcessId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HandleCount) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_INFORMATION),
            "::",
            stringify!(HandleCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SessionId) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_INFORMATION),
            "::",
            stringify!(SessionId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PageDirectoryBase) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_INFORMATION),
            "::",
            stringify!(PageDirectoryBase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VirtualMemoryCounters) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_INFORMATION),
            "::",
            stringify!(VirtualMemoryCounters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrivatePageCount) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_INFORMATION),
            "::",
            stringify!(PrivatePageCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoCounters) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_INFORMATION),
            "::",
            stringify!(IoCounters)
        )
    );
}
pub type SYSTEM_PROCESS_INFORMATION = _SYSTEM_PROCESS_INFORMATION;
pub type PSYSTEM_PROCESS_INFORMATION = *mut _SYSTEM_PROCESS_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_THREAD_INFORMATION {
    pub Reserved1: [LARGE_INTEGER; 3usize],
    pub Reserved2: ULONG,
    pub StartAddress: PVOID,
    pub ClientId: CLIENT_ID,
    pub Priority: KPRIORITY,
    pub BasePriority: LONG,
    pub Reserved3: ULONG,
    pub ThreadState: ULONG,
    pub WaitReason: ULONG,
}
#[test]
fn bindgen_test_layout__SYSTEM_THREAD_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_THREAD_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_THREAD_INFORMATION>(),
        80usize,
        concat!("Size of: ", stringify!(_SYSTEM_THREAD_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_THREAD_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYSTEM_THREAD_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_THREAD_INFORMATION),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_THREAD_INFORMATION),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StartAddress) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_THREAD_INFORMATION),
            "::",
            stringify!(StartAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClientId) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_THREAD_INFORMATION),
            "::",
            stringify!(ClientId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Priority) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_THREAD_INFORMATION),
            "::",
            stringify!(Priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BasePriority) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_THREAD_INFORMATION),
            "::",
            stringify!(BasePriority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_THREAD_INFORMATION),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ThreadState) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_THREAD_INFORMATION),
            "::",
            stringify!(ThreadState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WaitReason) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_THREAD_INFORMATION),
            "::",
            stringify!(WaitReason)
        )
    );
}
pub type SYSTEM_THREAD_INFORMATION = _SYSTEM_THREAD_INFORMATION;
pub type PSYSTEM_THREAD_INFORMATION = *mut _SYSTEM_THREAD_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_REGISTRY_QUOTA_INFORMATION {
    pub RegistryQuotaAllowed: ULONG,
    pub RegistryQuotaUsed: ULONG,
    pub Reserved1: PVOID,
}
#[test]
fn bindgen_test_layout__SYSTEM_REGISTRY_QUOTA_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_REGISTRY_QUOTA_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_REGISTRY_QUOTA_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_SYSTEM_REGISTRY_QUOTA_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_REGISTRY_QUOTA_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_REGISTRY_QUOTA_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RegistryQuotaAllowed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_REGISTRY_QUOTA_INFORMATION),
            "::",
            stringify!(RegistryQuotaAllowed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RegistryQuotaUsed) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_REGISTRY_QUOTA_INFORMATION),
            "::",
            stringify!(RegistryQuotaUsed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_REGISTRY_QUOTA_INFORMATION),
            "::",
            stringify!(Reserved1)
        )
    );
}
pub type SYSTEM_REGISTRY_QUOTA_INFORMATION = _SYSTEM_REGISTRY_QUOTA_INFORMATION;
pub type PSYSTEM_REGISTRY_QUOTA_INFORMATION = *mut _SYSTEM_REGISTRY_QUOTA_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_BASIC_INFORMATION {
    pub Reserved1: [BYTE; 4usize],
    pub MaximumIncrement: ULONG,
    pub PhysicalPageSize: ULONG,
    pub NumberOfPhysicalPages: ULONG,
    pub LowestPhysicalPage: ULONG,
    pub HighestPhysicalPage: ULONG,
    pub AllocationGranularity: ULONG,
    pub LowestUserAddress: ULONG_PTR,
    pub HighestUserAddress: ULONG_PTR,
    pub ActiveProcessors: ULONG_PTR,
    pub NumberOfProcessors: CCHAR,
}
#[test]
fn bindgen_test_layout__SYSTEM_BASIC_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_BASIC_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_BASIC_INFORMATION>(),
        64usize,
        concat!("Size of: ", stringify!(_SYSTEM_BASIC_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_BASIC_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYSTEM_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_BASIC_INFORMATION),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumIncrement) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_BASIC_INFORMATION),
            "::",
            stringify!(MaximumIncrement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PhysicalPageSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_BASIC_INFORMATION),
            "::",
            stringify!(PhysicalPageSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfPhysicalPages) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_BASIC_INFORMATION),
            "::",
            stringify!(NumberOfPhysicalPages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LowestPhysicalPage) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_BASIC_INFORMATION),
            "::",
            stringify!(LowestPhysicalPage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighestPhysicalPage) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_BASIC_INFORMATION),
            "::",
            stringify!(HighestPhysicalPage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocationGranularity) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_BASIC_INFORMATION),
            "::",
            stringify!(AllocationGranularity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LowestUserAddress) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_BASIC_INFORMATION),
            "::",
            stringify!(LowestUserAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighestUserAddress) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_BASIC_INFORMATION),
            "::",
            stringify!(HighestUserAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ActiveProcessors) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_BASIC_INFORMATION),
            "::",
            stringify!(ActiveProcessors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumberOfProcessors) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_BASIC_INFORMATION),
            "::",
            stringify!(NumberOfProcessors)
        )
    );
}
pub type SYSTEM_BASIC_INFORMATION = _SYSTEM_BASIC_INFORMATION;
pub type PSYSTEM_BASIC_INFORMATION = *mut _SYSTEM_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_INFORMATION {
    pub ProcessorArchitecture: USHORT,
    pub ProcessorLevel: USHORT,
    pub ProcessorRevision: USHORT,
    pub Unknown: USHORT,
    pub FeatureBits: ULONG,
}
#[test]
fn bindgen_test_layout__SYSTEM_PROCESSOR_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_PROCESSOR_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_PROCESSOR_INFORMATION>(),
        12usize,
        concat!("Size of: ", stringify!(_SYSTEM_PROCESSOR_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_PROCESSOR_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_PROCESSOR_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProcessorArchitecture) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESSOR_INFORMATION),
            "::",
            stringify!(ProcessorArchitecture)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProcessorLevel) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESSOR_INFORMATION),
            "::",
            stringify!(ProcessorLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProcessorRevision) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESSOR_INFORMATION),
            "::",
            stringify!(ProcessorRevision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Unknown) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESSOR_INFORMATION),
            "::",
            stringify!(Unknown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FeatureBits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESSOR_INFORMATION),
            "::",
            stringify!(FeatureBits)
        )
    );
}
pub type SYSTEM_PROCESSOR_INFORMATION = _SYSTEM_PROCESSOR_INFORMATION;
pub type PSYSTEM_PROCESSOR_INFORMATION = *mut _SYSTEM_PROCESSOR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_TIMEOFDAY_INFORMATION {
    pub BootTime: LARGE_INTEGER,
    pub CurrentTime: LARGE_INTEGER,
    pub TimeZoneBias: LARGE_INTEGER,
    pub CurrentTimeZoneId: ULONG,
    pub Reserved1: [BYTE; 20usize],
}
#[test]
fn bindgen_test_layout__SYSTEM_TIMEOFDAY_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_TIMEOFDAY_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_TIMEOFDAY_INFORMATION>(),
        48usize,
        concat!("Size of: ", stringify!(_SYSTEM_TIMEOFDAY_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_TIMEOFDAY_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYSTEM_TIMEOFDAY_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BootTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_TIMEOFDAY_INFORMATION),
            "::",
            stringify!(BootTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_TIMEOFDAY_INFORMATION),
            "::",
            stringify!(CurrentTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeZoneBias) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_TIMEOFDAY_INFORMATION),
            "::",
            stringify!(TimeZoneBias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentTimeZoneId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_TIMEOFDAY_INFORMATION),
            "::",
            stringify!(CurrentTimeZoneId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_TIMEOFDAY_INFORMATION),
            "::",
            stringify!(Reserved1)
        )
    );
}
pub type SYSTEM_TIMEOFDAY_INFORMATION = _SYSTEM_TIMEOFDAY_INFORMATION;
pub type PSYSTEM_TIMEOFDAY_INFORMATION = *mut _SYSTEM_TIMEOFDAY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_PERFORMANCE_INFORMATION {
    pub IdleTime: LARGE_INTEGER,
    pub ReadTransferCount: LARGE_INTEGER,
    pub WriteTransferCount: LARGE_INTEGER,
    pub OtherTransferCount: LARGE_INTEGER,
    pub ReadOperationCount: ULONG,
    pub WriteOperationCount: ULONG,
    pub OtherOperationCount: ULONG,
    pub AvailablePages: ULONG,
    pub TotalCommittedPages: ULONG,
    pub TotalCommitLimit: ULONG,
    pub PeakCommitment: ULONG,
    pub PageFaults: ULONG,
    pub WriteCopyFaults: ULONG,
    pub TransitionFaults: ULONG,
    pub CacheTransitionFaults: ULONG,
    pub DemandZeroFaults: ULONG,
    pub PagesRead: ULONG,
    pub PageReadIos: ULONG,
    pub CacheReads: ULONG,
    pub CacheIos: ULONG,
    pub PagefilePagesWritten: ULONG,
    pub PagefilePageWriteIos: ULONG,
    pub MappedFilePagesWritten: ULONG,
    pub MappedFilePageWriteIos: ULONG,
    pub PagedPoolUsage: ULONG,
    pub NonPagedPoolUsage: ULONG,
    pub PagedPoolAllocs: ULONG,
    pub PagedPoolFrees: ULONG,
    pub NonPagedPoolAllocs: ULONG,
    pub NonPagedPoolFrees: ULONG,
    pub TotalFreeSystemPtes: ULONG,
    pub SystemCodePage: ULONG,
    pub TotalSystemDriverPages: ULONG,
    pub TotalSystemCodePages: ULONG,
    pub SmallNonPagedLookasideListAllocateHits: ULONG,
    pub SmallPagedLookasideListAllocateHits: ULONG,
    pub Reserved3: ULONG,
    pub MmSystemCachePage: ULONG,
    pub PagedPoolPage: ULONG,
    pub SystemDriverPage: ULONG,
    pub FastReadNoWait: ULONG,
    pub FastReadWait: ULONG,
    pub FastReadResourceMiss: ULONG,
    pub FastReadNotPossible: ULONG,
    pub FastMdlReadNoWait: ULONG,
    pub FastMdlReadWait: ULONG,
    pub FastMdlReadResourceMiss: ULONG,
    pub FastMdlReadNotPossible: ULONG,
    pub MapDataNoWait: ULONG,
    pub MapDataWait: ULONG,
    pub MapDataNoWaitMiss: ULONG,
    pub MapDataWaitMiss: ULONG,
    pub PinMappedDataCount: ULONG,
    pub PinReadNoWait: ULONG,
    pub PinReadWait: ULONG,
    pub PinReadNoWaitMiss: ULONG,
    pub PinReadWaitMiss: ULONG,
    pub CopyReadNoWait: ULONG,
    pub CopyReadWait: ULONG,
    pub CopyReadNoWaitMiss: ULONG,
    pub CopyReadWaitMiss: ULONG,
    pub MdlReadNoWait: ULONG,
    pub MdlReadWait: ULONG,
    pub MdlReadNoWaitMiss: ULONG,
    pub MdlReadWaitMiss: ULONG,
    pub ReadAheadIos: ULONG,
    pub LazyWriteIos: ULONG,
    pub LazyWritePages: ULONG,
    pub DataFlushes: ULONG,
    pub DataPages: ULONG,
    pub ContextSwitches: ULONG,
    pub FirstLevelTbFills: ULONG,
    pub SecondLevelTbFills: ULONG,
    pub SystemCalls: ULONG,
}
#[test]
fn bindgen_test_layout__SYSTEM_PERFORMANCE_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_PERFORMANCE_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_PERFORMANCE_INFORMATION>(),
        312usize,
        concat!("Size of: ", stringify!(_SYSTEM_PERFORMANCE_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_PERFORMANCE_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYSTEM_PERFORMANCE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IdleTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(IdleTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadTransferCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(ReadTransferCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteTransferCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(WriteTransferCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OtherTransferCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(OtherTransferCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadOperationCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(ReadOperationCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteOperationCount) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(WriteOperationCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OtherOperationCount) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(OtherOperationCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AvailablePages) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(AvailablePages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalCommittedPages) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(TotalCommittedPages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalCommitLimit) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(TotalCommitLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PeakCommitment) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(PeakCommitment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PageFaults) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(PageFaults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteCopyFaults) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(WriteCopyFaults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TransitionFaults) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(TransitionFaults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CacheTransitionFaults) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(CacheTransitionFaults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DemandZeroFaults) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(DemandZeroFaults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PagesRead) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(PagesRead)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PageReadIos) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(PageReadIos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CacheReads) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(CacheReads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CacheIos) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(CacheIos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PagefilePagesWritten) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(PagefilePagesWritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PagefilePageWriteIos) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(PagefilePageWriteIos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MappedFilePagesWritten) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(MappedFilePagesWritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MappedFilePageWriteIos) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(MappedFilePageWriteIos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PagedPoolUsage) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(PagedPoolUsage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NonPagedPoolUsage) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(NonPagedPoolUsage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PagedPoolAllocs) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(PagedPoolAllocs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PagedPoolFrees) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(PagedPoolFrees)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NonPagedPoolAllocs) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(NonPagedPoolAllocs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NonPagedPoolFrees) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(NonPagedPoolFrees)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalFreeSystemPtes) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(TotalFreeSystemPtes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SystemCodePage) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(SystemCodePage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalSystemDriverPages) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(TotalSystemDriverPages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalSystemCodePages) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(TotalSystemCodePages)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SmallNonPagedLookasideListAllocateHits) as usize
                - ptr as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(SmallNonPagedLookasideListAllocateHits)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).SmallPagedLookasideListAllocateHits) as usize - ptr as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(SmallPagedLookasideListAllocateHits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MmSystemCachePage) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(MmSystemCachePage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PagedPoolPage) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(PagedPoolPage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SystemDriverPage) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(SystemDriverPage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FastReadNoWait) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(FastReadNoWait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FastReadWait) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(FastReadWait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FastReadResourceMiss) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(FastReadResourceMiss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FastReadNotPossible) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(FastReadNotPossible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FastMdlReadNoWait) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(FastMdlReadNoWait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FastMdlReadWait) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(FastMdlReadWait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FastMdlReadResourceMiss) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(FastMdlReadResourceMiss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FastMdlReadNotPossible) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(FastMdlReadNotPossible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MapDataNoWait) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(MapDataNoWait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MapDataWait) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(MapDataWait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MapDataNoWaitMiss) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(MapDataNoWaitMiss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MapDataWaitMiss) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(MapDataWaitMiss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PinMappedDataCount) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(PinMappedDataCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PinReadNoWait) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(PinReadNoWait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PinReadWait) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(PinReadWait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PinReadNoWaitMiss) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(PinReadNoWaitMiss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PinReadWaitMiss) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(PinReadWaitMiss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CopyReadNoWait) as usize - ptr as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(CopyReadNoWait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CopyReadWait) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(CopyReadWait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CopyReadNoWaitMiss) as usize - ptr as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(CopyReadNoWaitMiss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CopyReadWaitMiss) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(CopyReadWaitMiss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MdlReadNoWait) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(MdlReadNoWait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MdlReadWait) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(MdlReadWait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MdlReadNoWaitMiss) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(MdlReadNoWaitMiss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MdlReadWaitMiss) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(MdlReadWaitMiss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadAheadIos) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(ReadAheadIos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LazyWriteIos) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(LazyWriteIos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LazyWritePages) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(LazyWritePages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataFlushes) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(DataFlushes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataPages) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(DataPages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ContextSwitches) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(ContextSwitches)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FirstLevelTbFills) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(FirstLevelTbFills)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SecondLevelTbFills) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(SecondLevelTbFills)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SystemCalls) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PERFORMANCE_INFORMATION),
            "::",
            stringify!(SystemCalls)
        )
    );
}
pub type SYSTEM_PERFORMANCE_INFORMATION = _SYSTEM_PERFORMANCE_INFORMATION;
pub type PSYSTEM_PERFORMANCE_INFORMATION = *mut _SYSTEM_PERFORMANCE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_EXCEPTION_INFORMATION {
    pub Reserved1: [BYTE; 16usize],
}
#[test]
fn bindgen_test_layout__SYSTEM_EXCEPTION_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_EXCEPTION_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_EXCEPTION_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_SYSTEM_EXCEPTION_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_EXCEPTION_INFORMATION>(),
        1usize,
        concat!("Alignment of ", stringify!(_SYSTEM_EXCEPTION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_EXCEPTION_INFORMATION),
            "::",
            stringify!(Reserved1)
        )
    );
}
pub type SYSTEM_EXCEPTION_INFORMATION = _SYSTEM_EXCEPTION_INFORMATION;
pub type PSYSTEM_EXCEPTION_INFORMATION = *mut _SYSTEM_EXCEPTION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_LOOKASIDE_INFORMATION {
    pub Reserved1: [BYTE; 32usize],
}
#[test]
fn bindgen_test_layout__SYSTEM_LOOKASIDE_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_LOOKASIDE_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_LOOKASIDE_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_SYSTEM_LOOKASIDE_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_LOOKASIDE_INFORMATION>(),
        1usize,
        concat!("Alignment of ", stringify!(_SYSTEM_LOOKASIDE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOOKASIDE_INFORMATION),
            "::",
            stringify!(Reserved1)
        )
    );
}
pub type SYSTEM_LOOKASIDE_INFORMATION = _SYSTEM_LOOKASIDE_INFORMATION;
pub type PSYSTEM_LOOKASIDE_INFORMATION = *mut _SYSTEM_LOOKASIDE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_INTERRUPT_INFORMATION {
    pub Reserved1: [BYTE; 24usize],
}
#[test]
fn bindgen_test_layout__SYSTEM_INTERRUPT_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_INTERRUPT_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_INTERRUPT_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_SYSTEM_INTERRUPT_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_INTERRUPT_INFORMATION>(),
        1usize,
        concat!("Alignment of ", stringify!(_SYSTEM_INTERRUPT_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_INTERRUPT_INFORMATION),
            "::",
            stringify!(Reserved1)
        )
    );
}
pub type SYSTEM_INTERRUPT_INFORMATION = _SYSTEM_INTERRUPT_INFORMATION;
pub type PSYSTEM_INTERRUPT_INFORMATION = *mut _SYSTEM_INTERRUPT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_POLICY_INFORMATION {
    pub Reserved1: [PVOID; 2usize],
    pub Reserved2: [ULONG; 3usize],
}
#[test]
fn bindgen_test_layout__SYSTEM_POLICY_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_POLICY_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_POLICY_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_SYSTEM_POLICY_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_POLICY_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYSTEM_POLICY_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POLICY_INFORMATION),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POLICY_INFORMATION),
            "::",
            stringify!(Reserved2)
        )
    );
}
pub type SYSTEM_POLICY_INFORMATION = _SYSTEM_POLICY_INFORMATION;
pub type PSYSTEM_POLICY_INFORMATION = *mut _SYSTEM_POLICY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_HANDLE_ENTRY {
    pub OwnerPid: ULONG,
    pub ObjectType: BYTE,
    pub HandleFlags: BYTE,
    pub HandleValue: USHORT,
    pub ObjectPointer: PVOID,
    pub AccessMask: ULONG,
}
#[test]
fn bindgen_test_layout__SYSTEM_HANDLE_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_HANDLE_ENTRY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_HANDLE_ENTRY>(),
        24usize,
        concat!("Size of: ", stringify!(_SYSTEM_HANDLE_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_HANDLE_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYSTEM_HANDLE_ENTRY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OwnerPid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_HANDLE_ENTRY),
            "::",
            stringify!(OwnerPid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_HANDLE_ENTRY),
            "::",
            stringify!(ObjectType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HandleFlags) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_HANDLE_ENTRY),
            "::",
            stringify!(HandleFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HandleValue) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_HANDLE_ENTRY),
            "::",
            stringify!(HandleValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ObjectPointer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_HANDLE_ENTRY),
            "::",
            stringify!(ObjectPointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccessMask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_HANDLE_ENTRY),
            "::",
            stringify!(AccessMask)
        )
    );
}
pub type SYSTEM_HANDLE_ENTRY = _SYSTEM_HANDLE_ENTRY;
pub type PSYSTEM_HANDLE_ENTRY = *mut _SYSTEM_HANDLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_HANDLE_INFORMATION {
    pub Count: ULONG,
    pub Handle: [SYSTEM_HANDLE_ENTRY; 1usize],
}
#[test]
fn bindgen_test_layout__SYSTEM_HANDLE_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_HANDLE_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_HANDLE_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_SYSTEM_HANDLE_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_HANDLE_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYSTEM_HANDLE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_HANDLE_INFORMATION),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_HANDLE_INFORMATION),
            "::",
            stringify!(Handle)
        )
    );
}
pub type SYSTEM_HANDLE_INFORMATION = _SYSTEM_HANDLE_INFORMATION;
pub type PSYSTEM_HANDLE_INFORMATION = *mut _SYSTEM_HANDLE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_PAGEFILE_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub CurrentSize: ULONG,
    pub TotalUsed: ULONG,
    pub PeakUsed: ULONG,
    pub FileName: UNICODE_STRING,
}
#[test]
fn bindgen_test_layout__SYSTEM_PAGEFILE_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_PAGEFILE_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_PAGEFILE_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_SYSTEM_PAGEFILE_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_PAGEFILE_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYSTEM_PAGEFILE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PAGEFILE_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PAGEFILE_INFORMATION),
            "::",
            stringify!(CurrentSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalUsed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PAGEFILE_INFORMATION),
            "::",
            stringify!(TotalUsed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PeakUsed) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PAGEFILE_INFORMATION),
            "::",
            stringify!(PeakUsed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PAGEFILE_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type SYSTEM_PAGEFILE_INFORMATION = _SYSTEM_PAGEFILE_INFORMATION;
pub type PSYSTEM_PAGEFILE_INFORMATION = *mut _SYSTEM_PAGEFILE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PUBLIC_OBJECT_BASIC_INFORMATION {
    pub Attributes: ULONG,
    pub GrantedAccess: ACCESS_MASK,
    pub HandleCount: ULONG,
    pub PointerCount: ULONG,
    pub Reserved: [ULONG; 10usize],
}
#[test]
fn bindgen_test_layout__PUBLIC_OBJECT_BASIC_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_PUBLIC_OBJECT_BASIC_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PUBLIC_OBJECT_BASIC_INFORMATION>(),
        56usize,
        concat!("Size of: ", stringify!(_PUBLIC_OBJECT_BASIC_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_PUBLIC_OBJECT_BASIC_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PUBLIC_OBJECT_BASIC_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Attributes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PUBLIC_OBJECT_BASIC_INFORMATION),
            "::",
            stringify!(Attributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GrantedAccess) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PUBLIC_OBJECT_BASIC_INFORMATION),
            "::",
            stringify!(GrantedAccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HandleCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PUBLIC_OBJECT_BASIC_INFORMATION),
            "::",
            stringify!(HandleCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PointerCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_PUBLIC_OBJECT_BASIC_INFORMATION),
            "::",
            stringify!(PointerCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PUBLIC_OBJECT_BASIC_INFORMATION),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type PUBLIC_OBJECT_BASIC_INFORMATION = _PUBLIC_OBJECT_BASIC_INFORMATION;
pub type PPUBLIC_OBJECT_BASIC_INFORMATION = *mut _PUBLIC_OBJECT_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __PUBLIC_OBJECT_TYPE_INFORMATION {
    pub TypeName: UNICODE_STRING,
    pub Reserved: [ULONG; 22usize],
}
#[test]
fn bindgen_test_layout___PUBLIC_OBJECT_TYPE_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<__PUBLIC_OBJECT_TYPE_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__PUBLIC_OBJECT_TYPE_INFORMATION>(),
        104usize,
        concat!("Size of: ", stringify!(__PUBLIC_OBJECT_TYPE_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<__PUBLIC_OBJECT_TYPE_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__PUBLIC_OBJECT_TYPE_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TypeName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__PUBLIC_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(TypeName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__PUBLIC_OBJECT_TYPE_INFORMATION),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type PUBLIC_OBJECT_TYPE_INFORMATION = __PUBLIC_OBJECT_TYPE_INFORMATION;
pub type PPUBLIC_OBJECT_TYPE_INFORMATION = *mut __PUBLIC_OBJECT_TYPE_INFORMATION;
pub const _PROCESSINFOCLASS_ProcessBasicInformation: _PROCESSINFOCLASS = 0;
pub const _PROCESSINFOCLASS_ProcessQuotaLimits: _PROCESSINFOCLASS = 1;
pub const _PROCESSINFOCLASS_ProcessIoCounters: _PROCESSINFOCLASS = 2;
pub const _PROCESSINFOCLASS_ProcessVmCounters: _PROCESSINFOCLASS = 3;
pub const _PROCESSINFOCLASS_ProcessTimes: _PROCESSINFOCLASS = 4;
pub const _PROCESSINFOCLASS_ProcessBasePriority: _PROCESSINFOCLASS = 5;
pub const _PROCESSINFOCLASS_ProcessRaisePriority: _PROCESSINFOCLASS = 6;
pub const _PROCESSINFOCLASS_ProcessDebugPort: _PROCESSINFOCLASS = 7;
pub const _PROCESSINFOCLASS_ProcessExceptionPort: _PROCESSINFOCLASS = 8;
pub const _PROCESSINFOCLASS_ProcessAccessToken: _PROCESSINFOCLASS = 9;
pub const _PROCESSINFOCLASS_ProcessLdtInformation: _PROCESSINFOCLASS = 10;
pub const _PROCESSINFOCLASS_ProcessLdtSize: _PROCESSINFOCLASS = 11;
pub const _PROCESSINFOCLASS_ProcessDefaultHardErrorMode: _PROCESSINFOCLASS = 12;
pub const _PROCESSINFOCLASS_ProcessIoPortHandlers: _PROCESSINFOCLASS = 13;
pub const _PROCESSINFOCLASS_ProcessPooledUsageAndLimits: _PROCESSINFOCLASS = 14;
pub const _PROCESSINFOCLASS_ProcessWorkingSetWatch: _PROCESSINFOCLASS = 15;
pub const _PROCESSINFOCLASS_ProcessUserModeIOPL: _PROCESSINFOCLASS = 16;
pub const _PROCESSINFOCLASS_ProcessEnableAlignmentFaultFixup: _PROCESSINFOCLASS = 17;
pub const _PROCESSINFOCLASS_ProcessPriorityClass: _PROCESSINFOCLASS = 18;
pub const _PROCESSINFOCLASS_ProcessWx86Information: _PROCESSINFOCLASS = 19;
pub const _PROCESSINFOCLASS_ProcessHandleCount: _PROCESSINFOCLASS = 20;
pub const _PROCESSINFOCLASS_ProcessAffinityMask: _PROCESSINFOCLASS = 21;
pub const _PROCESSINFOCLASS_ProcessPriorityBoost: _PROCESSINFOCLASS = 22;
pub const _PROCESSINFOCLASS_ProcessDeviceMap: _PROCESSINFOCLASS = 23;
pub const _PROCESSINFOCLASS_ProcessSessionInformation: _PROCESSINFOCLASS = 24;
pub const _PROCESSINFOCLASS_ProcessForegroundInformation: _PROCESSINFOCLASS = 25;
pub const _PROCESSINFOCLASS_ProcessWow64Information: _PROCESSINFOCLASS = 26;
pub const _PROCESSINFOCLASS_ProcessImageFileName: _PROCESSINFOCLASS = 27;
pub const _PROCESSINFOCLASS_ProcessLUIDDeviceMapsEnabled: _PROCESSINFOCLASS = 28;
pub const _PROCESSINFOCLASS_ProcessBreakOnTermination: _PROCESSINFOCLASS = 29;
pub const _PROCESSINFOCLASS_ProcessDebugObjectHandle: _PROCESSINFOCLASS = 30;
pub const _PROCESSINFOCLASS_ProcessDebugFlags: _PROCESSINFOCLASS = 31;
pub const _PROCESSINFOCLASS_ProcessHandleTracing: _PROCESSINFOCLASS = 32;
pub const _PROCESSINFOCLASS_ProcessIoPriority: _PROCESSINFOCLASS = 33;
pub const _PROCESSINFOCLASS_ProcessExecuteFlags: _PROCESSINFOCLASS = 34;
pub const _PROCESSINFOCLASS_ProcessTlsInformation: _PROCESSINFOCLASS = 35;
pub const _PROCESSINFOCLASS_ProcessCookie: _PROCESSINFOCLASS = 36;
pub const _PROCESSINFOCLASS_ProcessImageInformation: _PROCESSINFOCLASS = 37;
pub const _PROCESSINFOCLASS_ProcessCycleTime: _PROCESSINFOCLASS = 38;
pub const _PROCESSINFOCLASS_ProcessPagePriority: _PROCESSINFOCLASS = 39;
pub const _PROCESSINFOCLASS_ProcessInstrumentationCallback: _PROCESSINFOCLASS = 40;
pub const _PROCESSINFOCLASS_ProcessThreadStackAllocation: _PROCESSINFOCLASS = 41;
pub const _PROCESSINFOCLASS_ProcessWorkingSetWatchEx: _PROCESSINFOCLASS = 42;
pub const _PROCESSINFOCLASS_ProcessImageFileNameWin32: _PROCESSINFOCLASS = 43;
pub const _PROCESSINFOCLASS_ProcessImageFileMapping: _PROCESSINFOCLASS = 44;
pub const _PROCESSINFOCLASS_ProcessAffinityUpdateMode: _PROCESSINFOCLASS = 45;
pub const _PROCESSINFOCLASS_ProcessMemoryAllocationMode: _PROCESSINFOCLASS = 46;
pub const _PROCESSINFOCLASS_ProcessGroupInformation: _PROCESSINFOCLASS = 47;
pub const _PROCESSINFOCLASS_ProcessTokenVirtualizationEnabled: _PROCESSINFOCLASS = 48;
pub const _PROCESSINFOCLASS_ProcessConsoleHostProcess: _PROCESSINFOCLASS = 49;
pub const _PROCESSINFOCLASS_ProcessWindowInformation: _PROCESSINFOCLASS = 50;
pub const _PROCESSINFOCLASS_MaxProcessInfoClass: _PROCESSINFOCLASS = 51;
pub type _PROCESSINFOCLASS = ::std::os::raw::c_uint;
pub use self::_PROCESSINFOCLASS as PROCESSINFOCLASS;
pub const _THREADINFOCLASS_ThreadBasicInformation: _THREADINFOCLASS = 0;
pub const _THREADINFOCLASS_ThreadTimes: _THREADINFOCLASS = 1;
pub const _THREADINFOCLASS_ThreadPriority: _THREADINFOCLASS = 2;
pub const _THREADINFOCLASS_ThreadBasePriority: _THREADINFOCLASS = 3;
pub const _THREADINFOCLASS_ThreadAffinityMask: _THREADINFOCLASS = 4;
pub const _THREADINFOCLASS_ThreadImpersonationToken: _THREADINFOCLASS = 5;
pub const _THREADINFOCLASS_ThreadDescriptorTableEntry: _THREADINFOCLASS = 6;
pub const _THREADINFOCLASS_ThreadEnableAlignmentFaultFixup: _THREADINFOCLASS = 7;
pub const _THREADINFOCLASS_ThreadEventPair: _THREADINFOCLASS = 8;
pub const _THREADINFOCLASS_ThreadQuerySetWin32StartAddress: _THREADINFOCLASS = 9;
pub const _THREADINFOCLASS_ThreadZeroTlsCell: _THREADINFOCLASS = 10;
pub const _THREADINFOCLASS_ThreadPerformanceCount: _THREADINFOCLASS = 11;
pub const _THREADINFOCLASS_ThreadAmILastThread: _THREADINFOCLASS = 12;
pub const _THREADINFOCLASS_ThreadIdealProcessor: _THREADINFOCLASS = 13;
pub const _THREADINFOCLASS_ThreadPriorityBoost: _THREADINFOCLASS = 14;
pub const _THREADINFOCLASS_ThreadSetTlsArrayAddress: _THREADINFOCLASS = 15;
pub const _THREADINFOCLASS_ThreadIsIoPending: _THREADINFOCLASS = 16;
pub const _THREADINFOCLASS_ThreadHideFromDebugger: _THREADINFOCLASS = 17;
pub type _THREADINFOCLASS = ::std::os::raw::c_uint;
pub use self::_THREADINFOCLASS as THREADINFOCLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _THREAD_NAME_INFORMATION {
    pub ThreadName: UNICODE_STRING,
}
#[test]
fn bindgen_test_layout__THREAD_NAME_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_THREAD_NAME_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_THREAD_NAME_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_THREAD_NAME_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_THREAD_NAME_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_THREAD_NAME_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ThreadName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_THREAD_NAME_INFORMATION),
            "::",
            stringify!(ThreadName)
        )
    );
}
pub type THREAD_NAME_INFORMATION = _THREAD_NAME_INFORMATION;
pub type PTHREAD_NAME_INFORMATION = *mut _THREAD_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_CODEINTEGRITY_INFORMATION {
    pub Length: ULONG,
    pub CodeIntegrityOptions: ULONG,
}
#[test]
fn bindgen_test_layout__SYSTEM_CODEINTEGRITY_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYSTEM_CODEINTEGRITY_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_CODEINTEGRITY_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_SYSTEM_CODEINTEGRITY_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_CODEINTEGRITY_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_CODEINTEGRITY_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CODEINTEGRITY_INFORMATION),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CodeIntegrityOptions) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CODEINTEGRITY_INFORMATION),
            "::",
            stringify!(CodeIntegrityOptions)
        )
    );
}
pub type SYSTEM_CODEINTEGRITY_INFORMATION = _SYSTEM_CODEINTEGRITY_INFORMATION;
pub type PSYSTEM_CODEINTEGRITY_INFORMATION = *mut _SYSTEM_CODEINTEGRITY_INFORMATION;
pub const _SYSTEM_INFORMATION_CLASS_SystemBasicInformation: _SYSTEM_INFORMATION_CLASS = 0;
pub const _SYSTEM_INFORMATION_CLASS_SystemProcessorInformation: _SYSTEM_INFORMATION_CLASS = 1;
pub const _SYSTEM_INFORMATION_CLASS_SystemPerformanceInformation: _SYSTEM_INFORMATION_CLASS = 2;
pub const _SYSTEM_INFORMATION_CLASS_SystemTimeOfDayInformation: _SYSTEM_INFORMATION_CLASS = 3;
pub const _SYSTEM_INFORMATION_CLASS_SystemProcessInformation: _SYSTEM_INFORMATION_CLASS = 5;
pub const _SYSTEM_INFORMATION_CLASS_SystemProcessorPerformanceInformation:
    _SYSTEM_INFORMATION_CLASS = 8;
pub const _SYSTEM_INFORMATION_CLASS_SystemHandleInformation: _SYSTEM_INFORMATION_CLASS = 16;
pub const _SYSTEM_INFORMATION_CLASS_SystemPagefileInformation: _SYSTEM_INFORMATION_CLASS = 18;
pub const _SYSTEM_INFORMATION_CLASS_SystemInterruptInformation: _SYSTEM_INFORMATION_CLASS = 23;
pub const _SYSTEM_INFORMATION_CLASS_SystemExceptionInformation: _SYSTEM_INFORMATION_CLASS = 33;
pub const _SYSTEM_INFORMATION_CLASS_SystemRegistryQuotaInformation: _SYSTEM_INFORMATION_CLASS = 37;
pub const _SYSTEM_INFORMATION_CLASS_SystemLookasideInformation: _SYSTEM_INFORMATION_CLASS = 45;
pub const _SYSTEM_INFORMATION_CLASS_SystemCodeIntegrityInformation: _SYSTEM_INFORMATION_CLASS = 103;
pub const _SYSTEM_INFORMATION_CLASS_SystemPolicyInformation: _SYSTEM_INFORMATION_CLASS = 134;
pub type _SYSTEM_INFORMATION_CLASS = ::std::os::raw::c_uint;
pub use self::_SYSTEM_INFORMATION_CLASS as SYSTEM_INFORMATION_CLASS;
pub const _OBJECT_INFORMATION_CLASS_ObjectBasicInformation: _OBJECT_INFORMATION_CLASS = 0;
pub const _OBJECT_INFORMATION_CLASS_ObjectNameInformation: _OBJECT_INFORMATION_CLASS = 1;
pub const _OBJECT_INFORMATION_CLASS_ObjectTypeInformation: _OBJECT_INFORMATION_CLASS = 2;
pub const _OBJECT_INFORMATION_CLASS_ObjectAllInformation: _OBJECT_INFORMATION_CLASS = 3;
pub const _OBJECT_INFORMATION_CLASS_ObjectDataInformation: _OBJECT_INFORMATION_CLASS = 4;
pub type _OBJECT_INFORMATION_CLASS = ::std::os::raw::c_uint;
pub use self::_OBJECT_INFORMATION_CLASS as OBJECT_INFORMATION_CLASS;
pub type POBJECT_INFORMATION_CLASS = *mut _OBJECT_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEY_VALUE_ENTRY {
    pub ValueName: PUNICODE_STRING,
    pub DataLength: ULONG,
    pub DataOffset: ULONG,
    pub Type: ULONG,
}
#[test]
fn bindgen_test_layout__KEY_VALUE_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_KEY_VALUE_ENTRY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_KEY_VALUE_ENTRY>(),
        24usize,
        concat!("Size of: ", stringify!(_KEY_VALUE_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_KEY_VALUE_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_KEY_VALUE_ENTRY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ValueName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KEY_VALUE_ENTRY),
            "::",
            stringify!(ValueName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KEY_VALUE_ENTRY),
            "::",
            stringify!(DataLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataOffset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_KEY_VALUE_ENTRY),
            "::",
            stringify!(DataOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KEY_VALUE_ENTRY),
            "::",
            stringify!(Type)
        )
    );
}
pub type KEY_VALUE_ENTRY = _KEY_VALUE_ENTRY;
pub type PKEY_VALUE_ENTRY = *mut _KEY_VALUE_ENTRY;
pub const _KEY_SET_INFORMATION_CLASS_KeyWriteTimeInformation: _KEY_SET_INFORMATION_CLASS = 0;
pub const _KEY_SET_INFORMATION_CLASS_KeyWow64FlagsInformation: _KEY_SET_INFORMATION_CLASS = 1;
pub const _KEY_SET_INFORMATION_CLASS_KeyControlFlagsInformation: _KEY_SET_INFORMATION_CLASS = 2;
pub const _KEY_SET_INFORMATION_CLASS_KeySetVirtualizationInformation: _KEY_SET_INFORMATION_CLASS =
    3;
pub const _KEY_SET_INFORMATION_CLASS_KeySetDebugInformation: _KEY_SET_INFORMATION_CLASS = 4;
pub const _KEY_SET_INFORMATION_CLASS_KeySetHandleTagsInformation: _KEY_SET_INFORMATION_CLASS = 5;
pub const _KEY_SET_INFORMATION_CLASS_MaxKeySetInfoClass: _KEY_SET_INFORMATION_CLASS = 6;
pub type _KEY_SET_INFORMATION_CLASS = ::std::os::raw::c_uint;
pub use self::_KEY_SET_INFORMATION_CLASS as KEY_SET_INFORMATION_CLASS;
extern "C" {
    pub fn NtClose(Handle: HANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn NtCreateFile(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        AllocationSize: PLARGE_INTEGER,
        FileAttributes: ULONG,
        ShareAccess: ULONG,
        CreateDisposition: ULONG,
        CreateOptions: ULONG,
        EaBuffer: PVOID,
        EaLength: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn NtOpenFile(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        ShareAccess: ULONG,
        OpenOptions: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn NtRenameKey(KeyHandle: HANDLE, NewName: PUNICODE_STRING) -> NTSTATUS;
}
extern "C" {
    pub fn NtNotifyChangeMultipleKeys(
        MasterKeyHandle: HANDLE,
        Count: ULONG,
        SubordinateObjects: *mut OBJECT_ATTRIBUTES,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        CompletionFilter: ULONG,
        WatchTree: BOOLEAN,
        Buffer: PVOID,
        BufferSize: ULONG,
        Asynchronous: BOOLEAN,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn NtQueryMultipleValueKey(
        KeyHandle: HANDLE,
        ValueEntries: PKEY_VALUE_ENTRY,
        EntryCount: ULONG,
        ValueBuffer: PVOID,
        BufferLength: PULONG,
        RequiredBufferLength: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn NtSetInformationKey(
        KeyHandle: HANDLE,
        KeySetInformationClass: KEY_SET_INFORMATION_CLASS,
        KeySetInformation: PVOID,
        KeySetInformationLength: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn NtFsControlFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        IoControlCode: ULONG,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn NtDeviceIoControlFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        IoControlCode: ULONG,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn NtWaitForSingleObject(
        Handle: HANDLE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn RtlIsNameLegalDOS8Dot3(
        Name: PUNICODE_STRING,
        OemName: POEM_STRING,
        NameContainsSpaces: PBOOLEAN,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn RtlNtStatusToDosError(Status: NTSTATUS) -> ULONG;
}
extern "C" {
    pub fn NtQueryInformationProcess(
        ProcessHandle: HANDLE,
        ProcessInformationClass: PROCESSINFOCLASS,
        ProcessInformation: PVOID,
        ProcessInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn NtQueryInformationThread(
        ThreadHandle: HANDLE,
        ThreadInformationClass: THREADINFOCLASS,
        ThreadInformation: PVOID,
        ThreadInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn NtSetInformationThread(
        ThreadHandle: HANDLE,
        ThreadInformationClass: THREADINFOCLASS,
        ThreadInformation: PVOID,
        ThreadInformationLength: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn NtQueryInformationFile(
        hFile: HANDLE,
        io: PIO_STATUS_BLOCK,
        ptr: PVOID,
        len: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn NtQueryObject(
        Handle: HANDLE,
        ObjectInformationClass: OBJECT_INFORMATION_CLASS,
        ObjectInformation: PVOID,
        ObjectInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn NtQuerySystemInformation(
        SystemInformationClass: SYSTEM_INFORMATION_CLASS,
        SystemInformation: PVOID,
        SystemInformationLength: ULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn NtQuerySystemTime(SystemTime: PLARGE_INTEGER) -> NTSTATUS;
}
extern "C" {
    pub fn NtQueryTimerResolution(
        MaximumTime: PULONG,
        MinimumTime: PULONG,
        CurrentTime: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn NtQueryVolumeInformationFile(
        hFile: HANDLE,
        io: PIO_STATUS_BLOCK,
        ptr: PVOID,
        len: ULONG,
        FsInformationClass: FS_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn NtSetInformationFile(
        hFile: HANDLE,
        io: PIO_STATUS_BLOCK,
        ptr: PVOID,
        len: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn NtSetInformationProcess(
        ProcessHandle: HANDLE,
        ProcessInformationClass: PROCESSINFOCLASS,
        ProcessInformation: PVOID,
        ProcessInformationLength: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn NtSetVolumeInformationFile(
        hFile: HANDLE,
        io: PIO_STATUS_BLOCK,
        ptr: PVOID,
        len: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn RtlLocalTimeToSystemTime(
        LocalTime: PLARGE_INTEGER,
        SystemTime: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn RtlTimeToSecondsSince1970(Time: PLARGE_INTEGER, ElapsedSeconds: PULONG) -> BOOLEAN;
}
extern "C" {
    pub fn RtlFreeAnsiString(AnsiString: PANSI_STRING);
}
extern "C" {
    pub fn RtlFreeUnicodeString(UnicodeString: PUNICODE_STRING);
}
extern "C" {
    pub fn RtlFreeOemString(OemString: POEM_STRING);
}
extern "C" {
    pub fn RtlInitString(DestinationString: PSTRING, SourceString: PCSZ);
}
extern "C" {
    pub fn RtlInitStringEx(DestinationString: PSTRING, SourceString: PCSZ) -> NTSTATUS;
}
extern "C" {
    pub fn RtlInitAnsiString(DestinationString: PANSI_STRING, SourceString: PCSZ);
}
extern "C" {
    pub fn RtlInitAnsiStringEx(DestinationString: PANSI_STRING, SourceString: PCSZ) -> NTSTATUS;
}
extern "C" {
    pub fn RtlInitUnicodeString(DestinationString: PUNICODE_STRING, SourceString: PCWSTR);
}
extern "C" {
    pub fn RtlAnsiStringToUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PCANSI_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn RtlUnicodeStringToAnsiString(
        DestinationString: PANSI_STRING,
        SourceString: PCUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn RtlUnicodeStringToOemString(
        DestinationString: POEM_STRING,
        SourceString: PCUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn RtlUnicodeToMultiByteSize(
        BytesInMultiByteString: PULONG,
        UnicodeString: PWCH,
        BytesInUnicodeString: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn RtlCharToInteger(String: PCSZ, Base: ULONG, Value: PULONG) -> NTSTATUS;
}
extern "C" {
    pub fn RtlConvertSidToUnicodeString(
        UnicodeString: PUNICODE_STRING,
        Sid: PSID,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn RtlUniform(Seed: PULONG) -> ULONG;
}
extern "C" {
    pub fn RtlDosPathNameToNtPathName_U(
        DosPathName: PCWSTR,
        NtPathName: PUNICODE_STRING,
        NtFileNamePart: *mut PCWSTR,
        DirectoryInfo: *mut ::std::os::raw::c_void,
    ) -> BOOL;
}
extern "C" {
    pub fn RtlPrefixUnicodeString(
        String1: PCUNICODE_STRING,
        String2: PCUNICODE_STRING,
        CaseInSensitive: BOOLEAN,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn RtlCreateUnicodeStringFromAsciiz(target: PUNICODE_STRING, src: LPCSTR) -> BOOLEAN;
}
pub type PRTL_HEAP_COMMIT_ROUTINE = ::std::option::Option<
    unsafe extern "C" fn(Base: PVOID, CommitAddress: *mut PVOID, CommitSize: PSIZE_T) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_HEAP_PARAMETERS {
    pub Length: ULONG,
    pub SegmentReserve: SIZE_T,
    pub SegmentCommit: SIZE_T,
    pub DeCommitFreeBlockThreshold: SIZE_T,
    pub DeCommitTotalFreeThreshold: SIZE_T,
    pub MaximumAllocationSize: SIZE_T,
    pub VirtualMemoryThreshold: SIZE_T,
    pub InitialCommit: SIZE_T,
    pub InitialReserve: SIZE_T,
    pub CommitRoutine: PRTL_HEAP_COMMIT_ROUTINE,
    pub Reserved: [SIZE_T; 2usize],
}
#[test]
fn bindgen_test_layout__RTL_HEAP_PARAMETERS() {
    const UNINIT: ::std::mem::MaybeUninit<_RTL_HEAP_PARAMETERS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RTL_HEAP_PARAMETERS>(),
        96usize,
        concat!("Size of: ", stringify!(_RTL_HEAP_PARAMETERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_HEAP_PARAMETERS>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_HEAP_PARAMETERS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_HEAP_PARAMETERS),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SegmentReserve) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_HEAP_PARAMETERS),
            "::",
            stringify!(SegmentReserve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SegmentCommit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_HEAP_PARAMETERS),
            "::",
            stringify!(SegmentCommit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeCommitFreeBlockThreshold) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_HEAP_PARAMETERS),
            "::",
            stringify!(DeCommitFreeBlockThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeCommitTotalFreeThreshold) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_HEAP_PARAMETERS),
            "::",
            stringify!(DeCommitTotalFreeThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumAllocationSize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_HEAP_PARAMETERS),
            "::",
            stringify!(MaximumAllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VirtualMemoryThreshold) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_HEAP_PARAMETERS),
            "::",
            stringify!(VirtualMemoryThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InitialCommit) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_HEAP_PARAMETERS),
            "::",
            stringify!(InitialCommit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InitialReserve) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_HEAP_PARAMETERS),
            "::",
            stringify!(InitialReserve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CommitRoutine) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_HEAP_PARAMETERS),
            "::",
            stringify!(CommitRoutine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_HEAP_PARAMETERS),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type RTL_HEAP_PARAMETERS = _RTL_HEAP_PARAMETERS;
pub type PRTL_HEAP_PARAMETERS = *mut _RTL_HEAP_PARAMETERS;
extern "C" {
    pub fn RtlFreeHeap(HeapHandle: PVOID, Flags: ULONG, HeapBase: PVOID) -> BOOLEAN;
}
extern "C" {
    pub fn RtlAllocateHeap(HeapHandle: PVOID, Flags: ULONG, Size: SIZE_T) -> PVOID;
}
extern "C" {
    pub fn RtlCreateHeap(
        Flags: ULONG,
        HeapBase: PVOID,
        ReserveSize: SIZE_T,
        CommitSize: SIZE_T,
        Lock: PVOID,
        Parameters: PRTL_HEAP_PARAMETERS,
    ) -> PVOID;
}
extern "C" {
    pub fn RtlDestroyHeap(HeapHandle: PVOID) -> PVOID;
}
pub const _WINSTATIONINFOCLASS_WinStationInformation: _WINSTATIONINFOCLASS = 8;
pub type _WINSTATIONINFOCLASS = ::std::os::raw::c_uint;
pub use self::_WINSTATIONINFOCLASS as WINSTATIONINFOCLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WINSTATIONINFORMATIONW {
    pub Reserved2: [BYTE; 70usize],
    pub LogonId: ULONG,
    pub Reserved3: [BYTE; 1140usize],
}
#[test]
fn bindgen_test_layout__WINSTATIONINFORMATIONW() {
    const UNINIT: ::std::mem::MaybeUninit<_WINSTATIONINFORMATIONW> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_WINSTATIONINFORMATIONW>(),
        1216usize,
        concat!("Size of: ", stringify!(_WINSTATIONINFORMATIONW))
    );
    assert_eq!(
        ::std::mem::align_of::<_WINSTATIONINFORMATIONW>(),
        4usize,
        concat!("Alignment of ", stringify!(_WINSTATIONINFORMATIONW))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WINSTATIONINFORMATIONW),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LogonId) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_WINSTATIONINFORMATIONW),
            "::",
            stringify!(LogonId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_WINSTATIONINFORMATIONW),
            "::",
            stringify!(Reserved3)
        )
    );
}
pub type WINSTATIONINFORMATIONW = _WINSTATIONINFORMATIONW;
pub type PWINSTATIONINFORMATIONW = *mut _WINSTATIONINFORMATIONW;
pub type PWINSTATIONQUERYINFORMATIONW = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: HANDLE,
        arg2: ULONG,
        arg3: WINSTATIONINFOCLASS,
        arg4: PVOID,
        arg5: ULONG,
        arg6: PULONG,
    ) -> BOOLEAN,
>;
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT {
    pub _address: u8,
}
